{"meta":{"title":"Shan San","subtitle":"个人博客","description":"个人休憩小站","author":"Shan San","url":"https://yeshan333.github.io","root":"/"},"pages":[{"title":"","date":"2019-08-03T10:12:16.443Z","updated":"2018-09-25T09:28:04.224Z","comments":true,"path":"baidu_verify_XRNJycrlKL.html","permalink":"https://yeshan333.github.io/baidu_verify_XRNJycrlKL.html","excerpt":"","text":"XRNJycrlKL"},{"title":"","date":"2019-08-03T10:12:16.443Z","updated":"2018-09-25T09:58:08.927Z","comments":true,"path":"googlec01c2945d8a3c128.html","permalink":"https://yeshan333.github.io/googlec01c2945d8a3c128.html","excerpt":"","text":"google-site-verification: googlec01c2945d8a3c128.html"},{"title":"Astronomy","date":"2018-10-09T05:26:08.000Z","updated":"2018-10-12T07:55:18.222Z","comments":true,"path":"Astronomy/index.html","permalink":"https://yeshan333.github.io/Astronomy/index.html","excerpt":"","text":"北京天文馆每日天文一图NASA &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;天上的街市作者：郭沫若远远的街灯明了，好像闪着无数的明星。天上的明星现了，好像点着无数的街灯。我想那缥缈的空中，定然有美丽的街市。街市上陈列的一些物品，定然是世上没有的珍奇。你看，那浅浅的天河，定然是不甚宽广。那隔河的牛郎织女，定能够骑着牛儿来往。我想他们此刻，定然在天街闲游。不信，请看那朵流星，那怕是他们提着灯笼在走。 一天文单位（AU）=149,597,870.7公里（日地距离） 一光年=63241.1 AU=946e+12公里"},{"title":"404 Not Found","date":"2019-08-03T10:12:16.443Z","updated":"2019-03-21T18:04:19.936Z","comments":false,"path":"/404.html","permalink":"https://yeshan333.github.io//404.html","excerpt":"","text":"&lt;!DOCTYPE html&gt; ]\\ 404"},{"title":"Collect","date":"2019-01-08T14:39:26.000Z","updated":"2019-01-08T15:24:14.700Z","comments":true,"path":"Collect/index.html","permalink":"https://yeshan333.github.io/Collect/index.html","excerpt":"","text":"Tools小记 description tools Link 截屏工具 Snipaste https://zh.snipaste.com/ 录屏工具 oCam https://download.cnet.com/oCam/3000-13633_4-75758209.html 清理工具 CCleaner https://www.ccleaner.com/ccleaner 远程连接工具 Xshell https://www.netsarang.com/products/xsh_overview.html 搜索利器 Everything http://www.voidtools.com/ Markdown编辑器 typora https://www.typora.io/ Shadowsocks-Qt5 影梭 https://github.com/shadowsocks/shadowsocks-qt5 windows数字权利激活工具 CMWTAT_Digital_Edition https://tgsan.github.io/CMWTAT_Digital_Edition/ 镜像制作 WPE工具箱 http://udsdown.xyz/109.html 镜像制作 refus https://rufus.ie/ 启动项管理 EasyUEFI https://www.easyuefi.com/index-cn.html 压缩工具 7-zip https://www.7-zip.org/ 优质文章小记用GDB调试程序 https://blog.csdn.net/haoel/article/details/2879 https://blog.csdn.net/haoel/article/details/2880?utm_source=blogxgwz2 https://blog.csdn.net/haoel/article/details/2881 https://blog.csdn.net/haoel/article/details/2882 https://blog.csdn.net/haoel/article/details/2883/ https://blog.csdn.net/haoel/article/details/2884 https://blog.csdn.net/haoel/article/details/2885/ https://coolshell.cn/articles/3643.html 跟我一起写Makefile https://blog.csdn.net/haoel/article/details/2886 https://blog.csdn.net/haoel/article/details/2887/ https://blog.csdn.net/haoel/article/details/2888 https://blog.csdn.net/haoel/article/details/2889/ https://blog.csdn.net/haoel/article/details/2890 https://blog.csdn.net/haoel/article/details/2891 https://blog.csdn.net/haoel/article/details/2892 https://blog.csdn.net/haoel/article/details/2893/ https://blog.csdn.net/haoel/article/details/2894 https://blog.csdn.net/haoel/article/details/2895 https://blog.csdn.net/haoel/article/details/2896 https://blog.csdn.net/haoel/article/details/2897 https://blog.csdn.net/haoel/article/details/2898 https://blog.csdn.net/haoel/article/details/2899"},{"title":"我想对我说","date":"2019-06-28T12:37:16.000Z","updated":"2019-07-02T08:54:20.358Z","comments":true,"path":"I_want_to_tell_me/index.html","permalink":"https://yeshan333.github.io/I_want_to_tell_me/index.html","excerpt":"","text":""},{"title":"PyChina","date":"2019-08-07T12:55:16.742Z","updated":"2019-08-07T12:55:16.742Z","comments":true,"path":"PyChina/index.html","permalink":"https://yeshan333.github.io/PyChina/index.html","excerpt":"","text":""},{"title":"Statement","date":"2019-03-14T12:30:46.000Z","updated":"2019-04-25T03:10:09.485Z","comments":true,"path":"Statement/index.html","permalink":"https://yeshan333.github.io/Statement/index.html","excerpt":"","text":"声明： 本站文章基于 知识共享署名-相同方式共享 4.0 国际许可协议发布，欢迎转载，演绎或用于商业目的，但是必须保留本站文章的署名 Shan San及链接。 作者： Shan San 出处： https://shansan.top/"},{"title":"About me","date":"2018-09-20T05:37:03.000Z","updated":"2019-12-25T05:12:56.374Z","comments":true,"path":"about/index.html","permalink":"https://yeshan333.github.io/about/index.html","excerpt":"","text":"聊一聊我是谁 在校kubi大三本科生，数学专业 目前在学习Web开发 我叫啥，请看下面 关于博客 2018年9月19日，本博诞生 初生博客是使用Hexo + Github Pages 搭建的，使用的主题是yilia 现在博客使用的hexo主题是xaoxuxu大佬写的Material-x 搭建这个博客的目的是为了记录部分自己平时的学习笔记 我发现我搭个博客学了很多花里胡哨的东西😂 emmm。。。有些话想到再说。 听歌可以戳下面，猛戳，别客气o(*≧▽≦)ツ┏━┓"},{"title":"所有分类","date":"2019-06-30T06:51:39.000Z","updated":"2019-06-30T06:52:19.600Z","comments":true,"path":"categories/index.html","permalink":"https://yeshan333.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-01-31T09:27:56.195Z","updated":"2020-01-31T09:27:56.195Z","comments":true,"path":"friends/index.html","permalink":"https://yeshan333.github.io/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-06-30T06:48:56.000Z","updated":"2019-06-30T06:51:15.163Z","comments":true,"path":"tags/index.html","permalink":"https://yeshan333.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"洞悉技术的本质-Git内部原理探索","slug":"Git内部原理探索","date":"2020-02-02T16:49:18.000Z","updated":"2020-02-02T17:20:43.367Z","comments":true,"path":"2020/02/03/Git内部原理探索/","link":"","permalink":"https://yeshan333.github.io/2020/02/03/Git内部原理探索/","excerpt":"前言洞悉技术的本质，可以让我们在层出不穷的框架面前仍能泰然处之。用了那么久的 Git，不懂点内部原理，那可不行！懂点原理可以让我们遇到问题的时候能够更好更快的理清解决问题的思路。 要真正读懂本文可能需要以下基础： 有 Git 使用经验 对 Git 的三个分区有所了解 熟悉常用的 Linux 命令 对经典哈希算法有一定的了解，比如SHA-1、SHA-256、MD5等 在开始之前，让我们先抛出几个问题，然后一一解决、回答它们 .git版本库里的文件/目录是干什么的? Git是如何存储文件信息的？ 当我们执行git add、git commit时，Git背后做了什么？ Git分支的本质是什么?","text":"前言洞悉技术的本质，可以让我们在层出不穷的框架面前仍能泰然处之。用了那么久的 Git，不懂点内部原理，那可不行！懂点原理可以让我们遇到问题的时候能够更好更快的理清解决问题的思路。 要真正读懂本文可能需要以下基础： 有 Git 使用经验 对 Git 的三个分区有所了解 熟悉常用的 Linux 命令 对经典哈希算法有一定的了解，比如SHA-1、SHA-256、MD5等 在开始之前，让我们先抛出几个问题，然后一一解决、回答它们 .git版本库里的文件/目录是干什么的? Git是如何存储文件信息的？ 当我们执行git add、git commit时，Git背后做了什么？ Git分支的本质是什么? Git分区在真正开始之前，让我们先回顾下Git的三个分区（Workspace、Index / Stage、git repository） 工作区（Workspace）：此处进行代码文件的编辑 索引或称暂存区（Index / Stage）：存储文件状态信息，进行commit前会对此时的文件状态作快照（Snapshot） Git版本库（git repository）：由Git Object持久记录每一次commit的快照和链式结构的commit变更历史 先看下从《Got Git》和网络上搬来的Git分区工作原理图和待remote的工作流再次感性回顾下之前使用Git自己时怎么操作的 相信看了这些，会对Git有新的认知，让我们正式开始🎉！ .git版本库里的文件/目录是干什么的让我们通过一个从GitHub clone下来的一个实际项目的版本库来看下这些文件/目录，clone下来的repository 12345678910111213$ git clone https://github.com/yeshan333/Explore-Git$ ls -F1configdescriptionHEADhooks/indexinfo/logs/objects/packed-refsrefs/ 挑几个重要文件/目录的做下解释 HEAD文件：用于存放当前所在分支的引用，这个引用是个符号引用（symbolic reference） index文件：二进制文件，它就是暂存区（Stage Area）。它是一个目录树，记录了文件的时间戳、文件长度、SHA-1等 refs目录：基本所有的引用（references）文件都存放在这里，引用文件中的内容为SHA-1值，一般是commit object的SHA-1值 objects目录：用于存放数据的所有 Git Object均存放在这个目录下，每个 Git Object 对应一个目录，object对应的SHA-1值的前 2 位为目录名，后 38 位为文件名 抱着一些初步的认知，我们继续解决后面几个问题，加深对.git版本库内文件的理解 Git是如何存储文件信息的要知道Git如何存储信息，我们需要了解一下常见的Git对象，Git就是通过这些对象存储文件信息的。Git Object是Git存储文件信息的最小单元，如下为几种常见的Git Object以及它们的作用，它们一般是不可变的（immutable），这些对象使用40位的SHA-1值进行标识。 blob：用于存储文件内容，Git保存文件的时候不会保存文件名 tree object：当前目录结构的一个快照（Snapshot），它存储了一条或多条树记录（tree entries），每条记录含有一个指向数据对象（blob）或子树对象（子树木对象可理解为子目录）的SHA-1指针以及相应的文件模式、类型、文件名，用于表示内容之间的目录层次关系 commit object：存储顶层tree object的SHA-1值、作者/提交者信息+时间戳以及提交注释，如果有父commit object，还会保存有这个commit object对应的SHA-1值。对于merge commit可能会有多个父commit object tag object：用于标记commit object。关于tag object 让我们通过一个实际的版本库了解下这些对象，使用git log查看这个版本库详尽的历史提交记录 123456789101112131415$ git log --pretty=rawcommit ee8a0dbc0c6fe89e6ff39b16c77543e8e2c6475btree fb12b3e52ce18ce281bfc2b11a5e4350c2d10358parent 7b94dcbe89c9534913854284b4af727a9a5dfc84author yeshan333 &lt;1329441308@qq.com&gt; 1580629391 +0800committer yeshan333 &lt;1329441308@qq.com&gt; 1580629391 +0800 final commitcommit 7b94dcbe89c9534913854284b4af727a9a5dfc84tree 8feb4afbab18e8d386413224a9e74f871c15a5caauthor yeshan333 &lt;1329441308@qq.com&gt; 1580629170 +0800committer GitHub &lt;noreply@github.com&gt; 1580629170 +0800 Initial commit Git提供了一把非常好用的瑞士军刀🔪给我们剖析这些对象，它是就是cat-file，通过-t参数可以查看object的类型，通过-p参数我们可以查看object存储的具体内容。查看信息时，我们需要使用到object对应的SHA-1值，可不必写完，从头开始的前几位不冲突即可。git cat-file 让我们通过它查看下SHA-1值ee8a0dbc0c6fe89e6ff39b16c77543e8e2c6475b对应的commit object的类型以及存放的内容。 12345678910$ git cat-file -t ee8acommit$ git cat-file -p ee8atree fb12b3e52ce18ce281bfc2b11a5e4350c2d10358parent 7b94dcbe89c9534913854284b4af727a9a5dfc84author yeshan333 &lt;1329441308@qq.com&gt; 1580629391 +0800committer yeshan333 &lt;1329441308@qq.com&gt; 1580629391 +0800final commit 让我们再查看下这个commit object（ee8a）存储的tree object（fb12）的信息 123456$ git cat-file -p fb12100644 blob 6116a7dd8f752dabff8730a46b46846b2d0a696b README.md040000 tree 41ed97c2adb97658107069582b6a27e474b4cc64 test$ git cat-file -t fb12tree 我们知道tree object存储了一条或多条树记录（tree entries），每条记录含有一个指向数据对象（blob）或子树对象（子树木对象可理解为子目录）的SHA-1指针以及相应的文件模式、类型、文件名。100644即为对应的文件模式，100644表示普通文本文件，040000表示目录文件。关于文件模式的一点疑问 让我们再看下tree object（fb12）存储的SHA-1指针（6116）对应的blob（6116）存放的内容 1234$ git cat-file -p 6116# Explore-Git$ git cat-file -t 6116blob Nice，很好的对应了之前对blob、tree object、commit object的描述。关于文件的大部分信息都存放在这些object中。 当我们执行git add、git commit时，Git背后做了什么解答这个问题，我们需要通过实践去一步步感受Git背后的操作。我们创建一个简单的例子感受下，我们需要时刻关注.git/objects这个目录 1234567891011$ mkdir demo$ cd demo$ git init # 初始化Git仓库$ find .git/objects -type f # 没有文件$ echo \"test\" &gt; test.txt$ mkdir hi$ cd hi$ echo \"Hello\" &gt; hello.txt$ cd ..$ find .git/objects -type f$ # 什么都没有 这里我们创建先了两个文件，test.txt、hello.txt，其中hello.txt文件放到了hi目录中，然后我们查看了.git/objects目录，没有文件。接下来就是重头戏了，我们要将当前目录的文件/目录（Linux一切皆文件）添加到暂存区（stage/index）。 1234$ git add .$ find .git/objects -type f.git/objects/9d/aeafb9864cf43055ae93beb0afd6c7d144bfa4.git/objects/e9/65047ad7c57865823c7d992b1d046ea66edf78 我们可以看到，执行了git add之后生成了两个文件，让我们通过git cat-file看看这两个文件 12345678$ git cat-file -t 9daeblob$ git cat-file -p 9daetest # test.txt文件中的内容$ git cat-file -t e965blob$ git cat-file -p e965Hello # hi/hello.txt文件中的内容 哦，Git为我们生成了两个object，两个blob，存放的是test.txt、hello.txt的内容，让我们commit一下看看Git又做了什么 123456789101112131415161718192021222324$ find .git/objects -type f.git/objects/27/1c49aa4a2c8eb1b2ef503c19378aa6810fca1e.git/objects/2e/8ebea76975c98806e73c0b7aea6c40c58d427c.git/objects/8c/3c7fbcd903744b20fd7567a1fcefa99133b5bc.git/objects/9d/aeafb9864cf43055ae93beb0afd6c7d144bfa4.git/objects/e9/65047ad7c57865823c7d992b1d046ea66edf78$ git cat-file -t 271ccommit$ git cat-file -t 2e8etree$ git cat-file -t 8c3ctree$$ git cat-file -p 271ctree 2e8ebea76975c98806e73c0b7aea6c40c58d427cauthor root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt; 1580651827 +0800committer root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt; 1580651827 +0800Hello Git$ git cat-file -p 8c3c100644 blob e965047ad7c57865823c7d992b1d046ea66edf78 hello.txt$ git cat-file -p 2e8e040000 tree 8c3c7fbcd903744b20fd7567a1fcefa99133b5bc hi100644 blob 9daeafb9864cf43055ae93beb0afd6c7d144bfa4 test.txt 哦，commit后Git为我们新创建了3个object，分别是根树对象tree object（2e8e）、子树对象tree object（8c3c）、commit object（271c）。现在一共有5个Git Object。这些object存放的内容符合我们在解答Git是如何存储文件信息的时对它们的表述。Git在add、commit后有条不紊的把它们组织了起来。tql👍 让我们看下此次提交的日志 1234567$ git log --pretty=rawcommit 271c49aa4a2c8eb1b2ef503c19378aa6810fca1etree 2e8ebea76975c98806e73c0b7aea6c40c58d427cauthor root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt; 1580651827 +0800committer root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt; 1580651827 +0800 Hello Git 问题来了，Git是如何组织这些object的❓令人兴奋的是Git在提供给我们这些顶层API去愉快使用的同时还提供了一些较为底层的API让我们能够更深入的了解它。接下来我们将通过部分底层的API来重现本次commit log的创建过程。主要用到的底层API如下： git update-index：对暂存区进行操作 git write-tree：根据当前暂存区（index）状态创建一个tree object 重现步骤如下： 1、先初始化版本库，再为内容分别为test的test.txt、Hello的hello.txt创建两个blob，blob不存储文件名 1234567$ mkdir test$ cd testgit init$ echo 'test' | git hash-object -w --stdin9daeafb9864cf43055ae93beb0afd6c7d144bfa4$ echo 'Hello' | git hash-object -w --stdine965047ad7c57865823c7d992b1d046ea66edf78 2、使用git update-index -add将blob（e965）加入暂存区，使用--cacheinfo参数指定文件模式、SHA-1值、文件名（hello.txt） 1$ git update-index --add --cacheinfo 100644 e965047ad7c57865823c7d992b1d046ea66edf78 hello.txt 3、使用git write-tree将当前暂存区状态写入一个tree object（8c3c） 12$ git write-tree8c3c7fbcd903744b20fd7567a1fcefa99133b5bc 4、将hello.txt移出暂存区，将blob（9dae）加入暂存区（即将test.txt加入暂存区） 12$ git update-index --remove hello.txt$ git update-index --add --cacheinfo 100644 9daeafb9864cf43055ae93beb0afd6c7d144bfa4 test.txt 5、使用git read-tree将已有tree object作为子树对象加入暂存区，通过--prefix设置名称为hi 1$ git read-tree --prefix=hi 8c3c7fbcd903744b20fd7567a1fcefa99133b5bc 6、记录下当前暂存区状态到tree object 12$ git write-tree2e8ebea76975c98806e73c0b7aea6c40c58d427c 7、使用git commit-tree根据tree object的SHA-1值创建commit object 12$ echo 'Hello Git' | git commit-tree 2e8e2616a5b40ead79df23736f61b346080423f438fe 8、查看commit log，没多大毛病，收工🎉 1234567891011121314$ git log --pretty=raw 2616commit 2616a5b40ead79df23736f61b346080423f438fetree 2e8ebea76975c98806e73c0b7aea6c40c58d427cauthor root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt; 1580660050 +0800committer root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt; 1580660050 +0800 Hello Git$ git cat-file -p 2616tree 2e8ebea76975c98806e73c0b7aea6c40c58d427cauthor root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt; 1580660050 +0800committer root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt; 1580660050 +0800Hello Git 相信到了这里，已经对Git在我们git add、git commit时做了什么有了一定的了解。如果想了解Git Object对应的SHA-1值如何生成和如何复现并串联多个commit object形成一个提交历史链，可查看《Pro Git》的第十章第二小节或参看后面的参考资料。 Git分支的本质是什么Git分支的本质是指向某一系列提交之首的指针或引用。Git使用引用的一个好处就是我们不需要花心思去记那些Git Object长长的SHA-1值。引用是存放SHA-1值的文件，它们位于.git/refs目录中。Git提供了一个API让我们更新引用-update-ref，示例如下 123456789101112131415$ git update-ref refs/heads/master 2616 # 2616为之前浮现commit log创建的commit object的SHA-1值$ git logcommit 2616a5b40ead79df23736f61b346080423f438fe (HEAD -&gt; master)Author: root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt;Date: Mon Feb 3 00:14:10 2020 +0800 Hello Git$ git log mastercommit 2616a5b40ead79df23736f61b346080423f438fe (HEAD -&gt; master)Author: root &lt;root@DESKTOP-CQ9JEC7.localdomain&gt;Date: Mon Feb 3 00:14:10 2020 +0800 Hello Git$ cat .git/refs/heads/master2616a5b40ead79df23736f61b346080423f438fe HEAD引用在介绍HEAD文件的时候我们说过它存放的是当前所在分支的引用，而且这个引用是个符号引用（symbolic reference）。那么什么是符号引用？它是一个指向其它引用的指针。我们可以查看之前clone下来的Explore-Git的HEAD文件 12$ cat .git/HEADref: refs/heads/master 当我们checkout到某个分支时，HEAD文件内容如下 123456$ git branch yeshan$ git checkout yeshanSwitched to branch 'yeshan'$ cat .git/HEADref: refs/heads/yeshan 至此，抛出的问题已解答完毕。 参考 Go Git：面向未来的代码平台，了解版本控制系统的发展和Git现存的问题，版本控制系统未来的走向 《Git权威指南》 - Git对象探秘 这才是真正的Git——Git内部原理揭秘！ 《Pro Git》- Basic Snapshotting Git对象模型 你知道 Git 是如何做版本控制的吗 图解Git GitHub Developer REST API Git Blobs 如何读取git-ls-tree输出的模式字段 常用Git命令清单","categories":[{"name":"Git","slug":"Git","permalink":"https://yeshan333.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yeshan333.github.io/tags/Git/"}]},{"title":"React+Flask打造前后端分离项目开发环境","slug":"React-Flask打造前后端分离项目开发环境","date":"2020-01-13T04:56:16.000Z","updated":"2020-01-27T08:16:44.944Z","comments":true,"path":"2020/01/13/React-Flask打造前后端分离项目开发环境/","link":"","permalink":"https://yeshan333.github.io/2020/01/13/React-Flask打造前后端分离项目开发环境/","excerpt":"前言 新的一年，开始水第一篇技术文。碰巧最近React玩得多，撸一篇文章纪念一下开发环境的搭建。🤔 开篇两问： 什么是React？：React，用于构建用户界面的 JavaScript 库（官网复制粘贴，真香，不用怎么写template了，舒服 什么是Flask？：一个使用Python编写的轻量级Web应用框架。用来写云原生应用很香！ 先看下最终的项目结构，如下：《项目源码》 12345678910111213141516171819├── app.py├── env| ├── Include| ├── Lib| ├── LICENSE.txt| ├── Scripts| └── tcl├── frontend| ├── build| ├── node_modules| ├── package-lock.json| ├── package.json| ├── public| ├── README.md| └── src├── static| └── js└── templates └── index.html","text":"前言 新的一年，开始水第一篇技术文。碰巧最近React玩得多，撸一篇文章纪念一下开发环境的搭建。🤔 开篇两问： 什么是React？：React，用于构建用户界面的 JavaScript 库（官网复制粘贴，真香，不用怎么写template了，舒服 什么是Flask？：一个使用Python编写的轻量级Web应用框架。用来写云原生应用很香！ 先看下最终的项目结构，如下：《项目源码》 12345678910111213141516171819├── app.py├── env| ├── Include| ├── Lib| ├── LICENSE.txt| ├── Scripts| └── tcl├── frontend| ├── build| ├── node_modules| ├── package-lock.json| ├── package.json| ├── public| ├── README.md| └── src├── static| └── js└── templates └── index.html 开发环境：Windows+Flask+React+Git Bash+vscode Backend-Flask 个人比较喜欢用CLI，So，项目开发依赖使用virtualenv+pip管理，pipenv也还行，虽然lock package有点久。听说比较新的poetry很香？ 1234567891011# 1、安装virtualenvpip install virtualenv# 2、为项目（Flask_React）创建虚拟环境-&gt;envvirtualenv env# 3、激活虚拟环境envsource env/Scripts/activate# 4、安装项目依赖pip install -r requirments.txt# 5、创建好templates和static目录，用于存放React打包好的渲染模板和静态文件mkdir templatesmkdir static 后端服务的基础环境搭建好了，随手写个路由，看下能不能用先 1234567891011# app.pyfrom flask import Flaskapp = Flask(__name__)@app.route('/')def index(): return \"&lt;h1&gt;Hello React+Flask!&lt;/h1&gt;\"if __name__ == '__main__': app.run('127.0.0.1', port=5000, debug=True) Frontend-React 前端React应用的开发环境使用官方提供的脚手架create-react-app搭建。 1234# 1、安装脚手架npm install -g create-react-app# 2、为Flask_React项目创建React App-&gt;frontendcreate-react-app frontend # 这里有点小久，喝杯咖啡☕摸下鱼 OK，前端开发环境搭建好了，清理掉src目录下的所有文件，自己写个组件，如下： 123cd frontend/srcrm -rf *touch index.js 1234567891011121314151617181920//index.jsimport React from 'react'import ReactDOM from 'react-dom'class App extends React.Component &#123; render() &#123; return ( &lt;div className=\"container\"&gt; &lt;h1 className=\"center-align\"&gt; 盒装一流弊&lt;br/&gt; &lt;span className=\"waves-effect waves-light btn\"&gt; &lt;i className=\"material-icons right\"&gt;cloud&lt;/i&gt;您说的都对 &lt;/span&gt; &lt;/h1&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById('root')) OK，预览下效果，顺便调试（没啥可调试的/(ㄒoㄒ)/~~）。npm start。效果如下： 没多大问题的话，是时候打包写好的React App给后端服务了。 Done很舒服的是create-react-app封装好了 Babel 和 webpack，我们可以直接使用npm run build打包写好的App到frontend/build目录中。然后手动将生成的文件分别挪到Flask的templates和static目录中即可。等等？手动，能不能使用CLI，dang然阔以。 npm 允许我们在package.json文件里面，使用scripts字段自定义脚本命令。更舒服的是npm script提供了pre和post钩子。我们可以给build脚本命令提供两个钩子prebuild和postbuild。编辑后的package.json文件的Script命令如下如下： 12345678\"scripts\": &#123; \"start\": \"react-scripts start\", \"prebuild\": \"rm -rf ..\\\\templates\\\\index.html &amp;&amp; rm -rf ..\\\\static\", \"build\": \"react-scripts build\", \"postbuild\": \"mv build\\\\index.html ..\\\\templates\\\\ &amp;&amp; mv build\\\\static ..\\\\static\", \"test\": \"react-scripts test\", \"eject\": \"react-scripts eject\"&#125;, 这时候，我们执行npm run build命令时，会自动按照下面的顺序执行 123rm -rf ..\\\\templates\\\\index.html &amp;&amp; rm -rf ..\\\\staticreact-scripts buildmv build\\\\index.html ..\\\\templates\\\\ &amp;&amp; mv build\\\\static ..\\\\static OK，我们试试。如下： Nice，没毛病。🎉🎉🎉。改下app.py: 12345678910from flask import Flask, render_templateapp = Flask(__name__)@app.route('/')def index(): return render_template('index.html') # 渲染打包好的React App的页面if __name__ == '__main__': app.run('127.0.0.1', port=5000, debug=True) 冇问题啊！收工！！！ References React Docs Create React App npm-scripts npm scripts 使用指南","categories":[{"name":"React","slug":"React","permalink":"https://yeshan333.github.io/categories/React/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://yeshan333.github.io/tags/Flask/"},{"name":"React","slug":"React","permalink":"https://yeshan333.github.io/tags/React/"}]},{"title":"2019年总结","slug":"2019年总结","date":"2019-12-31T03:15:07.000Z","updated":"2020-01-01T14:32:06.143Z","comments":true,"path":"2019/12/31/2019年总结/","link":"","permalink":"https://yeshan333.github.io/2019/12/31/2019年总结/","excerpt":"","text":"前言扯🥚终于考完试了（昨天下午终结了最后一科-“万恶”的复变函数🎈🎉），可以摩擦下年终总结了，花点时间想下2019年我干了什么🎁。完了写不下去了（此时中午12点59分30秒。 忆往昔-xxx~2019这一年过得无比的充实，个人感觉高中的时候都没对自己这么狠过，我怕是上了个假的大学（忽然想起高三临近高考那段时间，别人在复习，而我却趴在桌面上在睡觉&lt;被“农药”毒害，趴了整个高三，挺对不起老师的，惭愧😥）。 以下开始略微总结下今年的操作、收获与遗憾。 阅读方面这一年看了很多的书，有技术方面的也有非技术方面的都有，我佛了，大三上一整个学期就没打过游戏，我都佩服我自己，ε=ε=ε=┏(゜ロ゜;)┛，略微罗列下： 没看完的，看了大部分，但是没再继续看 《Python密码学编程》 《Python从入门到实践》 《C++ Primer Plus》 《Python基础教程（第3版）》 《算法图解》 《啊哈！算法》 《HTTP权威指南》 《Flask Web开发：基于Python的Web应用开发实战》 《Flask 入门教程》 《Docker Deep Dive》 《Linux 就该这么学》 《How To Think Like A Computer Scientist》 可以说是看完了的 《Web全栈工程师的自我修养》 《Don’t Make Me Think》 《Growth: 全栈增长工程师指南》 《我的职业是前端工程师》 《RePractise》 …… 上图，emmm…我正在看的，希望开学前能看完大部分，又能“吹水”了，都是💪力量啊！ 小声bb，我入手了套《周易》，看了那么多还是菜（太卑微了，总有那么种好高骛远的感觉！！！斑驳 技术实践与交流这一年，我喜欢上了开源社区，我的第一个issue。很幸运能够偷偷的在图灵读者群QQ当个混子，知道了Manjusaka（璈叔~，一直在听大佬出《捕蛇者说》播客，收获满满），通过大佬又知道了PyCon China。今年Python30周年，PyCon China 2019大佬云集，太香了，路费太贵没能去成，没能线下见诸位大佬（太苦bi了~/(ㄒoㄒ)/~~，还好有PPT和视频放出来，现在仍在反复的看一些感兴趣的Topic的Slide和视频，又get✅到了学习的新姿势。 这一年我做的都是一些小玩意，太卑微了，不敢列出来。不得不说GitHub真香，一些开源项目拿来即可用，可以快速集成到自己弄得东西上（此处吐槽😒文档写的不好或者连文档都没有的，看的太难受了）。虽然整的都是一些花里胡哨的小东西，至少我看到了自己在成长，不亏，此处上我的GitHub小绿点： 再看下大佬的，我透，我就是didi，我整的还贼水。 GitHub还有一点特别香，通过follow各领域的大佬，我能了解到一些“骚”技术（emmm。。。，有些东西我还用上了，不愧是终极程序员社交网站。此处艾特一位友链小伙伴TRHX🔗，嘿嘿嘿，你star的大部分项目我都拿来耍过几下。 emmm，很幸运的认识了友链里诸位大佬，无聊的时候经常去lu你们的文章，收获还是蛮多的。 缺憾与期待这一年有点难 自学太痛苦了（线下找不到倾诉的伙伴，院里找不到“真正”有共同兴趣、爱好、热情的伙伴，大部分人只是说说而已，行动上的弱者），真希望有个dalao带带我（枯了 我吐，一年多没跳舞了，我居然抛弃了我曾经热爱的Breaking，虽然仍在看一些街舞文化相关的节目和比赛-&gt;《这！就是街舞》、《Red Bull BC One》，但我已经不再是个纯粹的B-Boy了 感觉自己没能真正的融入开源社区，并未参与多人优质开源项目的开发 撸了一下董老师的《爱澎湃2019年度Python榜单》，发现我知道的东西还是太少，看来我对Python的热爱没有那么纯粹，信息的来源不太行 看了下我的GitHub年度报告，看来得好好养生了 期待 新的一年，我又立下了一丢丢flag🚩，不知道下学期结束前能不能操作完(☆▽☆) 稳住，别浪，Hello World -&gt; Cloud Native, Meta Year 期待下一年能撸一个优秀的技术开源项目或者去为优秀的开源项目贡献代码 期待自己所待的科协在未来有真正强有力的积累，能发挥出“马太效应” 我似乎还没真正想明白我想要什么，不给力啊！ 新一年对自己的要求：不只是要做思想上的强者，更要做行动上的强者；多思考、多折腾、多更新。很喜欢的一句话：I hear and I forget. I see and I remember. I do and I understand.","categories":[{"name":"随笔","slug":"随笔","permalink":"https://yeshan333.github.io/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://yeshan333.github.io/tags/随笔/"}]},{"title":"愿和平永驻人间","slug":"愿和平永驻人间","date":"2019-12-13T04:25:33.000Z","updated":"2019-12-13T04:52:16.051Z","comments":true,"path":"2019/12/13/愿和平永驻人间/","link":"","permalink":"https://yeshan333.github.io/2019/12/13/愿和平永驻人间/","excerpt":"","text":"","categories":[{"name":"memory","slug":"memory","permalink":"https://yeshan333.github.io/categories/memory/"}],"tags":[{"name":"memory","slug":"memory","permalink":"https://yeshan333.github.io/tags/memory/"}]},{"title":"❤Thanksgiving❤","slug":"heart","date":"2019-11-28T15:50:56.000Z","updated":"2020-01-30T14:00:59.449Z","comments":true,"path":"2019/11/28/heart/","link":"","permalink":"https://yeshan333.github.io/2019/11/28/heart/","excerpt":"","text":"","categories":[{"name":"随笔","slug":"随笔","permalink":"https://yeshan333.github.io/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://yeshan333.github.io/tags/随笔/"}]},{"title":"Serialization and Deserialization","slug":"Serialization-and-Deserialization","date":"2019-11-25T08:25:23.000Z","updated":"2019-11-25T12:27:11.335Z","comments":true,"path":"2019/11/25/Serialization-and-Deserialization/","link":"","permalink":"https://yeshan333.github.io/2019/11/25/Serialization-and-Deserialization/","excerpt":"序列化与反序列化 Serialization：Data Structure/Object —&gt; Binary StringDeserialization：Binary String —&gt; Data Structure/ObjectGoals：Cross-platform Communication、Persistent Storage and More Python中对象的序列化与反序列化pickle module pickle 仅可用于 Python，pickle所使用的数据流格式仅可用于 Pythonpickle 模块可以将复杂对象转换为字节流，也可以将字节流转换为具有相同内部结构的对象。可被pickling和unpickling的对象：https://docs.python.org/zh-cn/3/library/pickle.html#what-can-be-pickled-and-unpickled pickle提供了优秀的方法方便我们对对象进行pickling（封存）和unpickling（解封）","text":"序列化与反序列化 Serialization：Data Structure/Object —&gt; Binary StringDeserialization：Binary String —&gt; Data Structure/ObjectGoals：Cross-platform Communication、Persistent Storage and More Python中对象的序列化与反序列化pickle module pickle 仅可用于 Python，pickle所使用的数据流格式仅可用于 Pythonpickle 模块可以将复杂对象转换为字节流，也可以将字节流转换为具有相同内部结构的对象。可被pickling和unpickling的对象：https://docs.python.org/zh-cn/3/library/pickle.html#what-can-be-pickled-and-unpickled pickle提供了优秀的方法方便我们对对象进行pickling（封存）和unpickling（解封） 使用dumps和loads方法进行序列化和反序列化123456789101112131415&gt;&gt;&gt; import pickle&gt;&gt;&gt; person = dict(name='shan', age=20, sex=\"man\")&gt;&gt;&gt; pickle.dumps(person) # dumps方法会将obj序列化为bytes返回b'\\x80\\x03&#125;q\\x00(X\\x04\\x00\\x00\\x00nameq\\x01X\\x04\\x00\\x00\\x00shanq\\x02X\\x03\\x00\\x00\\x00ageq\\x03K\\x14X\\x03\\x00\\x00\\x00sexq\\x04X\\x03\\x00\\x00\\x00manq\\x05u.&gt;&gt;&gt;&gt;&gt;&gt; with open(\"dump.txt\",\"wb\") as f:... pickle.dump(person, f)...&gt;&gt;&gt; f = open(\"dump.txt\",\"rb\")&gt;&gt;&gt; d = pickle.load(f)&gt;&gt;&gt; f.close()&gt;&gt;&gt; d&#123;'name': 'shan', 'age': 20, 'sex': 'man'&#125;&gt;&gt;&gt; pickle.loads(pickle.dumps(d))&#123;'name': 'shan', 'age': 20, 'sex': 'man'&#125; https://docs.python.org/zh-cn/3/library/pickle.html#pickle.dump bytes对象是由单个字节组成的不可变序列 使用dump方法可将序列化的对象写入file obj load用于还原封存生成的bytes_object，loads方法用于还原从文件中读取的封存对象 json module 相比于pickle，json只能表示内置类型的子集，不能表示自定义的类json格式的文件的易读性更好Python json模块提供的API与pickle模块很相似 使用dumps和loads进行序列化和反序列化12345678&gt;&gt;&gt; import json&gt;&gt;&gt; person = dict(name='shan', age=20, sex=\"man\")&gt;&gt;&gt; json.dumps(person)'&#123;\"name\": \"shan\", \"age\": 20, \"sex\": \"man\"&#125;'&gt;&gt;&gt;&gt;&gt;&gt; json_str = json.dumps(person)&gt;&gt;&gt; json.loads(json_str)&#123;'name': 'shan', 'age': 20, 'sex': 'man'&#125; dumps方法会将obj转换为标准格式的JSON str并返回 loads方法可将包含JSON文档的str、bytes或者bytearray反序列化为Python对象 自定义对象的序列化与反序列化 对于自定义对象的序列化和反序列化操作需要我们实现专门的encoder和decoder需要用到dumps方法的default参数和loads方法的object_hook参数https://docs.python.org/3/library/json.html#json.loadshttps://docs.python.org/3/library/json.html#json.loads 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; import json&gt;&gt;&gt;&gt;&gt;&gt; class Student(object):... def __init__(self, name, age, score):... self.name = name... self.age = age... self.score = score...&gt;&gt;&gt; def student2dict(std):... return &#123;... 'name': std.name,... 'age': std.age,... 'score': std.score... &#125;...&gt;&gt;&gt; def dict2student(d):... return Student(d['name'], d['age'], d['score'])...&gt;&gt;&gt; s = Student('Bob', 20, 88)&gt;&gt;&gt; print(json.dumps(s, default=student2dict))&#123;\"name\": \"Bob\", \"age\": 20, \"score\": 88&#125;&gt;&gt;&gt; json_str = json.dumps(s, default=student2dict)&gt;&gt;&gt; print(json.loads(json_str, object_hook=dict2student))&lt;__main__.Student object at 0x000001B101675198&gt;&gt;&gt;&gt; json.loads(json_str, object_hook=dict2student)&lt;__main__.Student object at 0x000001B101675128&gt;&gt;&gt;&gt; old = json.loads(json_str, object_hook=dict2student)&gt;&gt;&gt; old.name'Bob' third-party module：marshmallow marshmallow is an ORM/ODM/framework-agnostic library for converting complex datatypes, such as objects, to and from native Python datatypes. 1234567891011121314151617181920212223&gt;&gt;&gt; import datetime as dt&gt;&gt;&gt; import marshmallow&gt;&gt;&gt; from dataclasses import dataclass&gt;&gt;&gt;&gt;&gt;&gt; from marshmallow import Schema, fields&gt;&gt;&gt;&gt;&gt;&gt; @dataclass... class Album:... title: str... release_date: dt.date...&gt;&gt;&gt; class AlbumSchema(Schema):... title = fields.Str()... release_date = fields.Date()...&gt;&gt;&gt; album = Album(\"Seven Innovation Base\", dt.date(2019, 11, 23))&gt;&gt;&gt; schema = AlbumSchema()&gt;&gt;&gt; data = schema.dump(album) # obj -&gt; dict&gt;&gt;&gt; data&#123;'title': 'Seven Innovation Base', 'release_date': '2019-11-23'&#125;&gt;&gt;&gt; data_str = schema.dumps(album) # obj -&gt; str&gt;&gt;&gt; data_str'&#123;\"title\": \"Seven Innovation Base\", \"release_date\": \"2019-11-23\"&#125;' 使用 marshmallow 可以很方便的对自定义对象进行序列化和反序列化 对object进行在序列化之前，需要为object创建一个schema,schema中的字段名必须与自定义的object中的成员一致 dumps method：obj -&gt; str, dump method：obj -&gt; dict 反序列化的 dict -&gt; obj 需要使用decorator：post_load自己实现 12345678910111213141516171819202122232425from marshmallow import Schema, fields, post_loadclass User: def __init__(self, name, email): self.name = name self.email = email def __repr__(self): return \"&lt;User(name=&#123;self.name!r&#125;)&gt;\".format(self=self)class UserSchema(Schema): name = fields.Str() email = fields.Email() @post_load def make_user(self, data, **kwargs): return User(**data)user_data = &#123; \"email\": \"ken@yahoo.com\", \"name\": \"Ken\",&#125;schema = UserSchema()result = schema.load(user_data)print(result) # 输出结果：&lt;User(name='Ken')&gt; References 序列化与反序列化 pickle module json module bytes RESTful API编写指南 Flask RESTful API开发之序列化与反序列化 marshmallow","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/tags/Python/"},{"name":"Json","slug":"Json","permalink":"https://yeshan333.github.io/tags/Json/"}]},{"title":"map-filter-reduce","slug":"map-filter-reduce","date":"2019-11-14T13:49:41.000Z","updated":"2019-11-14T15:39:42.940Z","comments":true,"path":"2019/11/14/map-filter-reduce/","link":"","permalink":"https://yeshan333.github.io/2019/11/14/map-filter-reduce/","excerpt":"听说函数式编程很⑥，咱也不知道，咱也不晓得，还没实际用过。emmm。。。。，先mark下Python中和函数式编程有关的部分功能先，又开始水了，立个flag🚩：慢慢完善 map先看下Python官方文档的说法 map(function, iterable, …)，返回一个将 function 应用于 iterable 中每一项并输出其结果的迭代器。 如果传入了额外的 iterable 参数，function 必须接受相同个数的实参并被应用于从所有可迭代对象中并行获取的项。 见识一下 123456789101112&gt;&gt;&gt; def cook(something):... if something == \"cow\":... return \"hamburger\"... elif something == \"tomato\":... return \"chips\"... elif something == \"chicken\":... return \"ddrumstick\"... elif something == \"corn\":... return \"popcorn\"...&gt;&gt;&gt; list(map(cook, [\"cow\", \"tomato\", \"chicken\", \"corn\"]))['hamburger', 'chips', 'ddrumstick', 'popcorn']","text":"听说函数式编程很⑥，咱也不知道，咱也不晓得，还没实际用过。emmm。。。。，先mark下Python中和函数式编程有关的部分功能先，又开始水了，立个flag🚩：慢慢完善 map先看下Python官方文档的说法 map(function, iterable, …)，返回一个将 function 应用于 iterable 中每一项并输出其结果的迭代器。 如果传入了额外的 iterable 参数，function 必须接受相同个数的实参并被应用于从所有可迭代对象中并行获取的项。 见识一下 123456789101112&gt;&gt;&gt; def cook(something):... if something == \"cow\":... return \"hamburger\"... elif something == \"tomato\":... return \"chips\"... elif something == \"chicken\":... return \"ddrumstick\"... elif something == \"corn\":... return \"popcorn\"...&gt;&gt;&gt; list(map(cook, [\"cow\", \"tomato\", \"chicken\", \"corn\"]))['hamburger', 'chips', 'ddrumstick', 'popcorn'] filter也看下官方文档的说法 filter(function, iterable),用 iterable 中函数 function 返回真的那些元素，构建一个新的迭代器。iterable 可以是一个序列，一个支持迭代的容器，或一个迭代器。如果 function 是 None ，则会假设它是一个身份函数，即 iterable 中所有返回假的元素会被移除。 也见识下 123456789&gt;&gt;&gt; def isVegetarian(food):... check = ['chips', 'popcorn']... if food in check:... return True... else:... return False...&gt;&gt;&gt; list(filter(isVegetarian, ['hamburger', 'chips', 'ddrumstick', 'popcorn']))['chips', 'popcorn'] reduce再看下官方文档 Apply function of two arguments cumulatively to the items of iterable, from left to right, so as to &gt;reduce the iterable to a single value. 见识下 123&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])15 一图胜千言 曾看到过一张把filter、map、reduce描述得很透彻得图，真滴六🐂 references Demonstrating map, filter, and reduce in Swift using food emoji 函数式编程指引 functools.reduce map","categories":[{"name":"函数式编程","slug":"函数式编程","permalink":"https://yeshan333.github.io/categories/函数式编程/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/tags/Python/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://yeshan333.github.io/tags/函数式编程/"}]},{"title":"git clone后如何checkout到remote branch","slug":"clone后如何checkout到remote-branch","date":"2019-10-26T16:36:10.000Z","updated":"2019-10-26T17:53:09.276Z","comments":true,"path":"2019/10/27/clone后如何checkout到remote-branch/","link":"","permalink":"https://yeshan333.github.io/2019/10/27/clone后如何checkout到remote-branch/","excerpt":"","text":"what/why通常情况使用git clone github_repository_address下载下来的仓库使用git branch查看当前所有分支时只能看到master分支，但是想要切换到其他分支进行工作怎么办❓ 其实使用git clone下载的repository没那么简单😥，clone得到的是仓库所有的数据，不仅仅是复制在Github repository所能看到的master分支下的所有文件，clone下来的是仓库下的每一个文件和每一个文件的版本（也就是说所有的分支都被搞下来了咯），那为啥看不到，其实remote branch被隐藏了，需要使用git branch -a才能看到。 howemmm…，现在看到了，那么怎么切换到remote branch呢？（我太难了🙃），又到了查文档的时候了，一波操作过后了解到git checkout是有restore working tree files的功能的，可以用来restore remote branch，比如使用以下命令在本地创建个新分支track远程分支： 1$ git checkout -b &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt; 12# 例子，本地为远程分支CkaiGrac-PYMO创建的新分支名为yeshan，push时需要注意git checkout -b yeshan --track origin/CkaiGrac-PYMO tips：使用git checkout -t &lt;remote/branch&gt;默认会在本地建立一个和远程分支名字一样的分支 reference git-branch: https://git-scm.com/docs/git-branch git-checkout: https://git-scm.com/docs/git-checkout","categories":[{"name":"Git","slug":"Git","permalink":"https://yeshan333.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yeshan333.github.io/tags/Git/"}]},{"title":"使用Microsoft Edge Beta将网页变成应用","slug":"使用Microsoft-Edge-Beta将网页变成应用","date":"2019-10-11T15:50:56.000Z","updated":"2020-01-30T13:59:29.329Z","comments":true,"path":"2019/10/11/使用Microsoft-Edge-Beta将网页变成应用/","link":"","permalink":"https://yeshan333.github.io/2019/10/11/使用Microsoft-Edge-Beta将网页变成应用/","excerpt":"","text":"今天无聊的我打开了装了很久都没用的Microsoft Edge Beta，一波乱戳，惊讶的发现Microsoft Edge Beta居然有将网页打包为应用的功能😂 B站也有PC”客户端”了，真香😂","categories":[{"name":"随笔","slug":"随笔","permalink":"https://yeshan333.github.io/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://yeshan333.github.io/tags/随笔/"}]},{"title":"简单感受下Python内置数据类型常用操作的性能","slug":"简单了解下Python内置数据类型常用操作的性能","date":"2019-10-02T11:01:46.000Z","updated":"2019-10-02T14:08:18.956Z","comments":true,"path":"2019/10/02/简单了解下Python内置数据类型常用操作的性能/","link":"","permalink":"https://yeshan333.github.io/2019/10/02/简单了解下Python内置数据类型常用操作的性能/","excerpt":"生成一个列表的几种方式的性能对比12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# -*- coding: utf-8 -*-from timeit import Timerimport matplotlib.pyplot as plt# 列表常用操作性能测试# 迭代 + '+'def test1(): l = [] for i in range(1000): l = l + [i] # 迭代 + appenddef test2(): l = [] for i in range(1000): l.append(i)# 列表生成式def test3(): l = [i for i in range(1000)]# list构造函数 + rangedef test4(): l = list(range(1000))t1 = Timer(\"test1()\", \"from __main__ import test1\")# print(\"concat %f seconds\" % t1.timeit(number=1000))t2 = Timer(\"test2()\", \"from __main__ import test2\")# print(\"concat %f seconds\" % t2.timeit(number=1000))t3 = Timer(\"test3()\", \"from __main__ import test3\")# print(\"concat %f seconds\" % t3.timeit(number=1000))t4 = Timer(\"test4()\", \"from __main__ import test4\")# print(\"concat %f seconds\" % t4.timeit(number=1000))result = [t1.timeit(1000), t2.timeit(1000), t3.timeit(1000), t4.timeit(1000)]method = [\"for+ '+'\", \"for + append\", \"list comprehension\", \"list + range\"]plt.bar(method, result, color='rgby')# plt.legend('concat time')# print(zip(method, result))for x,y in zip(method, result): plt.text(x, y, \"%fs\" % y)plt.show()","text":"生成一个列表的几种方式的性能对比12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# -*- coding: utf-8 -*-from timeit import Timerimport matplotlib.pyplot as plt# 列表常用操作性能测试# 迭代 + '+'def test1(): l = [] for i in range(1000): l = l + [i] # 迭代 + appenddef test2(): l = [] for i in range(1000): l.append(i)# 列表生成式def test3(): l = [i for i in range(1000)]# list构造函数 + rangedef test4(): l = list(range(1000))t1 = Timer(\"test1()\", \"from __main__ import test1\")# print(\"concat %f seconds\" % t1.timeit(number=1000))t2 = Timer(\"test2()\", \"from __main__ import test2\")# print(\"concat %f seconds\" % t2.timeit(number=1000))t3 = Timer(\"test3()\", \"from __main__ import test3\")# print(\"concat %f seconds\" % t3.timeit(number=1000))t4 = Timer(\"test4()\", \"from __main__ import test4\")# print(\"concat %f seconds\" % t4.timeit(number=1000))result = [t1.timeit(1000), t2.timeit(1000), t3.timeit(1000), t4.timeit(1000)]method = [\"for+ '+'\", \"for + append\", \"list comprehension\", \"list + range\"]plt.bar(method, result, color='rgby')# plt.legend('concat time')# print(zip(method, result))for x,y in zip(method, result): plt.text(x, y, \"%fs\" % y)plt.show() list和dict的检索效率对比123456789101112131415161718192021222324252627282930# -*- coding: utf-8 -*-import randomfrom timeit import Timerimport matplotlib.pyplot as pltlst_result = []d_result = []for i in range(10000,1000001,20000): t = Timer(\"random.randrange(%d) in x\" % i, \"from __main__ import random,x\") x = list(range(i)) lst_time = t.timeit(number=1000) x = &#123;j:None for j in range(i)&#125; d_time = t.timeit(number=1000) lst_result.append(lst_time) d_result.append(d_time) print(\"%d,%10.3f,%10.3f\" % (i, lst_time, d_time))test = [i for i in range(10000,1000001,20000)]plt.plot(test, lst_result, 'ro')plt.plot(test, d_result, 'bo')plt.legend(['List','Dictionary'])plt.show() del list[index]与del dict[key] 性能对比 average time complexity：$ O(n)\\ \\ vs\\ \\ O(1) $ 1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-import randomfrom timeit import Timerimport matplotlib.pyplot as pltsize = 20000l_result = []d_result = []for i in range(size): test_list = [i for i in range(size)] list_t = Timer(\"del test_list[%d]\" % i,\"from __main__ import test_list\") list_result = list_t.timeit(number=1) l_result.append(list_result) test_dict = &#123;j:None for j in range(size)&#125; dict_t = Timer(\"del test_dict[%d]\" % i,\"from __main__ import test_dict\") dict_result = dict_t.timeit(number=1) d_result.append(dict_result) # print(\"%d,%f,%f\" % (i, list_result, dict_result))plt.plot(range(size), l_result)plt.plot(range(size), d_result)plt.legend(['del list[index]', 'del dict[key]'])plt.show() 参考 matplotlib中文文档 TimeComplexity 北大数据结构与算法公开课 Python timeit","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/tags/Python/"}]},{"title":"Python环境管理与项目依赖管理","slug":"Python环境管理","date":"2019-09-02T05:07:13.000Z","updated":"2019-12-25T08:00:59.975Z","comments":true,"path":"2019/09/02/Python环境管理/","link":"","permalink":"https://yeshan333.github.io/2019/09/02/Python环境管理/","excerpt":"个人简单记录下 virtualenv + pip virtualenv是一个用于创建”隔离的ython运行环境”的工具，Docspip是Python的包管理工具，Docs 1234567891011121314# 安装virtualenvpip install virtualenv# -------------------------------- ## 虚拟环境的创建与使用# 1、在当前工程目录下使用virtualenv创建一套独立的Python运行环境virtualenv venv # 环境名为venv（自由定义）# 2、cd 到创建好的虚拟环境的Scripts目录，执行如下命令可激活或者退出虚拟环境activate # 激活，激活后命令提示符会变成当前工程目录Python环境名deactivate # 退出# 3、激活虚拟环境后可使用pip为当前项目安装依赖，example：pip install numpy# 4、使用pip freeze &gt; requirements.txt 可导出项目依赖到requirements.txt中# 为项目创建一个新的、干净的环境时，可使用 pip install -r requiremen.txt 为项目安装依赖","text":"个人简单记录下 virtualenv + pip virtualenv是一个用于创建”隔离的ython运行环境”的工具，Docspip是Python的包管理工具，Docs 1234567891011121314# 安装virtualenvpip install virtualenv# -------------------------------- ## 虚拟环境的创建与使用# 1、在当前工程目录下使用virtualenv创建一套独立的Python运行环境virtualenv venv # 环境名为venv（自由定义）# 2、cd 到创建好的虚拟环境的Scripts目录，执行如下命令可激活或者退出虚拟环境activate # 激活，激活后命令提示符会变成当前工程目录Python环境名deactivate # 退出# 3、激活虚拟环境后可使用pip为当前项目安装依赖，example：pip install numpy# 4、使用pip freeze &gt; requirements.txt 可导出项目依赖到requirements.txt中# 为项目创建一个新的、干净的环境时，可使用 pip install -r requiremen.txt 为项目安装依赖 Pipenv Pipenv集包管理和虚拟环境管理于一身，使用Pipfile和Pipfile.lock管理项目依赖（Pipfile中保存着各个依赖包的版本信息，Pipfile.lock保存着依赖包的锁信息）。Docs Pipenv playground Pipfile and Pipfile.lock 123456789101112# 安装pip install pipenv# ------------------ ## Pipenv的使用# 1、为当前工程创建虚拟环境pipenv install # 这里会生成Pipfile和Pipfile.lock文件# 2、虚拟环境的激活pipenv shell # 激活虚拟环境# 3、安装依赖pipenv install [package_name]# 4、在虚拟环境中运行Python脚本pipenv run xxx.py Poetry Poetry是新一代的用来处理依赖项的安装、构建和打包成Python包的工具（2018年2月28日发布0.1.0版本），Poetry使用pyproject.toml管理项目依赖。Docs 12345678910111213# Poetry的安装pip install poetry# ---------------------- ## poetry的使用# 1、快速创建一个Python项目poetry new [project_name]# 2、以交互式的方式为当前项目创建pyproject.toml文件poetry init# 3、为当前项目添加依赖poetry add [package_name]# 4、构建源码并对当前项目进行wheels archive（打包成Python包）poetry build 拓展关于Wheel打包格式《PEP427》","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/tags/Python/"},{"name":"环境管理","slug":"环境管理","permalink":"https://yeshan333.github.io/tags/环境管理/"}]},{"title":"docker学习笔记","slug":"docker学习笔记","date":"2019-08-08T09:29:19.000Z","updated":"2019-08-09T03:38:58.353Z","comments":true,"path":"2019/08/08/docker学习笔记/","link":"","permalink":"https://yeshan333.github.io/2019/08/08/docker学习笔记/","excerpt":"Play With Docker一个免费使用的基于web界面的Docker环境 常用docker命令可使用docker COMMAND --help查看命令的用法 Docker镜像相关 1、docker image pull：用于下载镜像，镜像从远程镜像仓库服务的仓库中下载，默认从Docker Hub的仓库中拉取 1234# 格式：docker pull [OPTIONS] NAME[:TAG|@DIGEST]# 说明：如果给出tag，一般拉取latest，name一般为username/repository,digest为镜像摘要可不给出docker image pull ubuntu:latest# 这个拉取标签为latest的ubuntu官方镜像，latest: Pulling from library/ubuntu，latest不一定是最新镜像","text":"Play With Docker一个免费使用的基于web界面的Docker环境 常用docker命令可使用docker COMMAND --help查看命令的用法 Docker镜像相关 1、docker image pull：用于下载镜像，镜像从远程镜像仓库服务的仓库中下载，默认从Docker Hub的仓库中拉取 1234# 格式：docker pull [OPTIONS] NAME[:TAG|@DIGEST]# 说明：如果给出tag，一般拉取latest，name一般为username/repository,digest为镜像摘要可不给出docker image pull ubuntu:latest# 这个拉取标签为latest的ubuntu官方镜像，latest: Pulling from library/ubuntu，latest不一定是最新镜像 2、docker image ls：列出本地Docker主机上存储的镜像 3、docker image inspect：查看镜像的细节，包括镜像层数据和元数据 12# docker image inspect [OPTIONS] IMAGE [IMAGE...]# inspect后一般跟repository name或image id 4、docker image rm：用于删除镜像。如果镜像存在关联的容器，并且容器处于运行(Up)或停止(Exit)状态时，不允许删除该镜像。rm后可跟repository或image id 5、dicker image search：从Docker Hub查找镜像 6、docker image build：根据Dockerfile构建镜像 12# 例如：使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。docker build -t yeshan333/ubuntu:latest . 7、docker image history：用于查看镜像构建的相关信息 Docker容器相关 1、docker container run：用于启动新容器 123456789101112# 格式：docker run [OPTIONS] IMAGE [COMMAND] [ARG...]# 常用options：# -d: 后台运行容器，并返回容器ID；# -i: 以交互模式运行容器，通常与 -t 同时使用；# -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；# -P: 随机端口映射，容器内部端口随机映射到主机的高端口# -p: 指定端口映射，格式为：主机(宿主)端口:容器端口# --name=\"container-name\": 为容器指定一个名称；# 示例docker container run -it ubuntu:latest /bin/bash# 说明：-it使容器具备交互性并与终端连接，命令最后表明运行容器中的Bash Shell程序 2、docker container ls：列出所有运行状态的容器可用docker ps代替，如果加个*-a附加参数，会列出所有容器（包括处于停止状态的容器） 3、docker container stop：停止运行中的容器，并将其状态设置为Exited(0)，stop后跟container name或container id 4、docker container rm：用于删除停止运行的容器，rm后跟container name或container id，使用-f参数可强制删除运行中的容器 5、docker container exec：用于连接一个处于运行状态的容器 123# 例如：docker container exec -t &lt;container-name or container-id&gt; bash# 该命令会将docker主机中的shell连接到一个运行中的容器，在容器内部启动一个新的bash shell进程 6、docker container start：用于重启处于停止(Exited)状态的容器，start后跟container name或container id 7、docker container inspect：查看容器的配置信息和运行时信息，inspect后跟container name或container id 8、快捷键Ctrl+PQ用于断开docker主机的shell终端与容器终端的连接，并在退出后保证容器在后台运行 应用容器化 (Containerizing|Dockerizing)即将应用整合到容器中并且运行的过程 应用容器化的一般步骤 1、编写应用代码 2、创建Dockerfile，其中包括当前应用的描述、依赖以及如何运行这个应用 3、对Dockerfile执行docker image build命令 4、等待Docker将应用程序构建到Docker镜像中 Once your app is containerized (made into a Docker image), you’re ready to ship it and run it as a container.《Docker Deep Dive》 使用Dockerfile定制镜像 Dockerfile最佳实践 使用Dockerfile定制镜像 Dockerfile中以#开头的都是注释行，除注释之外，每一行都是一条指令指令的的一般格式：INSTRUCTION argument，INSTRUCTION一般都为大写 示例Dockerfile：https://github.com/yeshan333/psweb123456789101112131415161718FROM alpineLABEL maintainer=&quot;nigelpoulton@hotmail.com&quot;# Install Node and NPMRUN apk add --update nodejs nodejs-npm# Copy app to /srcCOPY . /srcWORKDIR /src# Install dependenciesRUN npm installEXPOSE 8080ENTRYPOINT [&quot;node&quot;, &quot;./app.js&quot;] 说明： 每个Dockerfile文件文件的第一行一般都是FROM指令。FROM指定的镜像会作为当前镜像的一个基础镜像层，当前应用的剩余内容会作为新的镜像层添加到基础镜像层之上。，FROM建议引用官方镜像 LABEL指定当前镜像维护者，给镜像使用者一个沟通渠道 RUN apk add --update nodejs nodejs-npm将当前应用的依赖安装到镜像中，RUN指令会新建一个镜像层存储这些内容 COPY . /src会将应用相关文件从构建上下文复制到当前镜像中，这会新建一个镜像层 WORKDIR /src会为Dockerfile中未执行的指令设置工作目录 RUN npm install在当前工作目录中为应用安装依赖，这会新建一个镜像层 EXPOSE 8080对外提供一个web服务端口 ENTRYPOINT [&quot;node&quot;, &quot;./app.js&quot;]指定了当前镜像的入口程序，container运行时就会运行 构建镜像使用docker image build根据Dockerfile制作镜像，示例：123# -t用于指定制作好的镜像的名字及标签，通常 name:tag 或者 name# 最后的 . 表示使用当前目录作为构建上下文docker image build -t web:latest . 使用docker image history web:latest可以查看构建镜像过程中执行了哪些指令 推送镜像到Docker Hub 推送镜像前建议使用以下命令给镜像打新标签 12# new-tag建议以自己的 DockerHub ID/new-tag 的格式命名，方便推送到自己的repodocker image tag &lt;current-tag&gt; &lt;new-tag&gt; 使用docker image push &lt;tag-name&gt;推送镜像，推送前需要docker login,记得测试打包好的应用再推送！！！ Dockerfile常用指令 指令 说明 FROM 指定要构建的镜像的基础镜像，一般为Dockerfile文件第一行 RUN 用于在镜像中执行命令，会新建一个镜像层 COPY 一般用于将应用代码copy到镜像中，这会新建一个镜像层 WORKDIR 用于设置Dockerfile中未执行的指令的工作目录 ENTRYPOINT 指定镜像以容器方式启动后默认运行的程序， ENTRYPOINT 的命令不会被docker run指定要执行的命令覆盖 CMD 指定容器启动时执行的命令，一个 Dockerfile 中只能有一个 CMD 指令，如果写了多个，那么只有最后一个会执行。CMD 和 ENTRYPOINT 同时存在时，CMD 中的内容会变成 ENTRYPOINT 中指令命令的默认参数，该参数可以被 docker run 时设置的命令覆盖 ENV 设置镜像中的环境变量 EXPOSE 记录应用所使用的网络端口 更多： Dockerfile指令详解 Dockerfile reference","categories":[{"name":"docker","slug":"docker","permalink":"https://yeshan333.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://yeshan333.github.io/tags/docker/"}]},{"title":"几个不错的Jupyter Notebook云端展示平台","slug":"几个不错的Jupyter Notebook云端展示平台","date":"2019-08-07T01:27:50.000Z","updated":"2019-08-08T08:14:12.596Z","comments":true,"path":"2019/08/07/几个不错的Jupyter Notebook云端展示平台/","link":"","permalink":"https://yeshan333.github.io/2019/08/07/几个不错的Jupyter Notebook云端展示平台/","excerpt":"jupyter nbviewerURL:https://nbviewer.jupyter.org/ 结合Github的示例用法：https://nbviewer.jupyter.org/github/ + &lt;用户名或者用户名/存放ipynb文件的仓库或者Gist ID&gt; 例如：https://nbviewer.jupyter.org/github/yeshan333/JupyterNotebook-Show-sample","text":"jupyter nbviewerURL:https://nbviewer.jupyter.org/ 结合Github的示例用法：https://nbviewer.jupyter.org/github/ + &lt;用户名或者用户名/存放ipynb文件的仓库或者Gist ID&gt; 例如：https://nbviewer.jupyter.org/github/yeshan333/JupyterNotebook-Show-sample 还行~~~ binderURL:https://mybinder.org 使用文档：https://mybinder.readthedocs.io/en/latest/index.html# 结合Github的示例用法：https://mybinder.org/v2/gh/ + &lt;用户名/仓库名&gt; + /分支名 + ?filepath= + ipynb文件名 例如：https://mybinder.org/v2/gh/yeshan333/JupyterNotebook-Show-sample/master?filepath=demo.ipynb 很nice啊，在线交互式环境，在线跑代码，就是渲染有点小慢 google colab官方介绍:https://colab.research.google.com/notebooks/welcome.ipynb，需要科学上网 结合Github的示例用法：https://colab.research.google.com/github/ + 用户名/ + 存放ipynb文件的仓库名/ + blob/ + 分支名 + 要展示的ipynb文件路径 示例：https://colab.research.google.com/github/yeshan333/JupyterNotebook-Show-sample/blob/master/demo.ipynb 也是个在线的交互式环境，很nice了","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/tags/Python/"},{"name":"Jupyter","slug":"Jupyter","permalink":"https://yeshan333.github.io/tags/Jupyter/"}]},{"title":"pdb && cProfile","slug":"pdb-profile","date":"2019-07-28T07:55:48.000Z","updated":"2019-07-28T08:59:45.731Z","comments":true,"path":"2019/07/28/pdb-profile/","link":"","permalink":"https://yeshan333.github.io/2019/07/28/pdb-profile/","excerpt":"pdb https://docs.python.org/zh-cn/3.7/library/pdb.html#module-pdb 使用方式 1、在命令行下直接运行调试 1python -m pdb test.py 2、在需要被调试的代码中添加import pdb、pdb.set_trace()再运行代码进行调试","text":"pdb https://docs.python.org/zh-cn/3.7/library/pdb.html#module-pdb 使用方式 1、在命令行下直接运行调试 1python -m pdb test.py 2、在需要被调试的代码中添加import pdb、pdb.set_trace()再运行代码进行调试 1234567891011# test.pydef func(): print('enter func()')a = 1b = 2import pdbpdb.set_trace() # 运行到此处启动pdbfunc()c = 3print(a + b + c) 常用命令 简写 说明 p &lt;变量名&gt; 输出变量的值 l 列出源码，当前位置前后11行 n 执行吓一条语句 s 执行下一条语句，如果是函数，则会进入函数内，显示—call—，执行函数内第一条语句，执行完函数内语句后跳出显示—return— b 列出当前所有断点 b lineno 在某行添加断点 cl 清除断点 q 退出调试pdb help 帮助 cProfile-性能分析 https://docs.python.org/zh-cn/3.7/library/profile.html 123456789101112131415161718192021222324252627# test.pydef memoize(f): memo = &#123;&#125; def helper(x): if x not in memo: memo[x] = f(x) return memo[x] return helper@memoizedef fib(n): if n == 0: return 0 elif n == 1: return 1 else: return fib(n-1) + fib(n-2)def fib_seq(n): res = [] if n &gt; 0: res.extend(fib_seq(n-1)) res.append(fib(n)) return resfib_seq(30) 1python -m cProfile test.py ncalls：相应代码/函数被调用的次数 tottime：相应代码/函数执行所需时间（不包括它调用的其他代码/函数的时间） tottime percall：tottime/ncalls的结果 cumtime：对应代码/函数执行所需时间，包含它调用的其他代码/函数的时间 cumtime percall：cumtime和ncall相除的平均结果","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/tags/Python/"},{"name":"debug","slug":"debug","permalink":"https://yeshan333.github.io/tags/debug/"}]},{"title":"Python-自定义上下文管理器","slug":"Python-自定义上下文管理器","date":"2019-07-26T08:30:46.000Z","updated":"2019-07-26T10:51:09.652Z","comments":true,"path":"2019/07/26/Python-自定义上下文管理器/","link":"","permalink":"https://yeshan333.github.io/2019/07/26/Python-自定义上下文管理器/","excerpt":"上下文管理器 上下文管理器可以帮助我们自动分配和释放资源 上下文管理器需要配合with语句使用 比如进行文件操作的时候我们可能会忘记操作后关闭文件（file close），使用with open(filename, mode) as f不需要我们手动关闭文件，不管处理文件中是否有异常出现，都能保证with语句执行完毕后关闭文件，有效防止资源泄露，安全多了。 123# with 语句的一般格式with context_expression [as target(s)]: with-body 在执行with-body会调用上下文管理器的enter方法，执行完with-body之后再调用上下文管理器的exit方法","text":"上下文管理器 上下文管理器可以帮助我们自动分配和释放资源 上下文管理器需要配合with语句使用 比如进行文件操作的时候我们可能会忘记操作后关闭文件（file close），使用with open(filename, mode) as f不需要我们手动关闭文件，不管处理文件中是否有异常出现，都能保证with语句执行完毕后关闭文件，有效防止资源泄露，安全多了。 123# with 语句的一般格式with context_expression [as target(s)]: with-body 在执行with-body会调用上下文管理器的enter方法，执行完with-body之后再调用上下文管理器的exit方法 基与类的上下文管理器 基与类的上下文管理器需要我们实现对象的__enter()__和__exit()__方法 我们需要在__enter()__中管理资源对象，在__exit__()中释放资源 enter 方法在 with 语句体执行前调用，with 语句将该方法的返回值赋给 as 字句中的变量，如果有 as 字句的话 123456789101112131415161718192021222324# 模拟 Python 的打开文件、关闭文件操作class Filemanager: def __init__(self, name, mode): print('calling __init__ method') self.name = name self.mode = mode self.file = None def __enter__(self): print('caling __enter__ method') self.file = open(self.name, self.mode) return self.file def __exit__(self, exc_type, exc_val, exc_tb): print('caling __exit__ method') if self.file: self.file.close# Filemanager为上下文管理器# with Filemanager('test.txt', 'w') as f 是上下文表达式，f为资源对象 with Filemanager('test.txt', 'w') as f: print('ready to write to file') f.write('Hello World') 运行结果解析： 1、with 语句调用init方法，初始化对象 2、with 语句先暂存了Filemanager的exit方法 3、然后调用enter方法，输出caling enter method，返回资源对象（这里是文件句柄）给f 4、输出ready to write to file，将Hello World写入文件 5、最后调用exit方法，输出caling exit method，关闭之前打开的文件流 注意：exit方法中的参数exctype、excval、exc_tb分别表示exception type、exception value、traceback。进行资源回收时如果有异常抛出，那么异常的信息就会包含再这三个变量中，让我们可以再__exit中处理这些异常。例如： 12345678910111213141516171819class Foo: def __init__(self): print('__init__ called') def __enter__(self): print('__enter__ called') return self def __exit__(self, exc_type, exc_value, exc_tb): print('__exit__ called') if exc_type: print(f'exc_type: &#123;exc_type&#125;') print(f'exc_value: &#123;exc_value&#125;') print(f'exc_traceback: &#123;exc_tb&#125;') print('exception handled') return True with Foo() as obj: raise Exception('exception raised').with_traceback(None) 123456789101112131415161718192021222324输出结果：---------------------------------------1、__exit__返回 True__init__ called__enter__ called__exit__ calledexc_type: &lt;class &apos;Exception&apos;&gt;exc_value: exception raisedexc_traceback: &lt;traceback object at 0x00000234AA532F08&gt;exception handled---------------------------------------2、__exit__返回 False__init__ called__enter__ called__exit__ calledexc_type: &lt;class &apos;Exception&apos;&gt;exc_value: exception raisedexc_traceback: &lt;traceback object at 0x00000120D0324F88&gt;exception handledTraceback (most recent call last): File &quot;e:\\Blog\\shansan\\source\\_posts\\context.py&quot;, line 19, in &lt;module&gt; raise Exception(&apos;exception raised&apos;).with_traceback(None)Exception: exception raised--------------------------------------- 发生异常时，exit方法返回 True 表示不处理异常，否则会在退出该方法后重新抛出异常以由 with 语句之外的代码逻辑进行处理。 基与生成器的上下文管理器 基于生成器的上下文管理器的实现需要使用@contextmanage装饰器 我们需要在finally block 中释放资源 123456789101112from contextlib import contextmanager@contextmanagerdef file_manager(name, mode): try: f = open(name, mode) yield f finally: f.close() with file_manager('test.txt', 'w') as f: f.write('hello world') 参考 浅谈Python的with语句 上下文管理器-极客学院 http://wiki.jikexueyuan.com/project/interpy-zh/context_managers/README.html 深入理解 Python 中的上下文管理器 Python核心技术与实战-极客时间","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/tags/Python/"},{"name":"上下文","slug":"上下文","permalink":"https://yeshan333.github.io/tags/上下文/"}]},{"title":"Python协程-asyncio、async/await","slug":"Python协程（Coroutine）","date":"2019-07-19T06:58:48.000Z","updated":"2019-07-22T08:41:22.120Z","comments":true,"path":"2019/07/19/Python协程（Coroutine）/","link":"","permalink":"https://yeshan333.github.io/2019/07/19/Python协程（Coroutine）/","excerpt":"看到吐血 (´ཀ`」 ∠) 协程(Coroutine)本质上是一个函数，特点是在代码块中可以将执行权交给其他协程 众所周知，子程序（函数）都是层级调用的，如果在A中调用了B，那么B执行完毕返回后A才能执行完毕。协程与子程序有点类似，但是它在执行过程中可以中断，转而执行其他的协程，在适当的时候再回来继续执行。 协程与多线程相比的最大优势在于：协程是一个线程中执行，没有线程切换的开销；协程由用户决定在哪里交出控制权 这里用到的是asyncio库(Python 3.7)，这个库包含了大部分实现协程的魔法工具 使用 async 修饰词声明异步函数 使用 await 语句执行可等待对象（Coroutine、Task、Future） 使用 asyncio.create_task 创建任务，将异步函数（协程）作为参数传入，等待event loop执行 使用 asyncio.run 函数运行协程程序，协程函数作为参数传入","text":"看到吐血 (´ཀ`」 ∠) 协程(Coroutine)本质上是一个函数，特点是在代码块中可以将执行权交给其他协程 众所周知，子程序（函数）都是层级调用的，如果在A中调用了B，那么B执行完毕返回后A才能执行完毕。协程与子程序有点类似，但是它在执行过程中可以中断，转而执行其他的协程，在适当的时候再回来继续执行。 协程与多线程相比的最大优势在于：协程是一个线程中执行，没有线程切换的开销；协程由用户决定在哪里交出控制权 这里用到的是asyncio库(Python 3.7)，这个库包含了大部分实现协程的魔法工具 使用 async 修饰词声明异步函数 使用 await 语句执行可等待对象（Coroutine、Task、Future） 使用 asyncio.create_task 创建任务，将异步函数（协程）作为参数传入，等待event loop执行 使用 asyncio.run 函数运行协程程序，协程函数作为参数传入 解析协程运行时12345678910111213141516171819202122232425262728import asyncioimport timeasync def a(): print(\"欢迎使用 a ！\") await asyncio.sleep(1) print(\"欢迎回到 a ！\")async def b(): print(\"欢迎来到 b ！\") await asyncio.sleep(2) print(\"欢迎回到 b ！\")async def main(): task1 = asyncio.create_task(a()) task2 = asyncio.create_task(b()) print(\"准备开始\") await task1 print(\"task1 结束\") await task2 print(\"task2 结束\")if __name__ == \"__main__\": start = time.perf_counter() asyncio.run(main()) print('花费 &#123;&#125; s'.format(time.perf_counter() - start)) 解释： 1、asyncio.run(main())，程序进入main()函数，开启事件循环 2、创建任务task1、task2并进入事件循环等待运行 3、输出准备开始 4、执行await task1，用户选择从当前主任务中切出，事件调度器开始调度 a 5、a 开始运行，输出欢迎使用a！，运行到await asyncio.sleep(1)，从当前任务切出，事件调度器开始调度 b 6、b 开始运行，输出欢迎来到b！，运行到await asyncio.sleep(2)，从当前任务切出 7、以上事件运行时间非常短（毫秒），事件调度器开始暂停调度 8、一秒钟后，a的sleep完成，事件调度器将控制权重新交给a，输出欢迎回到a！，task1完成任务，退出事件循环 9、await task1完成，事件调度器将控制权还给主任务，输出task1结束，然后在await task2处继续等待 10、两秒钟后，b的sleep完成，事件调度器将控制权重新传给 b，输出欢迎回到 b！，task2完成任务，从事件循环中退出 11、事件调度器将控制权交还给主任务，主任务输出task2结束，至此协程任务全部结束，事件循环结束。 上面的代码也可以这样写，将15到21行换成一行await asyncio.gather(a(), b())也能实现类似的效果，await asyncio.gather 会并发运行传入的可等待对象（Coroutine、Task、Future）。 12345678910111213141516171819202122import asyncioimport timeasync def a(): print(\"欢迎使用 a ！\") await asyncio.sleep(1) print(\"欢迎回到 a ！\")async def b(): print(\"欢迎来到 b ！\") await asyncio.sleep(2) print(\"欢迎回到 b ！\")async def main(): await asyncio.gather(a(), b())if __name__ == \"__main__\": start = time.perf_counter() asyncio.run(main()) print('花费 &#123;&#125; s'.format(time.perf_counter() - start)) 异步接口同步实现12345678910111213141516171819202122232425\"\"\"- 简单爬虫模拟- 这里用异步接口写了个同步代码\"\"\"import asyncioimport timeasync def crawl_page(url): print('crawling &#123;&#125;'.format(url)) sleep_time = int(url.split('_')[-1]) await asyncio.sleep(sleep_time) # 休眠 print('OK &#123;&#125;'.format(url))async def main(urls): for url in urls: await crawl_page(url) # await会将程序阻塞在这里，进入被调用的协程函数，执行完毕后再继续start = time.perf_counter()# pip install nest-asyncioasyncio.run(main(['url_1', 'url_2'])) # 协程接口print(\"Cost &#123;&#125; s\".format(time.perf_counter() - start)) 使用Task实现异步1234567891011121314151617181920212223# 异步实现import asyncioimport timeasync def crawl_page(url): print('crawling &#123;&#125;'.format(url)) sleep_time = int(url.split('_')[-1]) await asyncio.sleep(sleep_time) print('OK &#123;&#125;'.format(url))async def main(urls): tasks = [asyncio.create_task(crawl_page(url)) for url in urls] for task in tasks: await task # 14、15行也可以换成这一行await asyncio.gather(*tasks) # *tasks 解包列表，将列表变成了函数的参数，与之对应的是，** dict 将字典变成了函数的参数start = time.perf_counter()asyncio.run(main(['url_1', 'url_2']))print(\"Cost &#123;&#125; s\".format(time.perf_counter() - start)) 生产者消费者模型的协程版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 极客时间：Python核心技术与实战import asyncioimport randomimport timeasync def consumer(queue, id): \"\"\"消费者\"\"\" while True: val = await queue.get() print('&#123;&#125; get a val : &#123;&#125;'.format(id, val)) await asyncio.sleep(1)async def producer(queue, id): \"\"\"生产者\"\"\" for _ in range(5): val = random.randint(1, 10) await queue.put(val) print('&#123;&#125; put a val: &#123;&#125;'.format(id, val)) await asyncio.sleep(1)async def main(): queue = asyncio.Queue() consumer_1 = asyncio.create_task(consumer(queue, 'consumer_1')) consumer_2 = asyncio.create_task(consumer(queue, 'consumer_2')) producer_1 = asyncio.create_task(producer(queue, 'producer_1')) producer_2 = asyncio.create_task(producer(queue, 'producer_2')) await asyncio.sleep(10) # cancel掉执行之间过长的consumer_1、consumer_2,while True consumer_1.cancel() consumer_2.cancel() # return_exceptions 设为True，不让异常throw到执行层，影响后续任务的执行 await asyncio.gather(consumer_1, consumer_2, producer_1, producer_2, return_exceptions=True)if __name__ == \"__main__\": start = time.perf_counter() asyncio.run(main()) print(\"Cost &#123;&#125; s\".format(time.perf_counter() - start)) 12345678910111213141516171819202122# 输出结果producer_1 put a val: 7producer_2 put a val: 4consumer_1 get a val : 7consumer_2 get a val : 4producer_1 put a val: 6producer_2 put a val: 1consumer_2 get a val : 6consumer_1 get a val : 1producer_1 put a val: 8producer_2 put a val: 1consumer_1 get a val : 8consumer_2 get a val : 1producer_1 put a val: 6producer_2 put a val: 4consumer_2 get a val : 6consumer_1 get a val : 4producer_1 put a val: 7producer_2 put a val: 8consumer_1 get a val : 7consumer_2 get a val : 8Cost 10.0093015 s 拓展阅读：Python的生产者消费者模型，看这篇就够了 参考 https://docs.python.org/3/library/asyncio.html#module-asyncio 深入理解asyncio（一） 揭密Python协程","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/tags/Python/"},{"name":"协程","slug":"协程","permalink":"https://yeshan333.github.io/tags/协程/"}]},{"title":"breaking一如既往的帅","slug":"breaking一如既往的帅","date":"2019-07-12T13:29:25.000Z","updated":"2019-07-12T13:41:30.400Z","comments":true,"path":"2019/07/12/breaking一如既往的帅/","link":"","permalink":"https://yeshan333.github.io/2019/07/12/breaking一如既往的帅/","excerpt":"","text":"看到了就爱上了，(๑•̀ㅂ•́)و✧Cloud的style move真的帅~~~（虽然很久没玩breaking了。。。。。(ノへ￣、)）","categories":[{"name":"随笔","slug":"随笔","permalink":"https://yeshan333.github.io/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://yeshan333.github.io/tags/随笔/"}]},{"title":"Latex基本语法简记","slug":"latex基本语法简记","date":"2019-06-18T07:05:57.000Z","updated":"2019-07-27T01:54:27.660Z","comments":true,"path":"2019/06/18/latex基本语法简记/","link":"","permalink":"https://yeshan333.github.io/2019/06/18/latex基本语法简记/","excerpt":"公式插入方式 行内公式可用\\(...\\)或... 例如f(x)=x^2,显示为$ f(x)=x^2 $ 独立公式（单独另起一行,公式会居中），使用$$$…$$$或\\[...\\] 例如：$$$ \\limit{f(x)dx} $$$或\\int_a^b{f(x)dx} 1234561. 行内公式可用`\\(...\\)`或`$...$`- 例如`$ f(x)=x^2 $`,显示为$ f(x)=x^2 $2. 独立公式（单独另起一行,公式会居中），使用`$$...$$`或`\\[...\\]`- 例如：`$$ \\limit&#123;f(x)dx&#125; $$`或$$ \\int_a^b&#123;f(x)dx&#125; $$","text":"公式插入方式 行内公式可用\\(...\\)或... 例如f(x)=x^2,显示为$ f(x)=x^2 $ 独立公式（单独另起一行,公式会居中），使用$$$…$$$或\\[...\\] 例如：$$$ \\limit{f(x)dx} $$$或\\int_a^b{f(x)dx} 1234561. 行内公式可用`\\(...\\)`或`$...$`- 例如`$ f(x)=x^2 $`,显示为$ f(x)=x^2 $2. 独立公式（单独另起一行,公式会居中），使用`$$...$$`或`\\[...\\]`- 例如：`$$ \\limit&#123;f(x)dx&#125; $$`或$$ \\int_a^b&#123;f(x)dx&#125; $$ 大括号的使用1234567891011121314151617181920212223方法一：$$ f(x)=\\left\\&#123;\\begin&#123;aligned&#125;x &amp; = &amp; \\cos(t) \\\\y &amp; = &amp; \\sin(t) \\\\z &amp; = &amp; \\frac xy\\end&#123;aligned&#125;\\right.$$方法二：$$ F^&#123;HLLC&#125;=\\left\\&#123;\\begin&#123;array&#125;&#123;rcl&#125;F_L &amp; &amp; &#123;0 &lt; S_L&#125;\\\\F^*_L &amp; &amp; &#123;S_L \\leq 0 &lt; S_M&#125;\\\\F^*_R &amp; &amp; &#123;S_M \\leq 0 &lt; S_R&#125;\\\\F_R &amp; &amp; &#123;S_R \\leq 0&#125;\\end&#123;array&#125; \\right. $$方法三:$$f(x)=\\begin&#123;cases&#125;0&amp; \\text&#123;x=0&#125;\\\\1&amp; \\text&#123;x!=0&#125;\\end&#123;cases&#125;$$ 方法一： f(x)=\\left\\{ \\begin{aligned} x & = & \\cos(t) \\\\ y & = & \\sin(t) \\\\ z & = & \\frac xy \\end{aligned} \\right.方法二： F^{HLLC}=\\left\\{ \\begin{array}{rcl} F_L & & {0 < S_L}\\\\ F^*_L & & {S_L \\leq 0 < S_M}\\\\ F^*_R & & {S_M \\leq 0 < S_R}\\\\ F_R & & {S_R \\leq 0} \\end{array} \\right.方法三: f(x)= \\begin{cases} 0& \\text{x=0}\\\\ 1& \\text{x!=0} \\end{cases}符号表要输出字符 空格 # $ % &amp; { } ，用命令：`\\空格 # $ \\% \\&amp; { }` 运算符表关系运算符 命令 显示 命令 显示 \\pm $\\pm$ \\times $\\times$ \\div $\\div$ \\mid $\\mid$ \\nmid $\\nmid$ \\cdot $\\cdot$ \\circ $\\circ$ \\ast $\\ast$ \\bigodot $\\bigodot$ \\bigotimes $\\bigotimes$ \\bigoplus $\\bigoplus$ \\leq $\\leq$ \\geq $\\geq$ \\neq $\\neq$ \\approx $\\approx$ \\equiv $\\equiv$ \\sum $\\sum$ \\prod $\\prod$ 集合运算符 命令 显示 命令 显示 \\emptyset $\\emptyset$ \\in $\\in$ \\notin $\\notin$ \\subset $\\subset$ \\supset $\\supset$ \\subseteq $\\subseteq$ \\supseteq $\\supseteq$ \\bigcap $\\bigcap$ \\bigcup $\\bigcup$ \\bigvee $\\bigvee$ \\bigwedge $\\bigwedge$ \\biguplus $\\biguplus$ \\bigsqcup $\\bigsqcup$ &ensp; &ensp; 对数运算符 命令 显示 命令 显示 命令 显示 \\log $\\log$ \\lg $\\lg$ \\ln $\\ln$ 三角运算符 命令 显示 命令 显示 命令 显示 \\bot $\\bot$ \\angle $\\angle$ 30^\\circ $30^\\circ$ \\sin $\\sin$ \\cos $\\cos$ \\tan $\\tan$ \\cot $\\cot$ \\sec $\\sec$ \\csc $\\csc$ 微积分运算符 命令 显示 命令 显示 命令 显示 \\prime $\\prime$ \\int $\\int$ \\iint $\\iint$ \\iiint $\\iiint$ \\oint $\\oint$ \\lim $\\lim$ \\infty $\\infty$ \\nabla $\\nabla$ &ensp; &ensp; 逻辑运算符 命令 显示 命令 显示 命令 显示 \\because $\\because$ \\therefore $\\therefore$ \\forall $\\forall$ \\exists $\\exists$ \\not= $\\not=$ \\not&gt; $\\not&gt;$ \\not&lt; $\\not&lt;$ \\not\\subset $\\not\\subset$ &ensp; &ensp; 其它符号戴帽和连线符号 命令 显示 命令 显示 命令 显示 \\hat{y} $\\hat{y}$ \\check{y} $\\check{y}$ \\breve $\\breve{y}$ \\overline{a+b+c+d} $\\overline{a+b+c+d}$ \\underline{a+b+c+d} $\\underline{a+b+c+d}$ \\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0} $\\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0}$ 箭头符号 命令 显示 命令 显示 命令 显示 \\uparrow $\\uparrow$ \\downarrow $\\downarrow$ \\Uparrow $\\Uparrow$ \\Downarrow $\\Downarrow$ \\rightarrow $\\rightarrow$ \\leftarrow $\\leftarrow$ \\Rightarrow $\\Rightarrow$ \\Leftarrow $\\Leftarrow$ \\longrightarrow $\\longrightarrow$ \\Longrightarrow $\\Longrightarrow$ \\longleftarrow $\\longleftarrow$ \\Longleftarrow $\\Longleftarrow$ 矩阵基本语法 起始标记\\begin{matrix},结束标记\\end{matrix} 每一行末标记\\\\进行换行，行间元素以&amp;分隔用于对齐。 12345$$\\begin&#123;matrix&#125;1&amp;0&amp;0\\\\0&amp;1&amp;0\\\\0&amp;0&amp;1\\\\\\end&#123;matrix&#125;$$ \\begin{matrix} 1&0&0\\\\ 0&1&0\\\\ 0&0&1\\\\ \\end{matrix}进阶 可用下列词替换matrix设置矩阵边框 pmatrix、bmatrix、Bmatrix：小括号、中括号、大括号边框 vmatrix、Vmatrix：单竖线、双竖线边框 省略元素 横省略号：\\cdots 竖省略号：\\vdots 斜省略号：\\ddots 123456$$\\begin&#123;Bmatrix&#125;&#123;a_&#123;11&#125;&#125;&amp;&#123;a_&#123;12&#125;&#125;&amp;&#123;\\cdots&#125;&amp;&#123;a_&#123;1n&#125;&#125;\\\\&#123;a_&#123;21&#125;&#125;&amp;&#123;a_&#123;22&#125;&#125;&amp;&#123;\\cdots&#125;&amp;&#123;a_&#123;2n&#125;&#125;\\\\&#123;\\vdots&#125;&amp;&#123;\\vdots&#125;&amp;&#123;\\ddots&#125;&amp;&#123;\\vdots&#125;\\\\&#123;a_&#123;m1&#125;&#125;&amp;&#123;a_&#123;m2&#125;&#125;&amp;&#123;\\cdots&#125;&amp;&#123;a_&#123;mn&#125;&#125;\\\\\\end&#123;Bmatrix&#125;$$ \\begin{Bmatrix} {a_{11}}&{a_{12}}&{\\cdots}&{a_{1n}}\\\\ {a_{21}}&{a_{22}}&{\\cdots}&{a_{2n}}\\\\ {\\vdots}&{\\vdots}&{\\ddots}&{\\vdots}\\\\ {a_{m1}}&{a_{m2}}&{\\cdots}&{a_{mn}}\\\\ \\end{Bmatrix}希腊字母表 命令 显示 命令 显示 \\alpha $\\alpha$ \\beta $\\beta$ \\gamma $\\gamma$ \\delta $\\delta$ \\epsilon $\\epsilon$ \\zeta $\\zeta$ \\eta $\\eta$ \\theta $\\theta$ \\iota $\\iota$ \\kappa $\\kappa$ \\lambda $\\lambda$ \\mu $\\mu$ \\nu $\\nu$ \\xi $\\xi$ \\pi $\\pi$ \\rho $\\rho$ \\sigma $\\sigma$ \\tau $\\tau$ \\upsilon $\\upsilon$ \\phi $\\phi$ \\chi $\\chi$ \\psi $\\psi$ \\omega $\\omega$ &ensp; &ensp; 如果需要大写的希腊字母，将命令首字母大写即可 例如：\\Gamma,显示$ \\Gamma $ 如果要将字母斜体显示，使用\\var前缀即可 例如：\\varGamma，显示$ \\varGamma $ 杂项 分组： 使用{}将具有相同等级的内容扩入其中，成组处理。 比如：\\10^10呈现为$10^10$，10^{10}呈现为$10^{10}$。 空格： 单个空格：a\\ b，$a\\ b$ 四个空格：a\\quad b,$a\\quad b$ 上标^，下标_ 尖括号\\langle\\rangle：$\\langle\\rangle$ 使用\\left或\\right使符号大小与临近的公式符号相适应，对比如下： (\\frac{x}{y})：$(\\frac{x}{y})$ \\left(\\frac{x}{y}\\right)：$\\left(\\frac{x}{y}\\right)$ 分式： \\frac{1}{3}：$\\frac{1}{3}$ 1 \\over 3：$1 \\over 3$ 开根\\sqrt[n]{3}：$\\sqrt[n]{3}$ 省略号： \\ldots：与文本底线对齐的省略号 \\cdots：与文本中线对齐的省略号 f(x_1,x_2,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2：$f(x_1,x_2,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2$ 综合运用示范123% 极限运算$$\\lim\\limits_&#123;n \\rightarrow +\\infty&#125; \\frac&#123;1&#125;&#123;n(n+1)&#125;$$ $$\\lim_&#123;n \\rightarrow +\\infty&#125; \\frac&#123;1&#125;&#123;n(n+1)&#125;$$ \\lim\\limits_{n \\rightarrow +\\infty} \\frac{1}{n(n+1)}\\lim_{n \\rightarrow +\\infty} \\frac{1}{n(n+1)}1$$ \\left[J_\\alpha(x) = \\sum_&#123;m=0&#125;^\\infty \\frac&#123;(-1)^m&#125;&#123;m! \\Gamma (m + \\alpha + 1)&#125; &#123;\\left(&#123; \\frac&#123;x&#125;&#123;2&#125; &#125;\\right)&#125;^&#123;2m + \\alpha&#125;\\right] $$ \\left[J_\\alpha(x) = \\sum_{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha}\\right]参考 MathJax使用LaTeX语法编写数学公式教程 MathJax 语法参考 基本数学公式语法(of MathJax) MathJax basic tutorial and quick reference","categories":[{"name":"math","slug":"math","permalink":"https://yeshan333.github.io/categories/math/"}],"tags":[{"name":"Latex","slug":"Latex","permalink":"https://yeshan333.github.io/tags/Latex/"}]},{"title":"MATLAB基操复习","slug":"MATLAB基操复习","date":"2019-06-17T11:51:57.000Z","updated":"2019-07-27T02:13:57.101Z","comments":true,"path":"2019/06/17/MATLAB基操复习/","link":"","permalink":"https://yeshan333.github.io/2019/06/17/MATLAB基操复习/","excerpt":"MATLAB基本操作1. 对象定义使用sym定义单个对象、使用syms定义多个对象 2. 使用limit求极限 \\lim_{v \\rightarrow a} f(x)1limit(f,v,a) % 使用limit(f,v,a,'left')可求左极限 3. 导数使用diff(f,v,n)对$ f(v)=v^{t-1} $求 $ n $ 阶导 $ \\frac{d^nf}{d^nv} $，n缺省时，默认为1，diff(f)默认求一阶导数。 4. 定积分和不定积分使用int(f,v)求f对变量v的不定积分，使用int(f,v,a,b)求f对变量v的定积分,a、b为积分上下标。$ \\int{f(v)dv} $、$ \\int^{a}_{b}{f(v)dv} $。","text":"MATLAB基本操作1. 对象定义使用sym定义单个对象、使用syms定义多个对象 2. 使用limit求极限 \\lim_{v \\rightarrow a} f(x)1limit(f,v,a) % 使用limit(f,v,a,'left')可求左极限 3. 导数使用diff(f,v,n)对$ f(v)=v^{t-1} $求 $ n $ 阶导 $ \\frac{d^nf}{d^nv} $，n缺省时，默认为1，diff(f)默认求一阶导数。 4. 定积分和不定积分使用int(f,v)求f对变量v的不定积分，使用int(f,v,a,b)求f对变量v的定积分,a、b为积分上下标。$ \\int{f(v)dv} $、$ \\int^{a}_{b}{f(v)dv} $。 5. matlab函数文件定义形式 12function [输出形参列表] = 函数名（输入形参列表） 函数体 12345678910111213141516171819202122232425262728293031323334353637function spir_len = spirallength(d, n, lcolor)% SPIRALLENGTH plot a circle of radius as r in the provided color and calculate its area % 输入参数： % d: 螺旋的旋距% n: 螺旋的圈数% lcolor：画图线的颜色% 输出参数：% spir_len：螺旋的周长% 调用说明：% spirallength(d,n):以参数d,n画螺旋线，螺旋线默认为蓝色% spirallength(d,n,lcolor):以参数d,n,lcolor画螺旋线% spir_len = spirallength(d,n):计算螺旋线的周长，并以蓝色填充螺旋线% spir_len = spirallength(d,n,lcolor):计算螺旋线的周长，并以lcolor颜色填充螺旋线 % 版本号V1.0，编写于1999年9月9号，修改于1999年9月10号，作者：亚索 if nargin &gt; 3 error('输入变量过多！');elseif nargin == 2 lcolor = 'b'; % 默认情况下为蓝色end j = sqrt(-1); phi = 0 : pi/1000 : n*2*pi; amp = 0 : d/2000 : n*d; spir = amp .* exp(j*phi); if nargout == 1 spir_len = sum(abs(diff(spir))); fill(real(spir), imag(spir), lcolor); elseif nargout == 0 plot(spir, lcolor); else error('输出变量过多！'); end axis('square'); 6. matlab程序设计语句 1234567891011121314151617181920212223242526272829303132333435363738% for循环for 循环变量=初值:步长:终值 循环体end% while循环while 条件 循环体end% if语句if 条件 语句组1elseif 语句组2else 语句组3end% switch语句switch 表达式 case 表达式1 语句组1 case 表达式2 语句组2 ... ... case 表达式m 语句组m otherwise 语句组end% try语句try 语句组1 %语句组1若正确则跳出该结构catch 语句组2end 7. 矩阵操作 操作 作用 size(A) 求矩阵A的行数和列数 length(x) 返回向量x的长度 A’ A的转置 A(:,n) 取矩阵A第n列数，A(n,:)取第n行 det(A) 求矩阵A的行列式 inv(A) 求A的逆 rank(A) 求A的秩 trace(A) 求A的迹 max(A)、min(A) 求A的各列最大、最小元素 mean(A) 求A各列的平均值 sum(A) 求A各列元素之和 8. matlab简单绘图 &ensp;plot函数是MATLAB中最核心的二维绘图函数，有诸多语法格式，可实现多种功能。常用格式有： plot(x)：缺省自变量的绘图格式，x可为向量或矩阵。 plot(x, y)：基本格式，x和y可为向量或矩阵。 plot(x1, y1, x2, y2,…)：多条曲线绘图格式，在同一坐标系中绘制多个图形。 plot(x, y,‘s’)：开关格式，开关量字符串s设定了图形曲线的颜色、线型及标示符号（见下表）。 无约束优化问题求解fminbnd、fminunc函数输出变量解释 变量 描述 x 由优化函数求得的值. 若exitflag&gt;0,则x为解; 否则,x不是最终解, 它只是迭代制止时优化过程的值 fval 解 x 处的目标函数值 exitflag 描述退出条件:exitflag&gt;0,表目标函数收敛于解x处；exitflag=0,表已达到函数评价或迭代的最大次数；exitflag&lt;0,表目标函数不收敛 output 包含优化结果信息的输出结构。Iterations:迭代次数；Algorithm:所采用的算法；FuncCount:函数评价次数 一元函数无约束优化问题-fminbnd常用格式min f(x)， x_1","categories":[{"name":"math","slug":"math","permalink":"https://yeshan333.github.io/categories/math/"}],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://yeshan333.github.io/tags/MATLAB/"}]},{"title":"搜索技巧","slug":"搜索技巧","date":"2019-06-08T12:22:17.000Z","updated":"2019-06-08T12:54:21.015Z","comments":true,"path":"2019/06/08/搜索技巧/","link":"","permalink":"https://yeshan333.github.io/2019/06/08/搜索技巧/","excerpt":"搜索也是门学问啊，GFW之下，世道艰难。 (ノ~、)","text":"搜索也是门学问啊，GFW之下，世道艰难。 (ノ~、) 百度高级搜索技巧双引号精确匹配 格式：”搜索词” 在查询词两边加上双引号表示查询词不能被拆分。 减号（-）不含特定查询 格式：搜索词 -排除词 减号后面紧跟的是需要排除的词，前面为要搜索的词（有个空格隔开） site，限制搜索范围在特定站点 格式：搜索词 site:站点域名 site:后面紧跟站点域名， 不要带协议头。site:和域名之前没有空格。 inurl，搜索范围限定在url链接中 格式：搜索词 inurl:url中必须存在的词 intitle，搜索范围限定在网页标题 格式：搜索词 intitle:标题必须含有的词 filetype，搜索范围限定在指定文件格式中 格式：搜索词 filetype:文件格式名 -源于百度:https://jingyan.baidu.com/article/d621e8dae7593c2864913f7b.html","categories":[{"name":"随笔","slug":"随笔","permalink":"https://yeshan333.github.io/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://yeshan333.github.io/tags/随笔/"}]},{"title":"Python面向对象","slug":"Python面向对象","date":"2019-05-24T04:54:40.000Z","updated":"2019-05-31T04:54:40.000Z","comments":true,"path":"2019/05/24/Python面向对象/","link":"","permalink":"https://yeshan333.github.io/2019/05/24/Python面向对象/","excerpt":"对象：一个自包含的实体，用一组可识别的特性和行为来标识 类：具有相同的属性和功能的对象的抽象的集合 实例：一个真实的对象，实例化就是创建对象的过程 多态：可对不同类型的对象执行相同的操作，而这些操作就像“被施了魔法”一样能够正常运行 封装：对外部隐藏有关对象工作原理的细节 继承：可基于通用类创建专用类 多态 多态可以让我们在不知道变量指向哪种对象时，也能够对其执行操作，且操作的行为将随对象所属的类型（类）而异。每当不知道对象是什么样就能对其执行操作，都是多态在起作用 多态以 继承 和 重写 父类方法 为前提 多态是调用方法的技巧，不会影响到类的内部设计 多态性即向不同的对象发送同一个消息，不同的对象在接收时会产生不同的行为（即方法） 听说Python天然就多态 12345678910111213141516171819202122232425class Person(object): def __init__(self,name,sex): self.name = name self.sex = sex def print_title(self): if self.sex == \"male\": print(\"man\") elif self.sex == \"female\": print(\"woman\")class Child(Person): # Child 继承 Person def print_title(self): if self.sex == \"male\": print(\"boy\") elif self.sex == \"female\": print(\"girl\") May = Child(\"May\",\"female\")Peter = Person(\"Peter\",\"male\")print(May.name,May.sex,Peter.name,Peter.sex)# 同一消息May.print_title()Peter.print_title()","text":"对象：一个自包含的实体，用一组可识别的特性和行为来标识 类：具有相同的属性和功能的对象的抽象的集合 实例：一个真实的对象，实例化就是创建对象的过程 多态：可对不同类型的对象执行相同的操作，而这些操作就像“被施了魔法”一样能够正常运行 封装：对外部隐藏有关对象工作原理的细节 继承：可基于通用类创建专用类 多态 多态可以让我们在不知道变量指向哪种对象时，也能够对其执行操作，且操作的行为将随对象所属的类型（类）而异。每当不知道对象是什么样就能对其执行操作，都是多态在起作用 多态以 继承 和 重写 父类方法 为前提 多态是调用方法的技巧，不会影响到类的内部设计 多态性即向不同的对象发送同一个消息，不同的对象在接收时会产生不同的行为（即方法） 听说Python天然就多态 12345678910111213141516171819202122232425class Person(object): def __init__(self,name,sex): self.name = name self.sex = sex def print_title(self): if self.sex == \"male\": print(\"man\") elif self.sex == \"female\": print(\"woman\")class Child(Person): # Child 继承 Person def print_title(self): if self.sex == \"male\": print(\"boy\") elif self.sex == \"female\": print(\"girl\") May = Child(\"May\",\"female\")Peter = Person(\"Peter\",\"male\")print(May.name,May.sex,Peter.name,Peter.sex)# 同一消息May.print_title()Peter.print_title() 封装 封装指的是向外部隐藏不必要的细节。与多态有点像，他们都是抽象的原则。多态让你无需知道对象所属的类（对象的类型）就能调用其方法。封装让你无需知道对象的构造就能够使用它。 实现封装可以对类内的属性和方法的访问加以限制。就像C++类使用private、protected一样对类的成员访问进行限制一样 默认情况下，Python中的属性和方法都是公开的，可以在对象外部访问 私有变量 Python并没有真正的私有化支持，但可用下划线得到伪私有。 在Python定义私有变量只需在变量名或函数名前加上两个下划线__,例如__name。那种仅限在一个对象内部访问的“私有”变量在Python中并不存在 使用双下划线将方法或属性变为私有时，在内部，Python将以双下划线开头的名字都进行转换，即在开头加上一个下划线和类名。但这样的私有变量或方法还是可以访问的，访问形式如：实例名.类名__变量名、实例名.类名__方法名() 以单下划线开头的时保护成员变量，只有本类和子类成员实例能访问这些变量 property装饰器、slots魔法 我们可以使用property装饰器对属性进行封装、通过getter和setter方法进行属性的访问和修改 Python是一门动态语言，可以在程序运行时给对象绑定属性和方法，也可以对已经绑定的属性和方法进行解绑定，我们可以使用slots魔法限定对象可以绑定的属性 继承&amp;&amp;派生 一个新类从已有类那里获得其已有特性，这种现象称为继承。从一个已有类（父类，Python叫超类）产生一个新的子类，称为类的派生。要指顶定超类，可在class语句中的类名后加上超类名，并将其用原括括起来 一个类可以继承多个类（多重继承）。但是，如果多个超类以不同的方式实现了同一个方法（即有多个同名的方法），必须在class语句中小心排列这些类，因为位于前面的类的方法将覆盖位于后面的类的方法 对子类的实例调用方法（或访问其属性）时，如果找不到该方法或者属性，将在父类中查找 在子类中可以重写超类的方法（包括构造函数），重写构造函数时，要确保在子类的构造函数中调用超类的构造函数，否则可能无法正确的初始化对象 Python中所有的方法实际上是virtual的 123456789class Person: def __init__(self,name): print(\"我叫&#123;&#125;\".format(name)) class Student(Person): def __init__(self,name): # 使用super函数调用父类构造函数 super().__init__(name) # 也可以写成这样：Person.__init__(self,name) print(\"我是一个学生！\") 抽象基类 抽象基类是不能（至少是不应该）实例化的类，其职责是定义子类应该实现的一组抽象方法。Python可通过引入ABC模块实现抽象基类，使用@abstractmethod装饰器将方法标记为抽象的。例如： 1234class Basic&#123; public: virtual void talk() const = 0;//纯虚函数&#125;; 123456from abc import ABC, abstractmethodclass Basic(ABC): @abstractmethod def talk(self): pass 抽象类（即包含抽象方法的类）最重要的特征是不能实例化。如果派生出的类没有重写talk方法，那么派生出的类也是抽象的，不能实例化。 鸭子类型 “鸭子类型”的语言是这么推断的：一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那它就可以被当做鸭子。也就是说，它不关注对象的类型，而是关注对象具有的行为(方法)。例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为鸭的对象，并调用它的走和叫方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的走和叫方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的走和叫方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名 鸭子类型的关注点在对象的行为，而不在对象的类型 参考：https://zhuanlan.zhihu.com/p/59299729 类方法、静态方法 类方法：使用@classmethod装饰器定义。类方法将类本身作为对象进行操作,类方法的第一个参数必须是当前类对象（一般命名为cls,用于传递类的属性和方法），实例对象和类对象都可以调用类方法。 静态方法：使用@staticmethod装饰器定义。没有self和cls参数。在方法中不能使用类或实例任何属性和方法。实例和对象都可以调用静态方法。 参考： https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/Day09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6.md","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/tags/Python/"}]},{"title":"Jupyter Notebooks的简单了解","slug":"Jupyter-Notebooks的简单了解","date":"2019-05-22T14:00:25.000Z","updated":"2019-05-22T16:02:01.093Z","comments":true,"path":"2019/05/22/Jupyter-Notebooks的简单了解/","link":"","permalink":"https://yeshan333.github.io/2019/05/22/Jupyter-Notebooks的简单了解/","excerpt":"玩Python这么久了，连Jupyter都不会，有点捞，今天补一补这方面的操作。。。。 Jupyter Notebooks&ensp;&ensp;Jupyter Notebooks 是一款开源的网络应用，我们可以将其用于创建和共享代码与文档。其提供了一个环境，你无需离开这个环境，就可以在其中编写你的代码、运行代码、查看输出、可视化数据并查看结果。因此，这是一款可执行端到端的数据科学工作流程的便捷工具，其中包括数据清理、统计建模、构建和训练机器学习模型、可视化数据等等。 安装pip install ipython jupyter 上手上手在终端输入jupyter notebook启动Jupyter notebooks,它会在默认浏览器中打开，地址是http://localhost:8888/tree。","text":"玩Python这么久了，连Jupyter都不会，有点捞，今天补一补这方面的操作。。。。 Jupyter Notebooks&ensp;&ensp;Jupyter Notebooks 是一款开源的网络应用，我们可以将其用于创建和共享代码与文档。其提供了一个环境，你无需离开这个环境，就可以在其中编写你的代码、运行代码、查看输出、可视化数据并查看结果。因此，这是一款可执行端到端的数据科学工作流程的便捷工具，其中包括数据清理、统计建模、构建和训练机器学习模型、可视化数据等等。 安装pip install ipython jupyter 上手上手在终端输入jupyter notebook启动Jupyter notebooks,它会在默认浏览器中打开，地址是http://localhost:8888/tree。 新建个Python文件试试 Jupyter常用键盘快捷键esc和enter用于切换Jupyter的键盘输入模式，esc切换为命令模式（blue），enter切换为编辑模式（green） 命令模式(常用) 连续按两下D，删除当前活跃单元 按A在活跃单元上插入一个单元，按B在活跃单元下插入一个单元 按Z撤销被删除的单元 按Y将当前单元变为代码单元 按Shift+方向上下键选择多个单元，按Shift+M可以合并选择的单元 Ctrl+Shift+F用于打开命令面板 按H查看快捷键完整列表 编辑模式（常用） Ctrl+S保存（防死机(๑•̀ㅂ•́)و✧） Ctrl+Home回到单元起始位置 Ctrl+Enter运行整个单元块 Alt+Enter运行当前活跃单元块，并在当前活跃单元块下方创建新的单元块 emmm可以划水了。。。。 了解更多： 始于Jupyter Notebooks：一份全面的初学者实用指南 jupyter notebook使用技巧 Jupyter介绍和使用 中文版","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/tags/Python/"}]},{"title":"Python多进程&&多线程（初步）","slug":"Python多进程-多线程","date":"2019-05-11T13:40:32.000Z","updated":"2019-06-07T03:54:37.796Z","comments":true,"path":"2019/05/11/Python多进程-多线程/","link":"","permalink":"https://yeshan333.github.io/2019/05/11/Python多进程-多线程/","excerpt":"进程 &amp;&amp; 线程 进程：进程是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或者wpawn的方式来创建新的进程执行其他任务，不过新的进程有自己独立的内存空间和数据栈，所以必须通过进程间的通信机制（IPC，Inter Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存等。 线程：进程的一个执行单元。线程在同一个进程中执行，共享程序的上下文。一个进程中的各个线程与主线程共享同一片数据空间，因而相比与独立的进程，线程间的信息共享和通信更为容易。线程一般是以并发的方式执行的。注意在单核CPU系统中，真正的并发是不可能的，所以新城的执行实际上是这样规划的：每个线程执行一小会，然后让步给其他线程的任务（再次排队等候更多的CPU执行时间）。在整个线程的执行过程中，每个线程执行它自己的特定的任务，在必要时和其他进程进行结果通信。 Python多进程（使用multiprocessing）1234567891011121314151617181920212223242526from time import time, sleepfrom random import randintfrom multiprocessing import Processdef my_task(name): sleep_time = randint(1,10) sleep(sleep_time) print(\"你叫了一声%s，它鸟你用了%d秒\" % (name, sleep_time))def main(): start = time() process_1 = Process(target=my_task, args=[\"yeshan\", ]) process_2 = Process(target=my_task, args=[\"foel\", ]) # 启动进程 process_1.start() process_2.start() # 等待进程执行结束 process_1.join() process_2.join() end = time() print(\"一共花费了%f秒\" % (end-start))if __name__ == '__main__': main()","text":"进程 &amp;&amp; 线程 进程：进程是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或者wpawn的方式来创建新的进程执行其他任务，不过新的进程有自己独立的内存空间和数据栈，所以必须通过进程间的通信机制（IPC，Inter Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存等。 线程：进程的一个执行单元。线程在同一个进程中执行，共享程序的上下文。一个进程中的各个线程与主线程共享同一片数据空间，因而相比与独立的进程，线程间的信息共享和通信更为容易。线程一般是以并发的方式执行的。注意在单核CPU系统中，真正的并发是不可能的，所以新城的执行实际上是这样规划的：每个线程执行一小会，然后让步给其他线程的任务（再次排队等候更多的CPU执行时间）。在整个线程的执行过程中，每个线程执行它自己的特定的任务，在必要时和其他进程进行结果通信。 Python多进程（使用multiprocessing）1234567891011121314151617181920212223242526from time import time, sleepfrom random import randintfrom multiprocessing import Processdef my_task(name): sleep_time = randint(1,10) sleep(sleep_time) print(\"你叫了一声%s，它鸟你用了%d秒\" % (name, sleep_time))def main(): start = time() process_1 = Process(target=my_task, args=[\"yeshan\", ]) process_2 = Process(target=my_task, args=[\"foel\", ]) # 启动进程 process_1.start() process_2.start() # 等待进程执行结束 process_1.join() process_2.join() end = time() print(\"一共花费了%f秒\" % (end-start))if __name__ == '__main__': main() 我们通过Process类创建了进程对象，通过target参数我们传入一个函数来表示进程启动后要执行的代码，后面的args是一个元组，它代表了传递给函数的参数。Process对象的start方法用来启动进程，join方法表示等待进程执行结束。 Python多线程（使用threading）123456789101112131415161718192021222324252627282930313233#!/usr/bin/env python#-*- coding:utf-8 -*-from time import time, sleepfrom random import randintfrom threading import Threaddef download(filename): print(\"开始下载 %s ...\" % filename) download_time = randint(1,10) sleep(download_time) print(\"下载完成！耗时 %d 秒\" % download_time)def main(): start = time() t1 = Thread(target=download, args=('黑暗地宫',)) t1.start() t2 = Thread(target=download, args=('通天',)) t2.start() t1.join() t2.join() end = time() print(\"下载总共耗时 %.3f 秒\" % (end-start))if __name__ == '__main__': main() 继承Thread类，实现自定义线程类 123456789101112131415161718192021222324252627282930313233343536373839#-*- coding:utf-8 -*-from time import time, sleepfrom random import randintfrom threading import Threadclass DownLoadTask(Thread): def __init__(self, filename): super().__init__() #初始化父类的构造函数 self._filename = filename # 私有的 def run(self): print(\"开始下载 %s ...\" % self._filename) download_time = randint(1,10) sleep(download_time) print(\"%s下载完成！耗时 %d 秒\" % (self._filename, download_time))def main(): strat = time() t1 = DownLoadTask(\"从菜鸟到菜鸡\") t1.start() t2 = DownLoadTask(\"去哪里啊弟弟\") t2.start() t1.join() t2.join() end = time() print(\"下载完成，总共耗费 %.3f 秒\" % (end-strat))if __name__ == '__main__': main() 线程间的通信 因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from time import sleepfrom threading import Thread, Lockclass Account(object): def __init__(self): self._balance = 0 self._lock = Lock() def deposit(self, money): # 先获取锁才能获取后面的代码 self._lock.acquire() try: # 计算存款后的余额 new_balance = self._balance + money # 模拟受理存款业务需要0.01秒的时间 sleep(0.01) # 修改账户余额 self._balance = new_balance finally: self._lock.release() @property def balance(self): return self._balanceclass AddMoneyThread(Thread): def __init__(self, account, money): super().__init__() self._account = account self._money = money def run(self): self._account.deposit(self._money)def main(): account = Account() threads = [] # 创建100个存款的线程向同一个账户中存钱 for _ in range(100): t = AddMoneyThread(account, 1) threads.append(t) t.start() # 等所有存款的线程都执行完毕 for t in threads: t.join() print('账户余额为: ￥%d元' % account.balance)if __name__ == '__main__': main() 输出结果为100块，不用锁为2块 Python内置装饰器 property property装饰器一般存在于类中，可以将一个函数定义成一个属性，属性的值就是该函数return的内容 1234567891011121314class Student(object): # 把一个方法变成属性 @property def score(self): return self._score # setter把一个方法变成一个可控属性用于赋值 @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value 参考： 一篇文章搞懂装饰器的用法 https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/Day13/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.md","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/tags/Python/"}]},{"title":"HTTPie的使用","slug":"HTTPie的使用","date":"2019-04-23T15:47:48.000Z","updated":"2019-04-23T15:51:09.246Z","comments":true,"path":"2019/04/23/HTTPie的使用/","link":"","permalink":"https://yeshan333.github.io/2019/04/23/HTTPie的使用/","excerpt":"","text":"HTTPie（发音为aitch-tee-tee-pie）是一个命令行HTTP客户端。其目标是使与Web服务的CLI交互尽可能人性化。它提供了一个简单的http命令，允许使用简单自然的语法发送任意HTTP请求，并显示彩色输出。HTTPie可用于测试，调试以及通常与HTTP服务器交互。 HTTPie官方文档 https://httpie.org/doc windows下安装 pip install --upgrade httpie HTTPie的简单使用一个完整的请求语句的大概样子http [选项(flags)] [方法] URL [查询字符串/数据字段/首部字段] HTTPie数据语法 类型 符号 示例 URL参数 == param==value 首部字段 : Name:value 数据字段 = field=value 原生JSON字段 := field:=json 表单上传字段 @ field@dir/file 示例1234567891011121314# 下载文件$ http --download www.jb51.net/my_file.zip# 提交表单$ http -f POST www.jb51.net name='Dan Nanni' comment='Hi there'# HTTPie的默认数据类型为JSON格式的$ http PUT example.org name=John email=john@example.org# 使用代理$ http --proxy=http:http://10.10.1.10:3128 --proxy=https:https://10.10.1.10:1080 example.org# 定制请求头$ http www.test.com User-Agent:Xmodulo/1.0 Referer:http://www.imike.me MyParam:Foo 放着先。。。。。。。。。占个位","categories":[],"tags":[]},{"title":"Git Branch Practice","slug":"Git-Branch-Practice","date":"2019-04-08T04:52:55.000Z","updated":"2019-04-08T06:06:29.229Z","comments":true,"path":"2019/04/08/Git-Branch-Practice/","link":"","permalink":"https://yeshan333.github.io/2019/04/08/Git-Branch-Practice/","excerpt":"","text":"最近在弄一个东西，基本的功能已经弄好了，现在想再扩展一起其他功能，但这样势必会改动原有代码，我又不想破坏原有的代码逻辑，方便以后查看。记得Git有个分支工作流可以很好的满足我的需求(๑•̀ㅂ•́)و✧。emmm，很久没发文了，record一下吧。(ノへ￣、) 使用到的命令12345678910111213$ git branch # 显示所有本地分支$ git branch &lt;new branch&gt; # 创建新分支$ git checkout &lt;branch&gt; # 切换到指定分支$ git branch -d &lt;branch&gt; # 删除本地分支$ git push --set-upstream origin &lt;branch&gt; # 将本地分支与远程分支关联$ git push origin --delete &lt;branch&gt; # 删除远程分支$ git tag -n # 列出所有本地标签以及相关信息$ git tag &lt;tagname&gt; # 基于最新提交创建标签&amp; git tag &lt;tagname&gt; -m \"备注信息\" # 基于最新提交创建含备注信息的标签 $ git tag -d &lt;tagname&gt; # 删除标签$ git push orign &lt;tagname&gt; # 将指定信息推送到远程仓库$ git push --tags # 推送所有标签到远程仓库 操作~操作 emmm，顺便试试tag","categories":[{"name":"Git","slug":"Git","permalink":"https://yeshan333.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yeshan333.github.io/tags/Git/"}]},{"title":"吐槽","slug":"吐槽","date":"2019-03-21T16:51:31.000Z","updated":"2019-06-29T04:27:30.609Z","comments":true,"path":"2019/03/22/吐槽/","link":"","permalink":"https://yeshan333.github.io/2019/03/22/吐槽/","excerpt":"","text":"better and better","categories":[],"tags":[]},{"title":"我与vim的亲密接触(ˉ▽￣～)","slug":"我与vim的亲密接触","date":"2019-03-20T15:51:17.000Z","updated":"2019-03-21T18:06:28.114Z","comments":true,"path":"2019/03/20/我与vim的亲密接触/","link":"","permalink":"https://yeshan333.github.io/2019/03/20/我与vim的亲密接触/","excerpt":"emmm，闲来无事，打算了解下神奇vim（用来zhuangbi）。在终端操作很帅(ˉ▽￣～)~~！什么是vim？？Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 vi/vim的使用vi/vim有三种模式： 命令模式：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。刚启动时就是这个模式。 输入模式：正常的文本录入。 末行模式：保存或退出文档，以及设置编辑环境。又可成为底线命令模式。","text":"emmm，闲来无事，打算了解下神奇vim（用来zhuangbi）。在终端操作很帅(ˉ▽￣～)~~！什么是vim？？Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 vi/vim的使用vi/vim有三种模式： 命令模式：控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。刚启动时就是这个模式。 输入模式：正常的文本录入。 末行模式：保存或退出文档，以及设置编辑环境。又可成为底线命令模式。 常用命令命令模式常用命令： 命令 作用 dd 删除（剪切）光标所在整行 5dd 删除（剪切）从光标处开始的5行 yy 复制光标所在的整行 5yy 复制从光标处开始的5行 n 显示搜索命令定位到的下一个字符串 N 显示搜索命令定位到的上一个字符串 u 撤销上一步的操作 p 将之前删除（dd）或复制（yy）过的数据粘贴到光标后面 末行模式可用命令： 命令 作用 :w 保存 :q 退出 :q! 强制退出（放弃对文档内容的修改） :wq! 强制保存退出 :set nu 显示行号 :set nonu 不显示行号 :命令 执行该命令 :整数 跳转到该行 :s/one/two 将当前光标所在行的第一个one替换成two :s/one/two/p 将当前光标所在行的所有one替换成two :%s/one/two/g 将全文中的所有one替换成two ?字符串 在文本中从下到上搜索该字符串 /字符串 在文本中从上到下搜索该字符串 我与它的亲密接触。。。。。 相关 vim官网：https://www.vim.org/ vim快捷键键位图：https://www.jianshu.com/p/8b986f572a61","categories":[{"name":"Linux","slug":"Linux","permalink":"https://yeshan333.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://yeshan333.github.io/tags/Linux/"}]},{"title":"SQLAlchemy建立数据库模型之间的关系","slug":"SQLAlchemy建立数据库模型之间的关系","date":"2019-03-20T09:45:17.000Z","updated":"2019-03-20T09:51:31.580Z","comments":true,"path":"2019/03/20/SQLAlchemy建立数据库模型之间的关系/","link":"","permalink":"https://yeshan333.github.io/2019/03/20/SQLAlchemy建立数据库模型之间的关系/","excerpt":"常见关系： 一对多关系 多对一关系 多对多关系 一对一关系 一对多关系（一个作者，多篇文章）123456789101112131415161718192021222324252627282930## 一对多关系，单作者-多文章，外键不可少## 外键(ForeignKey)总在多的那边定义,关系(relationship)总在单的那边定义class Author(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) phone = db.Column(db.String(20)) # articles为关系属性(一个集合，可以像列表一样操作，在关系的出发侧定义 ## relationship()函数的第一个参数为关系另一侧的模型名称(Article) articles = db.relationship('Article')class Article(db.Model): id = db.Column(db.Integer, primary_key=True) title = db.Column(db.String(15), index=True) body = db.Column(db.Text) # 传入ForeignKey的参数形式为：\"表名.字段名\" ## 模型类对应的表名由Flask-SQLAlchemy生成，默认为类名称的小写形式，多个单词通过下划线分隔 author_id = db.Column(db.Integer, db.ForeignKey('author.id')) ## 外键字段(author_id)和关系属性(articles)的命名没有限制## 建立关系可通过操作关系属性进行&gt;&gt;&gt;shansan = Author(name=\"shansan\")&gt;&gt;&gt;hello = Article(title=\"Hello world !\")&gt;&gt;&gt;boy = Article(title=\"Hello Boy !\")&gt;&gt;&gt;db.session.add(shansan) # 将创建的数据库记录添加到会话中&gt;&gt;&gt;db.session.add(hello)&gt;&gt;&gt;db.session.add(boy)&gt;&gt;&gt;shansan.articles.append(hello) # 操作关系属性&gt;&gt;&gt;shansan.articles.append(boy)&gt;&gt;&gt;db.session.commit()","text":"常见关系： 一对多关系 多对一关系 多对多关系 一对一关系 一对多关系（一个作者，多篇文章）123456789101112131415161718192021222324252627282930## 一对多关系，单作者-多文章，外键不可少## 外键(ForeignKey)总在多的那边定义,关系(relationship)总在单的那边定义class Author(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) phone = db.Column(db.String(20)) # articles为关系属性(一个集合，可以像列表一样操作，在关系的出发侧定义 ## relationship()函数的第一个参数为关系另一侧的模型名称(Article) articles = db.relationship('Article')class Article(db.Model): id = db.Column(db.Integer, primary_key=True) title = db.Column(db.String(15), index=True) body = db.Column(db.Text) # 传入ForeignKey的参数形式为：\"表名.字段名\" ## 模型类对应的表名由Flask-SQLAlchemy生成，默认为类名称的小写形式，多个单词通过下划线分隔 author_id = db.Column(db.Integer, db.ForeignKey('author.id')) ## 外键字段(author_id)和关系属性(articles)的命名没有限制## 建立关系可通过操作关系属性进行&gt;&gt;&gt;shansan = Author(name=\"shansan\")&gt;&gt;&gt;hello = Article(title=\"Hello world !\")&gt;&gt;&gt;boy = Article(title=\"Hello Boy !\")&gt;&gt;&gt;db.session.add(shansan) # 将创建的数据库记录添加到会话中&gt;&gt;&gt;db.session.add(hello)&gt;&gt;&gt;db.session.add(boy)&gt;&gt;&gt;shansan.articles.append(hello) # 操作关系属性&gt;&gt;&gt;shansan.articles.append(boy)&gt;&gt;&gt;db.session.commit() 基于一对多的双向关系（bidirectional relationship）在这里我们希望可以在Book类中存在这样一个属性：通过调用它可以获取对应的作者的记录，这类返回单个值的关系属性称为标量关系属性 1234567891011121314151617181920212223# 建立双向关系时，关系两边都有关系函数# 在关系函数中，我们使用back_populates参数连接对方，参数的值设置为关系另一侧的关系属性名class Writer(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) # back_populates的参数值为关系另一侧的关系属性名 books = db.relationship('Book', back_populates='writer') def __repr__(self): return '&lt;Writer %r&gt;' % self.nameclass Book(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(50), index=True) writer_id = db.Column(db.Integer, db.ForeignKey('writer.id')) writer = db.relationship('Writer', back_populates='books') def __repr__(self): return '&lt;Book %r&gt;' % self.name# 设置双向属性后，我们既可以通过集合属性操作关系，也可通过标量关系属性操作关系 多对一关系（多个市民都在同一个城市）123456789101112# 外键总在多的一侧定义## 多对一关系中，外键和关系属性都在多的一侧定义## 这里的关系属性是标量关系属性（返回单一数据）class Citizen(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(20), unique=True) city_id = db.Column(db.Integer, db.ForeignKey('city.id')) city = db.relationship('City')class City(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(20), unique=True) 一对一关系（国家和首都）12345678910111213## 一对一关系，将关系函数的uselist参数设为False，使得集合关系属性无法使用列表语义操作## 这里使用的是一对一双向关系class Country(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(20), unique=True) capital = db.relationship('Capital', uselist=False)class Capital(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(20), unique=True) country_id= db.Column(db.Integer, db.ForeignKey('country.id')) country = db.relationship('Country') 多对多双向关系（老师和学生） 多对多关系的建立需要使用关联表（association table）。关联表不存储数据，只用来存储关系两侧模型的外键对应关系 定义关系两侧的关系函数时，需要添加一个secondary参数，值设为关联表的名称 关联表由使用db.Table类定义，传入的第一个参数为关联表的名称 我们在关联表中将多对多的关系分化成了两个一对多的关系 1234567891011121314151617181920## 多对多关系，使用关联表（association table），关联表由db.Table定义## 关系函数需要设置secondary参数，值为关系表名association_table = db.Table('association_table', db.Column('student_id', db.Integer, db.ForeignKey('teacher.id')), db.Column('teacher_id', db.Integer, db.ForeignKey('student.id')) )class Student(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) grade = db.Column(db.String(20)) teachers = db.relationship('Teacher', secondary=association_table,back_populates='students')class Teacher(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(70), unique=True) office = db.Column(db.String(20)) students = db.relationship('Student', secondary=association_table, back_populates='teachers') 常用的SQLAlchemy关系函数参数和常用的SQLAlchemy关系记录加载方式（lazy参数可选值） 使用关系函数定义的属性不是数据库字段，而是类似于特定的查询函数 当关系属性被调用时，关系函数会加载相应的记录 相关http://www.sqlalchemy.org/ https://github.com/sqlalchemy/sqlalchemy https://github.com/mitsuhiko/flask-sqlalchemy","categories":[{"name":"Flask","slug":"Flask","permalink":"https://yeshan333.github.io/categories/Flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://yeshan333.github.io/tags/Flask/"}]},{"title":"Flask的请求钩子与上下文简记","slug":"Flask的请求钩子与上下文简记","date":"2019-03-16T14:32:05.000Z","updated":"2019-03-21T16:07:43.928Z","comments":true,"path":"2019/03/16/Flask的请求钩子与上下文简记/","link":"","permalink":"https://yeshan333.github.io/2019/03/16/Flask的请求钩子与上下文简记/","excerpt":"请求钩子(Hook) 在客户端和服务器交互的过程中，有些准备工作或扫尾工作需要处理，比如：在请求开始时，建立数据库连接；在请求结束时，指定数据的交互格式。为了让&gt;每个视图函数避免编写重复功能的代码，Flask提供了通用设施的功能，即请求钩子。通过请求钩子，我们可以对请求进行预处理(preprocessing)和后处理&gt;(postprocessing)。 Flask的请求钩子通过装饰器实现，每个钩子可以注册任意多个处理函数，默认的五种请求钩子如下: 钩子 说明 before_first_request 注册一个函数，在处理请求前运行 before_request 注册一个函数，在处理每个请求前运行 after_request 注册一个函数，如果有未处理的一场抛出。会在每个请求结束后运行 teardown_request 注册一个函数，即使有未处理的异常抛出，会在每个请求介绍后执行。如果发生异常，会传入异常对象作为参数注册到函数中 after_this_request 在视图函数内注册一个函数，在这个请求结束后运行","text":"请求钩子(Hook) 在客户端和服务器交互的过程中，有些准备工作或扫尾工作需要处理，比如：在请求开始时，建立数据库连接；在请求结束时，指定数据的交互格式。为了让&gt;每个视图函数避免编写重复功能的代码，Flask提供了通用设施的功能，即请求钩子。通过请求钩子，我们可以对请求进行预处理(preprocessing)和后处理&gt;(postprocessing)。 Flask的请求钩子通过装饰器实现，每个钩子可以注册任意多个处理函数，默认的五种请求钩子如下: 钩子 说明 before_first_request 注册一个函数，在处理请求前运行 before_request 注册一个函数，在处理每个请求前运行 after_request 注册一个函数，如果有未处理的一场抛出。会在每个请求结束后运行 teardown_request 注册一个函数，即使有未处理的异常抛出，会在每个请求介绍后执行。如果发生异常，会传入异常对象作为参数注册到函数中 after_this_request 在视图函数内注册一个函数，在这个请求结束后运行 假如我们创建了三个视图函数A、B、C，其中视图C使用了after_this_request钩子，那么当请求A进入后，整个请求处理周期的请求处理函数调用流程如图: 上下文 什么是上下文？上下文相当于一个容器，它保存了程序运行过程中的一些信息，它是当前环境的一个快照(snapshot)。Flask中有两种上下文，程序上下文(application context)和请求上下文(request context)。程序上下文中包含了程序运行所必须的信息；请求上下文里包含了请求的各种信息，比如请求的URL、HTTP方法等 上下文全局变量我们知道，Flask将请求报文封装在request对象中。按照一般的思路，如果我们要在视图函数中使用它，就得把它作为参数传入视图函数，就像我们接收URL变量一样。但这样就会导致大量的重复，而且增加了的程序的负担。不一般的是，我们可以从Flask导入一个全局的request变量，在视图函数中直接调用request的属性获取数据。这是为什么？因为Flask会在每个请求产生后后自动激活当前请求的上下文，激活请求上下文后，request被临时设置为全局可访问。在每个请求结束后，Flask就会销毁对应的请求上下文。 Flask提供的四个上下文全局变量如下： 变量名 上下文类别 说明 current_app 程序上下文 指向处理请求的当前程序实例 g 程序上下文 替代Python的全局变量用法，确保仅在当前请求可用，用于存储全局数据，每次请求都会重设 request 请求上下文 封装客户端发出的请求报文数据 session 请求上下文 用于记住请求之间的数据，通过签名的Cookie实现 不同的视图函数中，request对象都表示和视图函数对应的请求，也就是当前请求 程序存在多个程序实例的情况，使用current_app可获取对应的实例 上下文的激活请求进入时，Flask会自动激活请求上下文，此时程序上下文也被自动激活。请求处理完毕后，请求上下文和程序上下文也会自动销毁。两者具有相同的生命周期。 Flask自动激活上下文的情况： 使用flask run命令启动程序时 使用旧的app.run()方法启动程序时 执行使用@app.cli.command()装饰器注册的flask命令时 使用flask shell命令启动Python Shell时 手动激活的方法: 使用with语句，程序上下文对象可通过app.app_context()获取 使用push（）方法激活程序上下文 请求上下文可以通过test_request_context()方法临时创建 12345&gt;&gt;&gt; from app import app&gt;&gt;&gt; from flask import current_app&gt;&gt;&gt; with app.app_context(): ... current_app.name'app' 1234567&gt;&gt;&gt; from app import app&gt;&gt;&gt; from flask import current_app&gt;&gt;&gt; app_ctx = app.app_context()&gt;&gt;&gt; app_ctx.push()&gt;&gt;&gt; current_app.name'app'&gt;&gt;&gt; app_ctx.pop() 12345&gt;&gt;&gt; from app import app&gt;&gt;&gt; from flask import request&gt;&gt;&gt; with app.test_request_context('/hello'):... request.method'GET' 参考：https://book.douban.com/subject/30310340/","categories":[{"name":"Flask","slug":"Flask","permalink":"https://yeshan333.github.io/categories/Flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://yeshan333.github.io/tags/Flask/"}]},{"title":"将本地项目推送到GitHub远程仓库","slug":"将本地项目推送到GitHub远程仓库","date":"2019-03-08T15:59:28.000Z","updated":"2020-01-10T15:32:35.142Z","comments":true,"path":"2019/03/08/将本地项目推送到GitHub远程仓库/","link":"","permalink":"https://yeshan333.github.io/2019/03/08/将本地项目推送到GitHub远程仓库/","excerpt":"如何将本地项目推送到Github Tip：在本地要安装好Git，官网：https://git-scm.com/ 一个学习Git的好地方：https://try.github.io/ 在线闯关实战，边练边学的好地方：https://learngitbranching.js.org/ 方法一：使用https推送12345678910111213# 步骤# 1.创建一个目录mkdir Test# 2.将当前目录变为git管理仓库git init# 3.将文件添加到版本库，这里将目录下的所有文件都添加进去了git add .# 4.告诉git将文件提交到仓库git commit -m \"first-commit\"# 5.将当前仓库与远程仓库关联git remote add origin 远程仓库的https地址 # eg: git remote add https://github.com/ssmath/Test.git# 6.将仓库内master分支的所有内容推送到远程仓库,这里会使用到Github的账号密码git push -u origin master","text":"如何将本地项目推送到Github Tip：在本地要安装好Git，官网：https://git-scm.com/ 一个学习Git的好地方：https://try.github.io/ 在线闯关实战，边练边学的好地方：https://learngitbranching.js.org/ 方法一：使用https推送12345678910111213# 步骤# 1.创建一个目录mkdir Test# 2.将当前目录变为git管理仓库git init# 3.将文件添加到版本库，这里将目录下的所有文件都添加进去了git add .# 4.告诉git将文件提交到仓库git commit -m \"first-commit\"# 5.将当前仓库与远程仓库关联git remote add origin 远程仓库的https地址 # eg: git remote add https://github.com/ssmath/Test.git# 6.将仓库内master分支的所有内容推送到远程仓库,这里会使用到Github的账号密码git push -u origin master 方法二：使用ssh推送 生成ssh密钥 12ssh-keygen -t rsa -C \"your email address\"# eg: ssh-keygen -t rsa -C \"1329441308@qq.com\" 找到生成的文件，复制id_rsa.pub文件中的内容，文件一般在用户目录下的.ssh目录中 使用密钥与远程仓库配对，检验能否成功通讯 ssh -T git@github.com # 检验能否成功通讯 推送本地文件到github","categories":[{"name":"Git","slug":"Git","permalink":"https://yeshan333.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://yeshan333.github.io/tags/Git/"}]},{"title":"vscode配置Pipenv工作环境","slug":"vscode配置Pipenv工作环境","date":"2019-03-03T15:25:30.000Z","updated":"2019-04-28T11:23:57.261Z","comments":true,"path":"2019/03/03/vscode配置Pipenv工作环境/","link":"","permalink":"https://yeshan333.github.io/2019/03/03/vscode配置Pipenv工作环境/","excerpt":"让vscode使用Pipenv工作环境1、查看Pipenv的位置1234# 先激活Pipenv环境pipenv shell# 获取当前虚拟环境的位置pipenv --venv 2、打开setting.json配置文件 Ctrl+Shift+P，输入settings，选择Open Settings(JSon) 将之前得到的Pipenv环境路径添加进去 “python.venvPath”: “C:\\Users\\Algorithm\\.virtualenvs”","text":"让vscode使用Pipenv工作环境1、查看Pipenv的位置1234# 先激活Pipenv环境pipenv shell# 获取当前虚拟环境的位置pipenv --venv 2、打开setting.json配置文件 Ctrl+Shift+P，输入settings，选择Open Settings(JSon) 将之前得到的Pipenv环境路径添加进去 “python.venvPath”: “C:\\Users\\Algorithm\\.virtualenvs” 3、重启vscode 参考https://segmentfault.com/a/1190000017558652 https://blog.csdn.net/weixin_34294649/article/details/87518937","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/tags/Python/"}]},{"title":"Happy New Year !","slug":"Happy-New-Year","date":"2019-02-04T16:00:00.000Z","updated":"2019-07-02T08:32:05.639Z","comments":true,"path":"2019/02/05/Happy-New-Year/","link":"","permalink":"https://yeshan333.github.io/2019/02/05/Happy-New-Year/","excerpt":"","text":"12345678910111213141516171819202122232425262728C：printf(&quot;Happy New Year&quot;);C++ : cout&lt;&lt;&quot;Happy New Year&quot;;Objectivec: NSLog(@&quot;Happy New Year!&quot;);QBasic : Print &quot;Happy New Year&quot;Asp : Response.Write &quot;Happy New Year&quot;PHP : echo &quot;Happy New Year&quot;;Ruby: puts &quot;Happy New Year!&quot;JavaScript: alert(&quot;Happy New Year&quot;)VBScript:MsgBox &quot;Happy New Year&quot;JavaScript: document.write(&quot;Happy New Year&quot;)JavaScript: console.log(&apos; Happy New Year&apos;);xml &lt;TextView android:text=&quot;Happy New Year! &quot; /&gt; Delphi: ShowMessage(&apos;Happy New Year！&apos;);VB: Msg(&quot;Happy New Year！&quot;)VC: MessageBox(&quot;Happy New Year！&quot;);shell: echo Happy New Yearperl: print &apos;Happy New Year&apos;java: System.out.println(&quot;Happy New Year&quot;);LISP:(format t &quot;Happy New Year!~%&quot;)powerBuilder:messagebox（&quot;Happy New Year&quot;)C#：System.Console.WriteLine(&quot;Happy New Year!&quot;)COBOL:DISPLAY &apos;Happy New Year!&apos;Python:print(&quot;Happy New Year！&quot;)aswing:JOptionPane.showMessageDialog(&quot;happy&quot;,&quot;Happy New Year！&quot;)flex:Alert.show(&quot;Happy New Year！&quot;);Clojure: (println &quot;Happy New Year&quot;) verilog/systemverilog/e $display(&quot;Happy New Year&quot;) as:trace(&quot;Happy New Year！&quot;);","categories":[{"name":"blog","slug":"blog","permalink":"https://yeshan333.github.io/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://yeshan333.github.io/tags/blog/"}]},{"title":"HTML&&CSS(划水~~~)","slug":"HTML-CSS-划水","date":"2019-01-22T09:09:40.000Z","updated":"2019-03-24T12:48:15.680Z","comments":true,"path":"2019/01/22/HTML-CSS-划水/","link":"","permalink":"https://yeshan333.github.io/2019/01/22/HTML-CSS-划水/","excerpt":"HTML(超文本标记语言)HTML标签不区分大小写。 HTML属性 ID属性指定一个标识符，用于唯一标识页面元素，这些标识符主要供Javascript和CSS使用 class属性是一个全局属性，可用于建立元素编组。可以给多个元素指定相同的class属性，以便在CSS或Javascript中将这些元素作为一个编组来引用它们 style属性用于定义标签的样式。任何标签中都可以指定属性style。使用style属性可以为标签指定一个或多个样式规则， 在style定义多条规则的方法是用分号将他们分开","text":"HTML(超文本标记语言)HTML标签不区分大小写。 HTML属性 ID属性指定一个标识符，用于唯一标识页面元素，这些标识符主要供Javascript和CSS使用 class属性是一个全局属性，可用于建立元素编组。可以给多个元素指定相同的class属性，以便在CSS或Javascript中将这些元素作为一个编组来引用它们 style属性用于定义标签的样式。任何标签中都可以指定属性style。使用style属性可以为标签指定一个或多个样式规则， 在style定义多条规则的方法是用分号将他们分开 HTML的列表列表标签的特征： 每个列表都有一个指定列表类型的外部元素。 每个列表项都有自己的标签。 12345无序列表：&lt;ul&gt;&lt;/ul&gt;有序列表：&lt;ol&gt;&lt;/ol&gt;定义列表：&lt;dl&gt;&lt;/dl&gt;词汇列表的列表项为&lt;dt&gt;&lt;dd&gt;其他列表的列表项为&lt;li&gt; 有序列表（ol）有序列表默认的编号为罗马数字，可以使用属性style指定列表的编号样式，使用CSS属性list-style-type进行修改 1234567eg：&lt;ol style=\"list-style-type: upper-roman\"&gt; &lt;li&gt;罗马假日&lt;/li&gt; &lt;li&gt;平凡的世界&lt;/li&gt; &lt;li&gt;封神榜&lt;/li&gt; &lt;li&gt;无间道&lt;/li&gt;&lt;/ol&gt; 罗马假日 平凡的世界 封神榜 无间道 有序列表的编号样式 CSS属性list-style-type 描述 decimal(默认) 标准阿拉伯数字 lower-alpha 小写字母 upper-alpha 大写字母 lower-roman 小写罗马数字 upper-roman 大写罗马数字 无序列表（ul）无序列表编号样式 CSS属性list-style-type 描述 disc 圆盘，默认样式 square 实心正方形 circle 空心圆 123456eg：&lt;ul style=\"list-style-type: square\"&gt; &lt;li&gt;正方体&lt;/li&gt; &lt;li&gt;长方体&lt;/li&gt; &lt;li&gt;圆柱体&lt;/li&gt;&lt;/ul&gt; 正方体 长方体 圆柱体 定义列表（dl）定义列表的每个列表项都包含两部分 术语，标签为&lt;dt&gt; 术语的定义，标签为&lt;dt&gt; 1234567eg:&lt;dl&gt; &lt;dt&gt;HTML&lt;/dt&gt; &lt;dd&gt;超文本标记语言，标准通用标记语言下的一个应用。是 网页制作必备的编程语言。&lt;/dd&gt; &lt;dt&gt;CSS&lt;/dt&gt; &lt;dd&gt;层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。&lt;/dd&gt;&lt;/dl&gt; HTML 超文本标记语言，标准通用标记语言下的一个应用。是 网页制作必备的编程语言。 CSS 层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。 链接和锚链接到另一个页面的特定位置 方法： 使用锚，即在链接的URL中指定要链接到的元素的ID 123456789eg:另一个页面2.html：&lt;h2 id=\"part4\"&gt;Part four&lt;/h2&gt;当前页面1.html：&lt;a href=\"2.html#part4\"&gt;go to part four&lt;/a&gt; 链接到当前页面的其他元素 方法: 省略页面名就行，使用#号和ID 12eg:go to&lt;a href=\"#section5\"&gt;the fifth setion&lt;/a&gt; span标签span标签和style属性结合使用时，可取代很多标签，效果很nice 1234&lt;p&gt;Here is some&lt;span style=\"text-decoration: underline\"&gt; underline text&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Here is some&lt;span style=\"font-style:oblique\"&gt; oblique text&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Here is some&lt;span style=\"text-decoration:line-through\"&gt;line-through text&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Here is some&lt;span style=\"font-weight:120\"&gt; bolder text&lt;/span&gt;&lt;/p&gt; Here is some underline text Here is some oblique text Here is someline-through text Here is some bolder text HTML表格 标签 用途 &lt;table&gt;&lt;/table&gt; 定义表格 &#60;caption&#62;&#60;/caption&#62; 创建表题(可选) &#60;tr&#62;&#60;/tr&#62; 定义一个表格行，其中可包含表头单元格或数据单元格 &#60;th&#62;&#60;/th&#62; 定义一个表头单元格。表头单元格得内容通常显示为粗体，且在水平和竖直方向上都居中 &#60;td&#62;&#60;/td&#62; 定义一个数据单元格。数据单元格得内容通常显示为常规字体，在水平方向上左对齐，而且在垂直方向上居中 &#60;colgroup&#62;&#60;/colgroup&#62; 将一列或多列编组 &#60;col&#62;&#60;/col&#62; 用于定义表格列属性 &#60;thead&#62;&#60;/thead&#62; 创建表示表头的行编组。一个表格只能有一个表头 &#60;tfoot&#62;&#60;/tfoot&#62; 创建表示表尾的行编组。一个表格只能有一个表尾，它必须在表体前定义 &#60;tbody&#62;&#60;/tbody&#62; 定义一个或多个表示表体的行编组。一个表格可包含多个表头部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Table&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" style=\"width: 100%;\"&gt; &lt;caption&gt;&lt;b&gt;Science and Mathematic Class Schedules&lt;/b&gt;&lt;/caption&gt; &lt;colgroup style=\"width: 20%; text-align: center; vertical-align: top; background-color: #fcf;\"&gt; &lt;colgroup span=\"2\" style=\"width: 40%; vertical-align: top; background-color: #ccf;\"&gt; &lt;!-- span属性指定了列编组包含的列数，默认为1 --&gt; &lt;thead style=\"background-color: red;\"&gt; &lt;tr&gt; &lt;th&gt;Class&lt;/th&gt; &lt;th&gt;Room&lt;/th&gt; &lt;th&gt;Time&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody style=\"background-color: yellow;\"&gt; &lt;tr&gt; &lt;td&gt;Biology&lt;/td&gt; &lt;td&gt;Science Wing, Room 102&lt;/td&gt; &lt;td&gt;8:00 AM to 9:45 AM&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Science&lt;/td&gt; &lt;td&gt;Science Wing, Room 110&lt;/td&gt; &lt;td&gt;9:50 AM to 11:30 AM&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Physics&lt;/td&gt; &lt;td&gt;Science Wing, Room 107&lt;/td&gt; &lt;td&gt;1:00 PM to 2:45 PM&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tbody style=\"background-color: gray;\"&gt; &lt;tr&gt; &lt;td&gt;Geometry&lt;/td&gt; &lt;td&gt;Mathematics Wing, Room 236&lt;/td&gt; &lt;td&gt;8:00 AM to 9:45 Am&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Algebra&lt;/td&gt; &lt;td&gt;Mathematics Wing, Room 239&lt;/td&gt; &lt;td&gt;9:50 AM to 11:30 AM&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Trigonometry&lt;/td&gt; &lt;td&gt;Mathematics Wing, Room 245&lt;/td&gt; &lt;td&gt;1:00 PM to 2:45 PM&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;!-- tfoot一般放在tbody之前 --&gt; &lt;tfoot style=\"background-color: blue;\"&gt; &lt;tr&gt; &lt;th&gt;Class&lt;/th&gt; &lt;th&gt;Room&lt;/th&gt; &lt;th&gt;Time&lt;/th&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; text-align：指定水平对齐方式，可能取值：left、center、right vertical-align：指定垂直对齐方式，可能取值：top、middle、bottom 表格属性 属性 适用元素 用途 border table 指定表格是否带边框，默认不带。这个属性指定了表格边框的宽度 span col和colgroup 指定列编组包含多少列，必须是大于0的整数 colspan th或td 指定单元格将向右延伸横跨多少列 rowspan th或td 指定单元格将向下延伸横跨多少行 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;colspan and rowspan&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"10\" style=\"width: 100%\"&gt; &lt;caption&gt;&lt;b&gt;跨行跨列表格&lt;/b&gt;&lt;/caption&gt; &lt;!-- 跨列 --&gt; &lt;tr&gt; &lt;th colspan=\"2\"&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;/tr&gt; &lt;!-- 跨行 --&gt; &lt;tr&gt; &lt;th rowspan=\"2\"&gt;辣椒&lt;/th&gt; &lt;td&gt;牛角椒&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;灯笼椒&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; HTML表单 标签/属性 用途 &#60;form&#62; 创建HTML表单。一个文档可包含多个表单，但是不可嵌套 action 标签&#60;form&#62;的一个属性，使用URL路径指定负责处理表单数据的服务器脚本 enctype &#60;form&#62;的一个属性，指定将表单数据发送给服务器前如何对其进行编码 method &#60;form&#62;的一个属性，指定如何将表单数据发送给服务器 &#60;input&#62; 一个用于创建表单控件以收集用户输入的信息 &#60;button&#62; 创建一个可包含HTML内容的按钮 &#60;textarea&#62; 创建多行的文本输入字段 &#60;select&#62; 创建一个菜单或可滚动列表，列表项由&#60;option&#62;创建 &#60;progress&#62; 显示任务完成进度的进度条 &#60;label&#62; 创建与表单控件配套的标签 &#60;fieldset&#62; 将表单控件编组 type 标签&#60;input的一个属性&#62;，指定了表单控件的类型，可能取值：text：创建一个单行文本输入字段password：&ensp;创建一个可遮挡用户输入的单行文本输入字段hidden：&ensp;创建一个隐藏的表单控件checkbox：&ensp;创建一个复选框search：&ensp;创建一个搜索关键字输入字段file：&ensp;创建一个文件上传控件让用户能够选择要随表单数据一起上传到服务器的文件color、date、datetime、email、url、reset等等 其它 items 说明 HTML语义标签 http://www.w3school.com.cn/html/html5_semantic_elements.asp pre标签 http://www.w3school.com.cn/tags/tag_pre.asp HTML字符实体 http://www.w3school.com.cn/html/html_entities.asp CSS(层叠样式表)样式表由一系列规则组成，大致结构如下 selector { property1: value1; property } 每条规则都以选择器(selector)打头,后面是一系列有花括号括起来的属性(property)和值(value)。 每个选择器可以指定任意数量的属性,但属性之间必须用分号分隔。 在最后一个属性/值对后面,可以有分号,也可以没有。 选择器(selector) 任何标签都可以用作CSS选择器，与这种选择器相关联的规则将应用于页面中所有指定的元素 可使用单个选择器将样式应用于多种元素，元素间用逗号间隔，比如： 123p, ul &#123; color: blue&#125; 下面这个规则与上面那个等价1234567p &#123; color: blue;&#125;ul &#123; color: blue;&#125; 上下文选择器&ensp;&ensp;使用上下文选择器可以将样式应用于嵌套在指定元素内的元素 123ol em &#123; color: red;&#125; 上面那条规则应用于嵌套在有序列表中的em元素 123cite &#123; font-style: inherit; font-weight: 200;&#125;p cite &#123; font-style: italic; font-weight: 500;&#125;li cite&#123; font-style: normal; font-weight: bolder;&#125; 第一条为应用于所有cite标签的规则对于嵌套的cite标签，后两条规则说明了他们应该应用的样式 类 &amp;&amp; ID 选择器 将选择器应用于类，使用.+类名 将选择器应用于ID，使用#+ID，ID是独一无二的 给多个元素指定相同的样式可以使用类名，给单个元素指定样式可以使用ID 12345678910111213141516171819&lt;!-- 使用类型名 --&gt;&lt;div class=\"shan\"&gt;test&lt;/div&gt;&lt;!-- CSS --&gt;.shan &#123; color: red;&#125;&lt;!-- ------------------------------------ --&gt;&lt;!-- 使用ID --&gt;&lt;div id=\"footer\"&gt;Copyright 2019&lt;/div&gt;&lt;!-- CSS --&gt;#footer &#123; font-size: small;&#125; 子选择器1p &gt; span.important &#123; fot-weight: bold; &#125; 这个选择器只与p标签，属于important类的span标签匹配,与下面的span标签不匹配 1&lt;p&gt;This is a paragraph. &lt;em&gt;This is an &lt;span class=\"important\"&gt;important&lt;/span&gt; sentence.&lt;/em&gt;&lt;/p&gt; 这里的span为p的孙子 伪类http://www.w3school.com.cn/css/css_pseudo_classes.asp 锚伪类 1234a:link &#123;color: #FF0000&#125; /* 未访问的链接 */a:visited &#123;color: #00FF00&#125; /* 已访问的链接 */a:hover &#123;color: #FF00FF&#125; /* 鼠标移动到链接上 */a:active &#123;color: #0000FF&#125; /* 选定的链接 */ 更多 http://www.w3school.com.cn/css/css_selector_descendant.asp CSS度量单位 http://www.w3school.com.cn/cssref/css_units.asp CSS颜色 http://www.w3school.com.cn/cssref/css_colors.asp 盒子模型 element: 元素/内容 padding: 内边距 border: 边框 margin: 外边距 边框的属性 属性 说明 border-style 指定显示的边框类型。可能取值包括：none、dotted、dashed、solid、double、groove、ridge、inset、outset、inherit。 border-width 指定边框的宽度，单位通常为像素(px)。 border-color 指定边框颜色。 同时设置多个边框属性时，形式如下 1selector &#123; border: style width color; &#125; eg:1a &#123; border: dashed 3px red; &#125; 内边距和外边距 内边距(padding)是边框里面的空白区域 外边距(margin)是边框外面的空白区域 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;style type=\"text/css\"&gt; .outer &#123; border: 2px solid black; &#125; .inner &#123; border: 2px dotted black; padding: 15px; margin: 15px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; 工程狮 &lt;div class=\"outer\"&gt; &lt;div class=\"inner\"&gt; 攻城狮（谐音）工程师，来源于腾讯QQ手机管家于2012年3月1日16:53在发布了一条微博：&lt;br/&gt; 声称腾讯公司一名保安经过一层层技术面试进入了腾讯研究院，成为一名攻城狮（工程师）。&lt;br/&gt; 这种事儿看起来相信很多人的第一反应都是恶搞，不过不久，腾讯老大马化腾亲自出面，核实了这一事件的真实性，并且称这是个“很励志的故事”。&lt;br/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 内容(element)盒子 块式盒子 内嵌盒子 块级元素前后都换行，而内嵌元素的尺寸取决于其包含的内容以及外边距、内边距和边框的设置。CSS提供了属性display来修改元素的默认行为，属性display的可能取值有三个:block、inline和none。 边框显示了在样式表中指定的盒子的尺寸。但文本太多的时候，盒子可能无法容纳，多出来的文本可能会跑到边框的下方。这时，可以通过CSS属性overflow告诉浏览器要如何做。overflow的可能取值包括:visible(默认)、hidden、scroll、auto和inherit。 浮动（修改块级元素的排列方式） 属性float，指出浮动位置，取值：right、left、none 属性clear，消除浮动的影响，取值：none、left、right、both See the Pen 1 by Mr.Ye (@yeshan333) on CodePen. &ensp;&ensp;浮动的p元素移到了页面右边，而第二个段落出现在它的左边。通过将属于right类的元素p的样式属性float设置为right，指出了页面其他元素应沿元素绕排。我们将第三个段落的clear属性设置为both，消除了前面浮动的影响。 如果想要将第二段浮动到第一段的下方，可设置第二段的属性float为right，属性clear设置为right。仅仅设置float属性时，两个段落会并排。 12345678.main &#123; border: 3px solid black; padding: 10px; margin: 10px; float: right; clear: right; width: 33%;&#125;","categories":[{"name":"HTML","slug":"HTML","permalink":"https://yeshan333.github.io/categories/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://yeshan333.github.io/categories/CSS/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://yeshan333.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://yeshan333.github.io/tags/CSS/"}]},{"title":"你所拥有的知识并不取决于你记得多少，而在于它们能否在恰当的时候被回忆起来。","slug":"你所拥有的知识并不取决于你记得多少，而在于它们能否在恰当的时候被回忆起来。","date":"2019-01-16T15:08:36.000Z","updated":"2019-01-22T09:14:07.376Z","comments":true,"path":"2019/01/16/你所拥有的知识并不取决于你记得多少，而在于它们能否在恰当的时候被回忆起来。/","link":"","permalink":"https://yeshan333.github.io/2019/01/16/你所拥有的知识并不取决于你记得多少，而在于它们能否在恰当的时候被回忆起来。/","excerpt":"#","text":"#","categories":[{"name":"blog","slug":"blog","permalink":"https://yeshan333.github.io/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://yeshan333.github.io/tags/blog/"}]},{"title":"Jinja2语法小记","slug":"Jinja2语法小记","date":"2019-01-09T15:26:59.000Z","updated":"2019-01-09T16:01:12.435Z","comments":true,"path":"2019/01/09/Jinja2语法小记/","link":"","permalink":"https://yeshan333.github.io/2019/01/09/Jinja2语法小记/","excerpt":"jinja2模板语法小记 Jinja2模板中文文档 三种常见界定符 表达式{{ ... }} 用于装载字符串、变量、函数调用等 语句{% ... %} 用于装载控制语句，比如if判断、for循环等 注释{# ... #} 用于装载一个注释，模板渲染的时候会被忽略掉","text":"jinja2模板语法小记 Jinja2模板中文文档 三种常见界定符 表达式{{ ... }} 用于装载字符串、变量、函数调用等 语句{% ... %} 用于装载控制语句，比如if判断、for循环等 注释{# ... #} 用于装载一个注释，模板渲染的时候会被忽略掉 变量 在模板中，我们可以使用“.”获取变量的属性 1234user = &#123; 'username' : 'shansan', 'bio': '我佛了',&#125; 如果user为传入模板中的字典变量，则我们可通过”.“获取它的键值。eg：user.usernameuser.username等价于user[‘username’] 我们可以用set标签在模板中定义变量 1&#123;% set navigation = [(&apos;/&apos;,&apos;Home&apos;),(&apos;/about&apos;,&apos;关于我&apos;)] %&#125; 使用endset声明结束 过滤器(filter) 过滤器(filter)是一些可以用来修改和过滤特殊变量值的函数。过滤器和变量用一个竖线“|”（管道符号）隔开，需要参数的过滤器可以像函数一样使用括号传递 eg: 对一个movies列表使用length过滤器获取其长度 1movies|length 下面是Jinja2常用的内置过滤器 过滤器 说明 default(value,default_value,boolean=False) 设置默认值，默认值作为参数传入，别名为d escap(s) 转义HTML文本，别名为e first(seq) 返回序列的第一个元素 last(seq) 返回列表的最后一个元素 length(object) 返回变量的长度 safe(value) 将变量标记为安全，避免转义 wordcount(s) 计算单词数量 过滤器函数的第一个参数表示被过滤的变量值(value)或字符串(s)，即竖线符号左侧的值其他参数可以使用括号传入 测试器(Test) 测试器主要用来判断一个值是否满足某种变量类型,返回布尔值（True or False）的特殊函数语法为：if…is… is的左侧是测试器函数的第一个参数(value) 其他参数可以通过添加括号传入，也可以在右侧使用空格连接 Jinja2常用内置测试器 测试器 说明 callable(object) 判断对象是否可调用 defined(value) 判断变量是否已定义 none(value) 判断变量是否为None number(value) 判断变量是否为数字 string(value) 判断变量是否为字符串 sequence(value) 判断变量是否为序列，比如字符串、列表、元组 iterable(value) 判断变量是否可迭代 mapping(value) 判断变量是否是匹配对象，比如字典 smeas(value,other) 判断变量与other是否指向相同的内存地址 123&#123;% if foo is smeas(bar) %&#125;&#123;# 等价于 #&#125;&#123;% if foo is smeas bar %&#125; 判断foo和bar所以指向的内存地址是否相同 语句 在Jinja2中，语句使用{% ... %}标识在语句结束的地方，必须添加结束标签 if语句使用endif for语句使用endfor 12345&#123;% if user.name == &apos;shansan&apos; %&#125; &lt;h1&gt;you are right!&lt;/h1&gt;&#123;% else %&#125; &lt;h1&gt;you are wrong!&lt;/h1&gt;&#123;% endif %&#125; 123&#123;% for g in ga %&#125; &lt;li&gt;&#123;&#123; g.name &#125;&#125; - &#123;&#123; g.year &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125; 不可使用break和continue控制循环的执行 模板局部模板 当多个独立模板中使用到同一块HTML代码时，可以把这部分代码抽离出来，放到局部模板中 局部模板的命名一般以一个下划线开始 使用include标签插入一个局部模板 1&#123;% include &apos;_banner.html&apos; %&#125; 宏 宏，类似于Python中的函数。使用宏可以封装一部分模板代码 一般把宏寄存在即存在名为macros.html或_macros.html文件中 使用macro和endmacro标签声明宏的开始和结束 在开始标签中定义宏的名称和接收的参数 1234567&#123;% macro qux(amount=1) %&#125; &#123;% if amount==1 %&#125; I am qux. &#123;% elif amount&gt;1 %&#125; We are qux. &#123;% endif %&#125;&#123;% endmacro %&#125; 就像从Python模块中导入函数一样，我们可以使用import导入宏 1&#123;% from &apos;macros.html&apos; import qux %&#125; PS:默认情况下，使用include导入一个局部模板会传递上下文到局部模板中，但使用import却不会 模板继承 模板继承允许我们构建一个包含站点共同元素的基本模板”骨架”，并定义子模版可以覆盖的块 基模板 base.html 在基模板中定义的块（block），可以让子模版通过定义同名的块来执行继承操作 块的开始和结束分别使用block和endblock标签,不同的块允许嵌套以下示例代码中使用head、title、styles、content、footer和scripts划分了不同的标签块 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &#123;% block head %&#125; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&#123;% block title %&#125;Template - HelloFlask&#123;% endblock %&#125;&lt;/title&gt; &#123;% block styles %&#125;&#123;% endblock styles %&#125; &#123;% endblock head %&#125;&lt;/head&gt;&lt;body&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=\"&#123;&#123; url_for('index') &#125;&#125;\"&gt;Home&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;main&gt; &#123;% block content %&#125;&#123;% endblock content %&#125; &lt;/main&gt; &lt;footer&gt; &#123;% block footer %&#125; &#123;% endblock footer %&#125; &lt;/footer&gt; &#123;% block scripts %&#125;&#123;% endblock scripts %&#125;&lt;/body&gt;&lt;/html&gt; 子模版 index.html 当在子模版创建同名的块时，会使用字块的内容覆盖父块的内容 这里子模版的content块的内容覆盖了基模板content块的内容 extends 标签必须是模板中的第一个 标签 1234567891011121314&#123;% extends 'base.html' %&#125;&#123;% from 'macros.html' import qux %&#125;&#123;% block content %&#125;&#123;% set name='baz' %&#125;&lt;h1&gt;Template&lt;/h1&gt;&lt;ul&gt; &lt;li&gt;&lt;a href=\"&#123;&#123; url_for('watchlist') &#125;&#125;\"&gt;Watchlist&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Filter: &#123;&#123; foo|musical &#125;&#125;&lt;/li&gt; &lt;li&gt;Global: &#123;&#123; bar() &#125;&#125;&lt;/li&gt; &lt;li&gt;Test: &#123;% if name == 'baz' %&#125;I am baz.&#123;% endif %&#125;&lt;/li&gt; &lt;li&gt;Macro: &#123;&#123; qux(amount=5) &#125;&#125;&lt;/li&gt;&lt;/ul&gt;&#123;% endblock content %&#125; 如需要向基模板中追加内容，可以使用Jinja2的super()函数 如向基模板的styles块追加一行样式 12345678&#123;% block styles %&#125;&#123;&#123; super() &#125;&#125;&lt;style&gt; html&#123; color: red; &#125;&lt;/style&gt;&#123;% endblock %&#125; 参考： https://book.douban.com/subject/30310340/ https://www.cnblogs.com/yanzi-meng/p/8342798.html http://docs.jinkan.org/docs/jinja2/templates.html#id21","categories":[{"name":"Flask","slug":"Flask","permalink":"https://yeshan333.github.io/categories/Flask/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://yeshan333.github.io/tags/Flask/"}]},{"title":"泛型算法-1","slug":"泛型算法-1","date":"2019-01-03T10:41:00.000Z","updated":"2019-01-03T10:49:39.251Z","comments":true,"path":"2019/01/03/泛型算法-1/","link":"","permalink":"https://yeshan333.github.io/2019/01/03/泛型算法-1/","excerpt":"泛型算法-1 泛型算法实现了一些经典算法的公共接口，如排序和搜索；称它们是“泛型的”，是因为它们可以用于不同类型的元素的和多种容器类型（不仅包括标准库类型，还包括内置的数组类型），以及其它类型的序列。 大多数算法都定义在头文件algorithm中 算法永远不会执行容器的操作","text":"泛型算法-1 泛型算法实现了一些经典算法的公共接口，如排序和搜索；称它们是“泛型的”，是因为它们可以用于不同类型的元素的和多种容器类型（不仅包括标准库类型，还包括内置的数组类型），以及其它类型的序列。 大多数算法都定义在头文件algorithm中 算法永远不会执行容器的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/*算法find*//*- find将范围内中的所有元素与给定值进行比较，返回指向第一个等于给定值的迭代器- 如果范围内无匹配元素，则find返回第二个参数来表示搜索失败 */ void find_value()&#123; //find函数的返回值类型是迭代器类型 //在vector中查找值 int val = 7; vector&lt;int&gt; v&#123;1,2,3,4,5,6,7,8&#125;; auto result = find(v.begin(),v.end(),val); cout&lt;&lt;*result&lt;&lt;endl; //在数组中查找值 int nums[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; auto search = find(begin(nums),end(nums),11);//值不存在，返回尾后迭代器 cout&lt;&lt;*search&lt;&lt;endl; &#125; /*算法count*//*- 返回给定值在序列中出现的次数 */ void value_count()&#123; //count函数返回给定值在序列中出现的次数 int a[]=&#123;1,1,1,1,1,2,3,4,5,6&#125;; auto c = count(a,a+10,1); cout&lt;&lt;\"1出现的次数:\"&lt;&lt;c&lt;&lt;endl; &#125;/*算法accumulate*/ /*- accumulate将第三个参数作为求和起点- 注意序列中的元素的类型必须与第三个参数匹配 */ void sum_num()&#123; //accumulate函数用去求给定元素范围内元素的和 vector&lt;int&gt; v=&#123;1,2,3,4,5,6,7,8,9,10&#125;; auto sum = accumulate(v.begin(),v.end(),0); vector&lt;int&gt; v_compare&#123;1,2,3,4,5,6,7,8,9,10,11&#125;; if( equal(v.begin(),v.end(),v_compare.begin()) ) cout&lt;&lt;\"yeah\"&lt;&lt;endl; cout&lt;&lt;sum&lt;&lt;endl;&#125;/*算法fill*//*- 用于确定两个序列中是否保存相同的值- 第二个序列至少与第一个序列一样长 */ void init_fill()&#123; vector&lt;int&gt; v&#123;1,2,3,4,5,6,7,8&#125;; fill(v.begin(),v.end(),1);//不要对空容器使用此操作 for(auto a:v) cout&lt;&lt;a&lt;&lt;\" \";&#125;void elimDups(vector&lt;string&gt; &amp;words)&#123; void print(vector&lt;string&gt; v); sort(words.begin(),words.end()); //使用sort算法按字典序重排序列 //unique重排了输入范围，使得每个单词只出现一次， //unique返回指向不重复区域之后一个位置的迭代器 auto end_unique = unique(words.begin(),words.end()); //删除重复元素 words.erase(end_unique,words.end()); print(words);&#125;void print(vector&lt;string&gt; v)&#123; for(auto a:v) cout&lt;&lt;a&lt;&lt;\" \"; cout&lt;&lt;endl;&#125;//定制操作，按照长度重新排vectorbool isShorter(const string &amp;s1,const string &amp;s2)&#123; return s1.size() &gt; s2.size(); &#125; //按长度进行排序 void length_sort(vector&lt;string&gt; &amp;words)&#123; sort(words.begin(),words.end(),isShorter); print(words); //使用算法stable_sort来保持等长元素间的字典序 stable_sort(v.begin(),v.end(),isShorter); print(v); &#125; 向算法传递函数算法谓词 算法谓词即标准库算法传递的参数, 可以指定算法的操作，它是一个可以调用的表达式，其返回结果是一个能用作条件的值 接受谓词参数的算法对输入序列中的元素调用谓词。因此元素类型必须能转换成谓词的参数类型 标准库算法所使用的谓词分为两类：1.一元谓词：它们只接受一个参数2.二元谓词：它们接受两个参数 12345678910111213141516//定制操作，按照长度重新排vectorbool isShorter(const string &amp;s1,const string &amp;s2)&#123; return s1.size() &gt; s2.size(); &#125; //按长度进行排序 void length_sort(vector&lt;string&gt; &amp;words)&#123; sort(words.begin(),words.end(),isShorter); print(words); //使用算法stable_sort来保持等长元素间的字典序 stable_sort(v.begin(),v.end(),isShorter); print(v); &#125; 这里向算法stable_sort传递的第三个参数就是一个谓词 lambda表达式（匿名函数） lambda表达式与其它函数的区别是：lambda表达式可定义在函数内部 基本形式： 1[capture lsit](parameter list) -&gt; return type &#123;function body&#125; capture list(捕获列表): 一个lambda所在函数中的定义的局部变量的列表（通常为空） parameter list(参数列表) return type(返回类型) function body(函数体) 我们可以忽略形参列表和返回类型，但是必须永远包含捕获列表和函数体 12 auto f = []&#123;return 44;&#125; ;cout&lt;&lt;f()&lt;&lt;endl;//打印44 上面的向算法stable_sort传递的实参可以改写为,效果还是一样的 1stable_sort(v.begin(), v.end(), [](const string &amp;a,const string s&amp;b)&#123;return a.size()&lt;b.size()&#125;); 捕获列表的使用一个lambda可以出现在一个函数内部，使用其局部变量，但它只能使用那些指明的变量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;void biggies(vector&lt;string&gt; &amp;words,vector&lt;string&gt;::size_type sz)&#123; //使用sort算法按字典序重排序列 s sort(words.begin(),words.end()); //unique重排了输入范围，使得每个单词只出现一次， //unique返回指向不重复区域之后一个位置的迭代器 auto end_unique = unique(words.begin(),words.end()); //删除重复元素 words.erase(end_unique,words.end()); //按长度排序,长度相同的按字典序排 stable_sort(words.begin(),words.end(), [](const string &amp;a,const string &amp;b)&#123;return a.size() &lt; b.size();&#125;); //算法find_if返回一个迭代器，这个迭代器指向第一个满足size()&gt;=sz的元素 //这里用到了捕获列表，使用局部变量sz auto wc = find_if(words.begin(),words.end(), [sz](const string &amp;a)&#123;return a.size()&gt;sz; &#125;); //计算满足size &gt;= sz 的元素的个数 auto count = words.end() - wc; cout&lt;&lt;\"the numbers of word longer than \"&lt;&lt;sz&lt;&lt;\": \"&lt;&lt;count&lt;&lt;endl; //打印长度大于等于给定值sz的单词 //算法for_earch接受一个可调用对象，并对输入序列中的每个元素调用此对象 for_each(wc,words.end(),[](const string &amp;s)&#123; cout&lt;&lt;s&lt;&lt;\" \"; &#125;); &#125;int main()&#123; vector&lt;string&gt; words; string str; while(cin&gt;&gt;str) words.push_back(str); for(auto a:words) cout&lt;&lt;a&lt;&lt;\" \"; cout&lt;&lt;endl; biggies(words,6);//打印长度大于或等于给定值的单词 return 0;&#125; 捕获列表只用于局部非静态（static）变量，lambda可以直接使用局部static变量和在它所在函数之外声明的名字 lambada捕获和返回 变量的捕获方式有两种:值捕获、引用捕获 使用引用捕获变量时，必须确保被引用的对象在lambda执行的时候是存在的 lambda捕获的是局部变量，这些变量在函数结束后就不复存在了 我们可以从一个函数返回lambda，函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个lambda，则与函数不能返回一个局部变量类似，此lambda也不能包含引用捕获 使用&amp;、=进行隐式捕获我们可以让编译器根据lambda体中的代码来推断我们要使用哪些变量 &amp;告诉编译器采用引用捕获方式 =告诉编译器采用值捕获方式 混合使用显式捕获和隐式捕获时,显示捕获必须使用与隐式捕获不同的方式 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt; using namespace std;void biggies(vector&lt;string&gt; &amp;words, ostream &amp;os=cout, char c=' ')&#123; //os隐式捕获，c显式捕获 for_each(words.begin(), words.end(), [&amp;, c](const string &amp;s)&#123; os&lt;&lt;s&lt;&lt;c;&#125; ); printf(\"\\n\"); //c隐式捕获，os显示捕获 for_each(words.begin(), words.end(), [=, &amp;os](const string &amp;s)&#123; os&lt;&lt;s&lt;&lt;c;&#125; ); &#125;int main()&#123; vector&lt;string&gt; str; string temp; while(cin&gt;&gt;temp) str.push_back(temp); biggies(str); return 0; &#125; 指定lambda的返回类型 要为一个lambda定义返回类型时，必须使用尾置返回类型 尾置返回类型跟在形参列表后面，并以一个1234```c++auto f = [](int i)-&gt;int&#123; return i+1;&#125;;cout&lt;&lt;f(3)&lt;&lt;endl;//输出结果为：4 可变lambada使用关键字123456```c++int i=1;auto f = [i]()mutable&#123; return ++i;&#125;;i=0;cout&lt;&lt;f();//输出结果为2 lambda捕获列表 &ensp; 说明 [] 空捕获列表。lambda不能使用所在函数中的变量。一个lambda只有捕获变量后才能使用它们 [names] names是一个逗号分隔的名字列表，这些名字都是lambda所在函数的局部变量。默认情况下，捕获列表中的变量都被拷贝 [&amp;] 隐式捕获列表，采用隐式捕获方式 [=] 隐式捕获列表，采用值捕获方式 [&amp;, identifier_list] identifier_list是一个逗号分隔的列表，包含0个或多个来自所在函数的变量，这些变量采用值捕获方式。任何隐式捕获的变量都采用引用方式捕获 [=, identifier_list] identifier_list是一个逗号分隔的列表，包含0个或多个来自所在函数的变量，这些变量采用引用捕获方式，且变量名字前必须使用&amp;。任何隐式捕获的变量都采用值方式捕获","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"装饰器--python","slug":"装饰器-python","date":"2019-01-03T10:39:32.000Z","updated":"2019-03-23T09:11:24.882Z","comments":true,"path":"2019/01/03/装饰器-python/","link":"","permalink":"https://yeshan333.github.io/2019/01/03/装饰器-python/","excerpt":"python装饰器回顾返回函数","text":"python装饰器回顾返回函数 什么是装饰器 python装饰器就是用于拓展原来函数功能的一种函数，目的是在不改变原函数定义的情况下，给函数增加新的功能。这个函数的特殊之处在于它的返回值也是一个函数，这个函数是内嵌“原”函数的函数 在代码运行期间动态的增加功能装饰器(decorator)是修改其它函数功能的函数,是返回函数的高阶函数 demo12345678910111213141516171819202122232425# -*- coding: utf-8 -*-'''- 这是一个decorator- 使用一个函数作为参数- 它返回一个函数'''def a_new_decorator(a_func): def wrapTheFunction(): print(\"I am doing some boring work before executing a_func()\") a_func() print(\"I am doing some boring work after executing a_func()\") return wrapTheFunction'''- 使用a_new_decorator装饰a_function_requiring_decoration- @a_new_decorator 等价于 a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)'''@a_new_decoratordef a_function_requiring_decoration(): print(\"I am the function which needs some decoration remove my foul smell\")a_function_requiring_decoration() 运行结果 @a_new_decorator 等价于 a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration) 下面这段程序和上面那段等价 1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-def a_new_decorator(a_func): def wrapTheFunction(): print(\"I am doing some boring work before executing a_func()\") a_func() print(\"I am doing some boring work after executing a_func()\") return wrapTheFunction def a_function_requiring_decoration(): print(\"I am the function which needs some decoration to remove my foul smell\") #a_function_requiring_decoration()#outputs: \"I am the function which needs some decoration to remove my foul smell\"a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)#now a_function_requiring_decoration is wrapped by wrapTheFunction() a_function_requiring_decoration()#outputs:I am doing some boring work before executing a_func()# I am the function which needs some decoration to remove my foul smell# I am doing some boring work after executing a_func() 应用：日志打印 在wrap函数内，首先打印日志，再调用原始函数*args表示任何多个无名参数，它是一个tuple；**kwargs表示关键字参数，它是一个dict PS对于上面的demo &gt;&gt;&gt;print(a_function_requiring_decoration.__name__) #输出结果为 wrapTheFunction 明显不是我们想要的，我们函数的名字和注释文档被重写了预期应该为 a_function_requiring_decoration 使用functools.warps可以解决这个问题 上面的demo应该这样写 参考 http://www.runoob.com/w3cnote/python-func-decorators.html https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318435599930270c0381a3b44db991cd6d858064ac0000 https://eastlakeside.gitbooks.io/interpy-zh/content/decorators/ https://www.cnblogs.com/yuzhanhong/p/9180212.html","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/tags/Python/"}]},{"title":"博客搭建参考汇总","slug":"博客搭建参考汇总","date":"2019-01-01T13:20:28.000Z","updated":"2019-07-11T04:42:07.248Z","comments":true,"path":"2019/01/01/博客搭建参考汇总/","link":"","permalink":"https://yeshan333.github.io/2019/01/01/博客搭建参考汇总/","excerpt":"","text":"以下是我搭建博客参考的一些教程 hexo博客搭建教程https://blog.csdn.net/gdutxiaoxu/article/details/53576018 https://m.w3cschool.cn/hexo_blog/hexo_blog-tvpu244e.html https://www.cnblogs.com/jackyroc/p/7681938.html https://blog.csdn.net/u010820857/article/details/82027535 Yilia主题配置https://github.com/litten/hexo-theme-yilia https://www.jianshu.com/p/517263426abd 404公益页面http://www.qq.com/404/ https://blog.csdn.net/liu1340308350/article/details/81744824 使用valine评论https://panjunwen.com/diy-a-comment-system/ https://www.xxwhite.com/2017/Valine.html valine头像https://en.gravatar.com/emails?auto-applied=1 版权设置https://blog.zscself.com/2017/01/25/ee4d9ecb/ http://tc9011.com/2017/02/02/hexo%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E5%8F%8A%E4%B8%80%E4%BA%9B%E7%89%B9%E6%95%88/ 访问量统计https://blog.csdn.net/qq_40910541/article/details/80659193 https://blog.csdn.net/zxlvxj/article/details/77720934 https://ruider.github.io/2018/06/11/%E6%B7%BB%E5%8A%A0hexo-yilia%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%95%B0%E9%87%8F/ http://easydo.work/2017/10/26/hexo-yilia-page-view.html 域名绑定https://blog.csdn.net/yucicheung/article/details/79560027 https://www.jianshu.com/p/d92ea8542673?utm_campaign=haruki&amp;utm_content=note&amp;utm_medium=reader_share&amp;utm_source=qq 添加目录https://blog.csdn.net/u013082989/article/details/70212008 http://lawlite.me/2017/04/17/Hexo-yilia%E4%B8%BB%E9%A2%98%E5%AE%9E%E7%8E%B0%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95%E5%92%8C%E6%B7%BB%E5%8A%A0%E8%A7%86%E9%A2%91/","categories":[{"name":"blog","slug":"blog","permalink":"https://yeshan333.github.io/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://yeshan333.github.io/tags/blog/"}]},{"title":"2019你好","slug":"2019你好","date":"2018-12-31T16:00:00.000Z","updated":"2019-07-28T08:31:33.020Z","comments":true,"path":"2019/01/01/2019你好/","link":"","permalink":"https://yeshan333.github.io/2019/01/01/2019你好/","excerpt":"","text":"![](https://img.vim-cn.com/98/76b6778c92f439ecde44ca1ac3a26a035ef7f1.png)","categories":[{"name":"blog","slug":"blog","permalink":"https://yeshan333.github.io/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://yeshan333.github.io/tags/blog/"}]},{"title":"memory","slug":"memory","date":"2018-12-31T04:40:34.000Z","updated":"2019-04-11T15:46:44.042Z","comments":true,"path":"2018/12/31/memory/","link":"","permalink":"https://yeshan333.github.io/2018/12/31/memory/","excerpt":"","text":"搭建依托于我的个人服务器的博客emmm。。。 2018年12月24日0点10分，忽然觉得无聊，打开某云，手一贱租了台云服务器（233~~~~）。嗯，既然都租了，那就再来个博客吧。 基于typecho搭建的个人博客宝塔面板安装1yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh 网站搭建点击添加，创建网站 嗯，接下来访问自己域名（公网ip地址），看看是否创建成功 接下来配置伪静态规则 嗯，接下来搭建博客，这里使用宝塔后台无脑安装(不好意思，我太菜),还是用命令行操作吧 记得填写常用邮箱、管理员名和密码 http://typecho.org/download 嗯，接下来访问自己的域名就ok了 emm，是不是少了什么，SSL证书没有，少了小绿锁 那就去申请吧 站点管理，设置 因为我的web服务器是nigix","categories":[{"name":"blog","slug":"blog","permalink":"https://yeshan333.github.io/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://yeshan333.github.io/tags/blog/"}]},{"title":"线性表的链式存储-单链表","slug":"线性表的链式存储-单链表","date":"2018-12-14T16:28:59.000Z","updated":"2019-06-26T11:51:57.307Z","comments":true,"path":"2018/12/15/线性表的链式存储-单链表/","link":"","permalink":"https://yeshan333.github.io/2018/12/15/线性表的链式存储-单链表/","excerpt":"单链表操作 单链表的创建（尾插法、头插法） 单链表的查找操作 单链表的删除操作 单链表的逆置操作(使用头插法) 单链表表长的计算 打印单链表","text":"单链表操作 单链表的创建（尾插法、头插法） 单链表的查找操作 单链表的删除操作 单链表的逆置操作(使用头插法) 单链表表长的计算 打印单链表 单链表的创建头插法12345678910111213141516forward_list* creat_3() //头插法 &#123; forward_list *head,*s; int num; head = NULL;//链表初始状态为空 while(scanf(\"%d\",&amp;num) &amp;&amp; num) &#123; s = (forward_list*)malloc(sizeof(forward_list)); s-&gt;data = num; s-&gt;next = head; head = s;//将新结点插入到表头 &#125; return head;&#125; 尾插法（不含头结点）1234567891011121314151617181920212223//尾插法建表 forward_list* creat_1()&#123; forward_list *head=NULL;//头指针，初始状态为空 forward_list *rear=NULL;//尾指针，初始状态为空 int num; forward_list *s; while(scanf(\"%d\",&amp;num) == 1 &amp;&amp; num)//输入0结束 &#123; s = (forward_list*)malloc(sizeof(forward_list)); s-&gt;data = num; if(head == NULL)//将新节点加入空表 head = s; else //原表非空，将新节点链接到表尾之后 rear-&gt;next = s; rear = s;//尾指针指向新的表尾 &#125; if(rear!= NULL)//对于非空表，将尾结点的下一个结点置空 rear-&gt;next = NULL; return head; &#125; 尾插法（含头结点）12345678910111213141516171819202122//尾插法建表,包含头结点 forward_list* creat_2()&#123; forward_list *s; forward_list *head, *rear; int num; head = (forward_list*)malloc(sizeof(forward_list)); rear = head; while(scanf(\"%d\",&amp;num)==1 &amp;&amp; num) &#123; s = (forward_list*)malloc(sizeof(forward_list)); s-&gt;data = num; rear-&gt;next = s; rear = s;//表指针指向新的表尾 &#125; rear-&gt;next = NULL; return head;&#125; 单链表的查找操作按值查找123456789101112131415void search_1(forward_list *s, int x)&#123; forward_list *p; p = s; while(p != NULL) &#123; if(p-&gt;data == x) &#123; printf(\"\\nthe value : %d is exist !\\n\",x); return ; &#125; p = p-&gt;next; &#125; printf(\"\\nthe value : %d is not fonud !\\n\",x);&#125; 按值查找（包含头结点）123456789101112131415void search_2(forward_list *s, int x)//带头节点 &#123; forward_list *p; p = s-&gt;next;//emmmm while(p != NULL) &#123; if(p-&gt;data == x) &#123; printf(\"\\nthe value : %d is exist !\\n\",x); return ; &#125; p = p-&gt;next; &#125; printf(\"\\nthe value : %d is not fonud !\\n\",x);&#125; 单链表的删除操作按给定结点的位置删除（带头结点）1234567891011121314151617181920void delete_1(forward_list *head,int i) //删除第i个节点(单链表包含头节点)&#123; int j=0; forward_list *p,*q; p=head; j=0; while((p-&gt;next!=NULL)&amp;&amp;(j&lt;i-1)) &#123; p=p-&gt;next; j++; &#125; if(p-&gt;next!=NULL) &#123; q=p-&gt;next; p-&gt;next=p-&gt;next-&gt;next; free(q); &#125; else printf(\"illegal delete position,delete failed!\");&#125; 按照指定值删除结点(不带头结点)123456789101112131415161718192021222324void forward_list_delete_1(forward_list *s,int x)//删除链表（不带头节点）中指定值的元素 &#123; forward_list *p; forward_list *temp;//用来存放被删除元素的前一个结点 p = s; if(x == p-&gt;data) free(p); temp = p; p = p-&gt;next; while(p != NULL) &#123; if(p-&gt;data == x) &#123; temp-&gt;next = p-&gt;next; free(p); return ; &#125; temp = p; p = p-&gt;next; &#125; printf(\"\\n你要删除的元素 %d 不在表中\\n\",x); return ; &#125; 单链表的逆置头插法逆置(带头结点)12345678910111213void reverse_2(forward_list *head)//头插法逆置,带头节点 &#123; forward_list *p,*q; p=head-&gt;next; head-&gt;next=NULL; while(p) &#123; q=p; p=p-&gt;next; q-&gt;next=head-&gt;next; head-&gt;next=q; &#125;&#125; 计算单链表的表长 带头结点 1234567891011void list_length_2(forward_list *s)&#123; int count; forward_list *p=s-&gt;next; while(p) &#123; count++; p = p-&gt;next; &#125; printf(\"\\nlist length: %d\\n\",count);&#125; 不带头结点 1234567891011void list_length_1(forward_list *s)&#123; int count; forward_list *p=s; while(p) &#123; count++; p = p-&gt;next; &#125; printf(\"\\nlist length: %d\\n\",count);&#125; 打印单链表 带头结点 1234567891011void print_forward_list_2(forward_list *s)//打印含头节点的单链表 &#123; forward_list *p; p = s-&gt;next;//因为含有头节点，head-&gt;data的数据域的数据未知 while(p != NULL) &#123; printf(\"%-3d\",p-&gt;data); p = p-&gt;next; &#125; return ;&#125; 不带头结点 1234567891011void print_forward_list_1(forward_list *s)//打印单链表 &#123; forward_list *p; p = s; while(p != NULL) &#123; printf(\"%4d\",p-&gt;data); p = p-&gt;next; &#125; return ;&#125; 试试源程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;stdlib.h&gt;//定义单链表结点类型 typedef struct node&#123; int data; //结点数据域 struct node *next; //结点指针域 &#125;forward_list;//尾插法建表 forward_list* creat_1()&#123; forward_list *head=NULL;//头指针，初始状态为空 forward_list *rear=NULL;//尾指针，初始状态为空 int num; forward_list *s; while(scanf(\"%d\",&amp;num) == 1 &amp;&amp; num)//输入0结束 &#123; s = (forward_list*)malloc(sizeof(forward_list)); s-&gt;data = num; if(head == NULL)//将新节点加入空表 head = s; else //原表非空，将新节点链接到表尾之后 rear-&gt;next = s; rear = s;//尾指针指向新的表尾 &#125; if(rear!= NULL)//对于非空表，将尾结点的下一个结点置空 rear-&gt;next = NULL; return head; &#125;//尾插法建表,包含头结点 forward_list* creat_2()&#123; forward_list *s; forward_list *head, *rear; int num; head = (forward_list*)malloc(sizeof(forward_list)); rear = head; while(scanf(\"%d\",&amp;num)==1 &amp;&amp; num) &#123; s = (forward_list*)malloc(sizeof(forward_list)); s-&gt;data = num; rear-&gt;next = s; rear = s;//表指针指向新的表尾 &#125; rear-&gt;next = NULL; return head;&#125;forward_list* creat_3() //头插法 &#123; forward_list *head,*s; int num; head = NULL;//链表初始状态为空 while(scanf(\"%d\",&amp;num) &amp;&amp; num) &#123; s = (forward_list*)malloc(sizeof(forward_list)); s-&gt;data = num; s-&gt;next = head; head = s;//将新结点插入到表头 &#125; return head;&#125;void search_1(forward_list *s, int x)&#123; forward_list *p; p = s; while(p != NULL) &#123; if(p-&gt;data == x) &#123; printf(\"\\nthe value : %d is exist !\\n\",x); return ; &#125; p = p-&gt;next; &#125; printf(\"\\nthe value : %d is not fonud !\\n\",x);&#125;void search_2(forward_list *s, int x)//带头节点 &#123; forward_list *p; p = s-&gt;next;//emmmm while(p != NULL) &#123; if(p-&gt;data == x) &#123; printf(\"\\nthe value : %d is exist !\\n\",x); return ; &#125; p = p-&gt;next; &#125; printf(\"\\nthe value : %d is not fonud !\\n\",x);&#125; void reverse_1(forward_list *head)//头插法逆置单链表 &#123; forward_list *p; forward_list *temp; p = head;//存好之前的单链表 //printf(\"\\n%d\\n\",p-&gt;data); head-&gt;next = NULL; while(p) &#123; temp = p; //printf(\"1\"); p = p-&gt;next; temp-&gt;next = head-&gt;next; head = temp; printf(\"\\n%d\\n\",head-&gt;data); &#125;&#125;void reverse_2(forward_list *head)//头插法逆置,带头节点 &#123; forward_list *p,*q; p=head-&gt;next; head-&gt;next=NULL; while(p) &#123; q=p; p=p-&gt;next; q-&gt;next=head-&gt;next; head-&gt;next=q; &#125;&#125; void forward_list_delete_1(forward_list *s,int x)//删除链表（不带头节点）中指定值的元素 &#123; forward_list *p; forward_list *temp;//用来存放被删除元素的前一个结点 p = s; if(x == p-&gt;data) free(p); temp = p; p = p-&gt;next; while(p != NULL) &#123; if(p-&gt;data == x) &#123; temp-&gt;next = p-&gt;next; free(p); return ; &#125; temp = p; p = p-&gt;next; &#125; printf(\"\\n你要删除的元素 %d 不在表中\\n\",x); return ; &#125;void delete_1(forward_list *head,int i) //删除第i个节点(单链表包含头节点)&#123; int j=0; forward_list *p,*q; p=head; j=0; while((p-&gt;next!=NULL)&amp;&amp;(j&lt;i-1)) &#123; p=p-&gt;next; j++; &#125; if(p-&gt;next!=NULL) &#123; q=p-&gt;next; p-&gt;next=p-&gt;next-&gt;next; free(q); &#125; else printf(\"illegal delete position,delete failed!\");&#125; /*//不对 void list_delete(forward_list *s, int i)//删除单链表(不带头节点)的第i个结点 &#123; int count=1; forward_list *p,*q; p=s; //将p移动到被删除结点的前一个结点 while((p!=NULL)&amp;&amp;(count&lt;i-1)) &#123; p=p-&gt;next; count++; &#125; if(i == count) &#123; q = p; p = p-&gt;next; free(q); return ; &#125; if(p-&gt;next!=NULL) &#123; q=p-&gt;next; p-&gt;next=p-&gt;next-&gt;next; free(q); &#125; else printf(\"illegal delete position,delete failed!\"); &#125;*/ void list_length_1(forward_list *s)&#123; int count; forward_list *p=s; while(p) &#123; count++; p = p-&gt;next; &#125; printf(\"\\nlist length: %d\\n\",count);&#125;void list_length_2(forward_list *s)&#123; int count; forward_list *p=s-&gt;next; while(p) &#123; count++; p = p-&gt;next; &#125; printf(\"\\nlist length: %d\\n\",count);&#125;void print_forward_list_1(forward_list *s)//打印单链表 &#123; forward_list *p; p = s; while(p != NULL) &#123; printf(\"%4d\",p-&gt;data); p = p-&gt;next; &#125; return ;&#125;void print_forward_list_2(forward_list *s)//打印含头节点的单链表 &#123; forward_list *p; p = s-&gt;next;//因为含有头节点，head-&gt;data的数据域的数据未知 while(p != NULL) &#123; printf(\"%-3d\",p-&gt;data); p = p-&gt;next; &#125; return ;&#125; int main()&#123; /*不带头结点的单链表*/ printf(\"使用不带头结点的单链表:\\n\"); forward_list *p; printf(\"尾插法建表:\\n\"); p = creat_1();//尾插法建表 print_forward_list_1(p); list_length_1(p); //查找是否存在值为6的结点 search_1(p,6); printf(\"\\n删了个5后，表变为\\n\"); forward_list_delete_1(p,5); print_forward_list_1(p); //头插法建表 forward_list *s; printf(\"\\n头插法建表:\\n\"); s = creat_3(); print_forward_list_1(s); list_length_1(s); /*带头结点的单链表*/ printf(\"\\n\\n使用带头结点的单链表:\\n\"); forward_list *t; t = creat_2(); print_forward_list_2(t); search_2(t,6); list_length_2(t); printf(\"\\n逆置:\\n\"); reverse_2(t); print_forward_list_2(t); list_length_2(t); return 0;&#125; 运行结果","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://yeshan333.github.io/categories/数据结构/"}],"tags":[{"name":"C","slug":"C","permalink":"https://yeshan333.github.io/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://yeshan333.github.io/tags/数据结构/"}]},{"title":"线性表之顺序存储-顺序表","slug":"线性表之顺序存储-顺序表","date":"2018-12-14T04:14:59.000Z","updated":"2019-06-26T11:52:40.825Z","comments":true,"path":"2018/12/14/线性表之顺序存储-顺序表/","link":"","permalink":"https://yeshan333.github.io/2018/12/14/线性表之顺序存储-顺序表/","excerpt":"顺序表的操作 向有序顺序表插入一个元素 顺序表的冒泡排序 顺序表的删除操作 顺序表中元素的查找 顺序表的逆置 删除顺序表中的相同元素 向顺序表的指定位置插入元素 打印顺序表","text":"顺序表的操作 向有序顺序表插入一个元素 顺序表的冒泡排序 顺序表的删除操作 顺序表中元素的查找 顺序表的逆置 删除顺序表中的相同元素 向顺序表的指定位置插入元素 打印顺序表 顺序表的存储结构1234567#define maxsize 100 //存储空间的分配量 //定义顺序表数据类型 typedef struct&#123; int data[maxsize]; int last; //存放表中最后一个元素的下标 &#125;sequenlist; 顺序表的冒泡排序1234567891011121314151617void list_bubble_sort(sequenlist *p)//max to min&#123; int i,j; int temp; for(i=0; i&lt; p-&gt;last; i++)//attention &#123; for(j=0; j&lt; p-&gt;last-i; j++) &#123; if(p-&gt;data[j] &lt; p-&gt;data[j+1]) &#123; temp = p-&gt;data[j]; p-&gt;data[j] = p-&gt;data[j+1]; p-&gt;data[j+1] = temp; &#125; &#125; &#125; &#125; 顺序表的删除操作12345678910111213141516171819nt delete_1(sequenlist *s,int del) //删除函数 &#123; int temp; for(int i=0; i &lt;= s-&gt;last; i++) &#123; if(del == s-&gt;data[i]) &#123; temp = i; for(int j=i; j&lt;s-&gt;last; j++) &#123; s-&gt;data[j] = s-&gt;data[j+1]; &#125; s-&gt;last = s-&gt;last - 1; return 0;//删除第一个与del相同的元素，函数结束 &#125; &#125; //要删的那个元素不在表中 printf(\"the element you want to delete is not in the sequenlist!\\n\"); &#125; 顺序表中元素的查找12345678910111213int search(sequenlist *s,int key) //查找函数 &#123; for(int i=0; i&lt;= s-&gt;last; i++) &#123; if(key == s-&gt;data[i]) &#123; printf(\"exist !\\n\"); return 0; &#125; &#125; printf(\"not found !\\n\"); return 0;&#125; 顺序表的逆置12345678910111213void reverse(sequenlist *s)//逆置函数 &#123; int i,j; int temp; int last_temp = s-&gt;last; for(i=0; i&lt;= s-&gt;last/2; i++) &#123; temp = s-&gt;data[i]; s-&gt;data[i] = s-&gt;data[last_temp]; s-&gt;data[last_temp] = temp; last_temp--; &#125;&#125; 删除顺序表中的相同元素12345678910111213141516171819void delete_same(sequenlist *s)//删除表中相同的元素 &#123; int i,j; int temp; for(i=0; i&lt;=s-&gt;last; i++) &#123; for(j=1; j&lt;=s-&gt;last; j++) &#123; if(s-&gt;data[j] == s-&gt;data[i])//元素相同 &#123; for(int k=j; k&lt;s-&gt;last; k++) &#123; s-&gt;data[k] = s-&gt;data[k+1]; &#125; s-&gt;last = s-&gt;last - 1; &#125; &#125; &#125;&#125; 向顺序表的指定位置插入元素123456789101112131415161718192021222324252627int insert(sequenlist *L,int i,int x) //指定位置,插入 &#123; int j; if(((*L).last) &gt;= maxsize-1) &#123; printf(\"the list is overflow!\\n\"); return (0); &#125; else &#123; if((i&lt;1)||(i&gt;(*L).last+2)) &#123; printf(\"position is not correct!\\n\"); return (0); &#125; else &#123; for(j=(*L).last;j&gt;=i-1;j--) &#123; (*L).data[j+1]=(*L).data[j]; &#125; (*L).last=(*L).last+1; (*L).data[i-1]=x; return (0); &#125; &#125;&#125; 向顺序表的指定位置插入元素123456789101112131415161718192021222324252627int insert(sequenlist *L,int i,int x) //指定位置,插入 &#123; int j; if(((*L).last) &gt;= maxsize-1) &#123; printf(\"the list is overflow!\\n\"); return (0); &#125; else &#123; if((i&lt;1)||(i&gt;(*L).last+2)) &#123; printf(\"position is not correct!\\n\"); return (0); &#125; else &#123; for(j=(*L).last;j&gt;=i-1;j--) &#123; (*L).data[j+1]=(*L).data[j]; &#125; (*L).last=(*L).last+1; (*L).data[i-1]=x; return (0); &#125; &#125;&#125; 打印顺序表12345678void print_list(sequenlist *s) //打印顺序表 &#123; int i; for(i=0; i&lt;=s-&gt;last; i++) &#123; printf(\"%3d\",s-&gt;data[i]); &#125; &#125; 试着煲下汤123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247/** author: shansan.top* date: 2018/12/12* version: 1.0 */#include&lt;stdio.h&gt;#define maxsize 100//定义顺序表数据类型 typedef struct&#123; int data[maxsize]; int last;&#125;sequenlist;int search(sequenlist *s,int key) //查找函数 &#123; for(int i=0; i&lt;= s-&gt;last; i++) &#123; if(key == s-&gt;data[i]) &#123; printf(\"exist !\\n\"); return 0; &#125; &#125; printf(\"not found !\\n\"); return 0;&#125;int delete_1(sequenlist *s,int del) //删除函数 &#123; int temp; for(int i=0; i &lt;= s-&gt;last; i++) &#123; if(del == s-&gt;data[i]) &#123; temp = i; for(int j=i; j&lt;s-&gt;last; j++) &#123; s-&gt;data[j] = s-&gt;data[j+1]; &#125; s-&gt;last = s-&gt;last - 1; return 0;//删除第一个与del相同的元素，函数结束 &#125; &#125; //要删的那个元素不在表中 printf(\"the element you want to delete is not in the sequenlist!\\n\"); &#125; void print_list(sequenlist *s) //打印顺序表 &#123; int i; for(i=0; i&lt;=s-&gt;last; i++) &#123; printf(\"%3d\",s-&gt;data[i]); &#125; &#125;void reverse(sequenlist *s)//逆置函数 &#123; int i,j; int temp; int last_temp = s-&gt;last; for(i=0; i&lt;= s-&gt;last/2; i++) &#123; temp = s-&gt;data[i]; s-&gt;data[i] = s-&gt;data[last_temp]; s-&gt;data[last_temp] = temp; last_temp--; &#125;&#125;void list_bubble_sort(sequenlist *p)//max to min&#123; int i,j; int temp; for(i=0; i&lt; p-&gt;last; i++)//attention &#123; for(j=0; j&lt; p-&gt;last-i; j++) &#123; if(p-&gt;data[j] &lt; p-&gt;data[j+1]) &#123; temp = p-&gt;data[j]; p-&gt;data[j] = p-&gt;data[j+1]; p-&gt;data[j+1] = temp; &#125; &#125; &#125; &#125;void insert_in_order_list(sequenlist *s,int value)//有序表中插入元素 &#123; int i,j; int count=0; //int temp = s-&gt;last+1; for(i=0; i&lt;=s-&gt;last; i++) &#123; count++; if( value &lt;= s-&gt;data[i]) &#123; s-&gt;last = s-&gt;last + 1; for(j=s-&gt;last; j&gt;i; j--) &#123; s-&gt;data[j] = s-&gt;data[j-1]; &#125; s-&gt;data[i] = value; return ;//结束函数 &#125; &#125; //printf(\"i=%d\",i); //printf(\"s-&gt;last=%d\\n\",s-&gt;last); if(i &gt; s-&gt;last-1) &#123; s-&gt;last = s-&gt;last + 1; s-&gt;data[s-&gt;last] = value; &#125;&#125;int insert(sequenlist *L,int i,int x) //指定位置,插入 &#123; int j; if(((*L).last) &gt;= maxsize-1) &#123; printf(\"the list is overflow!\\n\"); return (0); &#125; else &#123; if((i&lt;1)||(i&gt;(*L).last+2)) &#123; printf(\"position is not correct!\\n\"); return (0); &#125; else &#123; for(j=(*L).last;j&gt;=i-1;j--) &#123; (*L).data[j+1]=(*L).data[j]; &#125; (*L).last=(*L).last+1; (*L).data[i-1]=x; return (0); &#125; &#125;&#125;void delete_same(sequenlist *s)//删除表中相同的元素 &#123; int i,j; int temp; for(i=0; i&lt;=s-&gt;last; i++) &#123; for(j=1; j&lt;=s-&gt;last; j++) &#123; if(s-&gt;data[j] == s-&gt;data[i])//元素相同 &#123; for(int k=j; k&lt;s-&gt;last; k++) &#123; s-&gt;data[k] = s-&gt;data[k+1]; &#125; s-&gt;last = s-&gt;last - 1; &#125; &#125; &#125;&#125;int main()&#123; sequenlist p=&#123;&#123;1,3,2,6,5,4,9,7,8&#125;,8&#125;; //这里有9个数，但数组下表是从0开始的，所以 p.last = 8 print_list(&amp;p); printf(\"\\n\"); //查找 printf(\"please input a value which you want: \"); int value;//C++语法可以临时定义一个变量,C语言不可以（需放在开头）。 scanf(\"%d\",&amp;value); //search(&amp;p,10); search(&amp;p,value); print_list(&amp;p); printf(\"\\n\\n\"); //删除表中的指定元素 delete_1(&amp;p,8); printf(\"after delete:\\n\"); print_list(&amp;p); //逆置顺序表 printf(\"\\n\\nafter reverse:\\n\"); reverse(&amp;p); print_list(&amp;p); //冒泡排序 printf(\"\\nafter sort:\\n\"); printf(\"\\n\"); //list_bubble_sort(&amp;try_1); list_bubble_sort(&amp;p); print_list(&amp;p); //往有序顺序表中插入一个元素 printf(\"\\n\\n\"); sequenlist try_1 = &#123;&#123;1,2,3,5,6,7&#125;,5&#125;; print_list(&amp;try_1); printf(\"\\n\"); printf(\"please input the value that you wan to insert into the sequenlist: \"); int data; scanf(\"%d\",&amp;data); insert_in_order_list(&amp;try_1,data); //insert_in_order_list(&amp;try_1,9); print_list(&amp;try_1); //删除表中相同的元素 printf(\"\\n\\n\"); sequenlist try_2= &#123;&#123;1,1,2,2,3,3,4,4&#125;,7&#125;; print_list(&amp;try_2); printf(\"\\ndelete the same element:\\n\"); delete_same(&amp;try_2); print_list(&amp;try_2); printf(\"\\n\"); //另一种玩法 int n; int i; printf(\"\\nplease input the number of elements: \"); scanf(\"%d\",&amp;n); printf(\"please input %d values:\\n\",n); sequenlist try_3; try_3.last = n-1;//注意，数组的小标从0开始 for(i=0; i&lt;=try_3.last; i++) &#123; scanf(\"%d\",&amp;try_3.data[i]); &#125; print_list(&amp;try_3); printf(\"\\n\\n\"); //在指定位置插入 insert(&amp;try_3,1,22); print_list(&amp;try_3); return 0; &#125; 程序运行结果","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://yeshan333.github.io/categories/数据结构/"}],"tags":[{"name":"C","slug":"C","permalink":"https://yeshan333.github.io/tags/C/"},{"name":"数据结构","slug":"数据结构","permalink":"https://yeshan333.github.io/tags/数据结构/"}]},{"title":"勿忘国耻，吾辈自强！","slug":"勿忘国耻，吾辈自强！","date":"2018-12-12T16:17:58.000Z","updated":"2019-12-13T04:21:32.189Z","comments":true,"path":"2018/12/13/勿忘国耻，吾辈自强！/","link":"","permalink":"https://yeshan333.github.io/2018/12/13/勿忘国耻，吾辈自强！/","excerpt":"","text":"","categories":[{"name":"Memory","slug":"Memory","permalink":"https://yeshan333.github.io/categories/Memory/"}],"tags":[{"name":"Memory","slug":"Memory","permalink":"https://yeshan333.github.io/tags/Memory/"}]},{"title":"Biu一下GDB","slug":"biu一下GDB","date":"2018-12-03T15:51:52.000Z","updated":"2019-03-21T18:00:15.791Z","comments":true,"path":"2018/12/03/biu一下GDB/","link":"","permalink":"https://yeshan333.github.io/2018/12/03/biu一下GDB/","excerpt":"gcc常见编译选项 -c :只激活预处理、编译和汇编，也就是生成obj文件 -S :只激活处理和编译，把文件编译成汇编代码 -o :定制目标名称，缺省的时候编译出来的可执行程序名为a.exe(windows)或a.out(linux) -Wall :打开一些很有用的编译警告 -std :指定C标准，如-std=99，使用C99标准 -g :指示编译器，编译的时候添加调试信息 -O0 -O1 -O2 -O3 ：编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高","text":"gcc常见编译选项 -c :只激活预处理、编译和汇编，也就是生成obj文件 -S :只激活处理和编译，把文件编译成汇编代码 -o :定制目标名称，缺省的时候编译出来的可执行程序名为a.exe(windows)或a.out(linux) -Wall :打开一些很有用的编译警告 -std :指定C标准，如-std=99，使用C99标准 -g :指示编译器，编译的时候添加调试信息 -O0 -O1 -O2 -O3 ：编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高 1234567891011121314151617181920/*file_name: swap.c*/ #include&lt;stdio.h&gt;void swap(int a, int b)&#123; int t; t = a; a = b; b = t;&#125;int main()&#123; int a=3, b=4; swap(a,b); printf(\"%d %d\",a,b); return 0; &#125; GDB的使用 什么是GDBhttps://www.bing.com/knows/search?q=gdb&amp;mkt=zh-cn&amp;FORM=BKACAIhttp://www.gnu.org/software/gdb/ 一般来说，GDB主要帮助你完成以下四个方面的内容1、启动你的程序，可以按照你的自定义的要求随心所欲的运行程序2、可以让被调试的程序在你所指定的调置的断点处停住。(断点可以是条件表达式)3、当程序被停住时，可以检查此时你的程序中所发生的事4、你可以改变你的程序，将一个BUG产生的影响修正，从而测试其他BUG GDB常见命令 简称 全称 备注 l list 显示指定行号或者指定函数附近的源代码 b break 在指定行号或指定函数开头设置断点 r run 运行程序，直到程序结束或遇到断点 c continue 在程序中断后继续执行程序，直到程序结束或遇到断点停下。注意在程序开始执行前只能用r，而不能用c n next 执行一条语句。如果有函数调用，则把它当做一个整体 s step 执行一条语句。如果有函数调用，则进入函数内部 u until 执行到指定行号或指定函数的开头 p print 显示变量或表达式的值 disp display 把一个表达式设置为display，当程序每次停下来时都会显示其值 cl clear 取消断点，和b格式相同，如果该位置有多个断点，将同时取消 i info 显示各种信息，如i b显示所有断点，i disp显示display，而i lo显示所有局部变量 bt backtrace 打印所有栈帧信息 调用栈（Call Stack）调用栈描述的是函数之间的调用关系。调用栈由栈帧（Stack Frame）组成，每个栈帧对应着一个未运行完的函数。在GDB中可以用backtrace（简称bt）命令打印所有栈帧信息。若要用p命令打印一个非当前栈帧的局部变量，可以用frame命令选择另一个栈帧 拿个程序来玩玩,swap.c文件1234567891011#include&lt;stdio.h&gt;void swap(int a, int b)&#123; int t;t = a;a = b;b = t;&#125;int main()&#123; int a=3, b=4; swap(a,b); printf(\"%d %d\",a,b); return 0; &#125; 程序的目的是交换a和b的值，然而并没有交换交换成功 原因： 函数的形参和在函数内部声明的变量都是该函数的局部变量。无法访问其他函数的局部变量。 局部变量的存储空间是临时分配的，函数执行完毕时，局部变量的空间将被释放，其中的值无法保留到下次使用。 如果要实现真正的交换，我们应该传入的是存储变量的地址，此时函数swap的形参类型应该为指针类型 PS:C语言的变量都是放在内存中的，而内存中间的每一个字节都有一个称为地址(address)的编号。每一个变量都占有一定数目的字节（可以用sizeof运算符获得），其中第一个字节的地址称为变量的地址。 o(*≧▽≦)ツ┏━┓拿个递归程序来玩玩12345678910#include&lt;stdio.h&gt;int f(int n)&#123; return n == 0 ? 1 : f(n-1)*n;&#125;int main()&#123; printf(\"%d\\n\",f(3)); return 0;&#125; 在C语言的函数中，调用自己和调用其他函数没有任何本质区别，都是建立新栈帧，传递参数并修改当前代码行。在函数执行体完毕后删除栈帧，处理返回值，并修改当前代码行数。 以上调用栈的一个比喻 皇帝（拥有main函数的栈帧）：大臣，你给我算下f(3)大臣（拥有f(3)的栈帧）：知府，你给我算下f(2)知府（拥有f(2)的栈帧）：县令，你给我算下f(1)县令（拥有f(1)的栈帧）：师爷，你给我算下f(0)师爷（拥有f(0)的栈帧）：回老爷，f(0)=1县令（心算f(1)=f(0)1=1）：回知府大人，f(1)=1知府（心算f(2)=f(1)2=2）：回大人，f(2)=2大臣（心算f(3)=f(2)*3=6）：回皇上，f(3)=6皇上满意了 emmmmmm。。。。。。。。。。。。","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"GDB","slug":"GDB","permalink":"https://yeshan333.github.io/tags/GDB/"}]},{"title":"标准库容器","slug":"标准库容器","date":"2018-12-01T09:45:46.000Z","updated":"2019-06-27T13:32:24.819Z","comments":true,"path":"2018/12/01/标准库容器/","link":"","permalink":"https://yeshan333.github.io/2018/12/01/标准库容器/","excerpt":"","text":"标准库容器是模板类型，用来保存给定类型的对象。一个容器就是一些特定类型对象的集合。 顺序容器 顺序容器我们提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置对应。 一般来说，每个容器都定义在一个都文件中 顺序元素几乎可以保存任意类型的元素 顺序容器类型 说明 vector 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢 array 固定大小数组，支持快速随机访问，不能添加或删除元素 string 与vector相似的容器，但专门用于保存字符。随机访问块。在尾部插入或删除快 deque 双端队列。支持快速随机访问。在头尾位置插入或删除速度很快 list 双向链表。只支持双向顺序访问，在list中任何位置进行插入或删除操作的速度都很快 forward_list 单向链表。只支持单向顺序访问，在链表的任何位置进行插入或删除操作的速度都很快 forward_list、array是新C++标准增加的类型与内置数组相比，array是一种更安全、更容易使用的数组类型。array对象的大小不是固定的，因此，他支持插入和删除元素以及改变容器大小的操作 容器类型成员每个容器都定义了多个类型 类型别名 说明 iterator 容器的迭代器类型成员 const_iterator 可以读取元素，但不能修改元素的迭代器类型 size_type 无符号整数类型，足够保存此种容器类型最大可能容器的大小 differrnce_type 带符号整数类型，足够保存两个迭代器之间的距离 value_type 元素类型 reference_type 元素左值类型，与value_type&amp;含义相同 const_reference 元素的const左值类型，(即const value_type&amp;) 通过类型别名，我们可以在不了解容器中元素类型的情况下使用它 为了使用这些类型，我们必须显示的使用其类型名 vector::iterator iter;//iter是通过vector定义的迭代器类型 容器的begin成员和end成员begin成员生成一个指向容器中第一个元素位置的迭代器end成员生成指向尾元素之后的位置的迭代器 容器定义和初始化 每个容器都定义了一个默认的构造函数。容器的默认的构造函数都会创建一个指定类型的空容器，他们都可以接受指定容器大小和元素初始值的参数 由于array是固定大小的数组。定义一个array时，除了制定元素类型外，还要指定容器的大小 创建一个容器为另一个容器的拷贝时，两个容器的类型以及元素的类型必须相同 当传递迭代器参数来拷贝一个范围时，不要求容器的类型必须相同，且新容器和原容器的元素类型也可以不同，只要能将要拷贝的元素的类型转换为要初始化的容器的元素类型即可 定义&amp;初始化方式 说明 C a 默认构造函数，如果C是一个array，则a中元素按默认方式初始化，否则a为空 C a(b)C a=b a初始化为b的拷贝。a和b必须是相同的类型(它们必须是相同的容器类型，且保存的是相同的元素类型)，对于array我们还要定义它的大小 C a{b,c,d,e,f,…}C a={b,c,d,e,f,…} a初始化为初始化列表中元素的拷贝。列表中的元素类型必须与a的元素类型相容。对于array来说，列表元素的数目必须小于或等于array的大小，任何遗漏的元素直接进行值初始化 C a(b_iterator,c_iterator) a初始化为迭代器b_iterator和c_iterator指定范围中元素的拷贝，范围中元素的类型必须与a的元素类型相容 C a(n) a包含n个元素，这些元素进行了值初始化，此构造函数explicit的，string和array不适用 C a(n,value) a包含n个初始化为值value的元素 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;list&gt;#include&lt;forward_list&gt;using namespace std;int main()&#123; list&lt;string&gt; svec(10,\"shan\"); for(auto i:svec) &#123; cout&lt;&lt;i&lt;&lt;endl; &#125; //vector&lt;string&gt; vec = svec;//#错误，容器类型不匹配 forward_list&lt;string&gt; fvec(svec.begin(),svec.end());//使用迭代器范围进行拷贝初始化 for(auto temp:fvec) &#123; cout&lt;&lt;temp&lt;&lt;endl; &#125; return 0;&#125; 标准库array的使用 定义一个array时，我们要指定元素的类型，还要指定容器的大小 由于大小是array类型的一部分，array不支持不同容器类型的构造函数 对array进行列表初始化的时候，初始值的数目必须等于或小于array的大小 array要求初始值的类型必须要与创建的容器类型相一致 虽然我们不能对内置的数组进行拷贝或对象赋值操作，但是array并无此限制 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;array&gt; using namespace std;int main()&#123; array&lt;int ,10&gt; num_1;//定义了一个保存10个int的数组 for(auto i:num_1) cout&lt;&lt;i&lt;&lt;\" \"; cout&lt;&lt;endl; array&lt;int ,10&gt; num_2=&#123;1,2,3,4,5,6,7,8,9,10&#125;; for(auto i:num_2) cout&lt;&lt;i&lt;&lt;\" \"; cout&lt;&lt;endl; int d[5]=&#123;3,6,9,12,15&#125;; //int b[5]=d; 这是错误的，内置数组不支持拷贝和赋值 array&lt;int ,6&gt; try_1=&#123;4,5,6,7,8,9&#125;; array&lt;int ,6&gt; try_2=try_1; for(auto temp:try_2) cout&lt;&lt;temp&lt;&lt;\" \"; return 0;&#125; 容器操作swap和assign a.swap(b):用于交换两个容器中的元素，两个容器必须具有相同的类型 swap(a,b):用于交换两个相同类型的容器中的元素 a.assign(1_iterator,2_iterator):将a中的元素替换为迭代器1_iterator和2_iterator范围中的元素，迭代器不能指向a中的元素 a.assign(value_list): 将a中的元素初始化为初始化列表value_list中的元素 a.assign(n,value):将a中的元素替换为n个值为value的元素 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; a=&#123;1,2,3,4,5,6&#125;; vector&lt;int&gt; b; b.assign(&#123;6,7,8,9,10,11&#125;); cout&lt;&lt;endl; for(auto temp:b) cout&lt;&lt;temp&lt;&lt;\" \"; cout&lt;&lt;endl; b.assign(a.begin(),a.end()); for(auto temp:b) cout&lt;&lt;temp&lt;&lt;\" \"; cout&lt;&lt;endl; /* * swap操作交换两个相同类型容器的内容 * assing操作用参数所指定的元素(即拷贝)替换左边容器中的所有元素。 * assign允许我们从不同但相容的类型赋值，或者从一个容器的子序列赋值 * 除了string外，指向容器的迭代器、引用和指针在swap操作后都不会失效 */ vector&lt;int&gt; temp=&#123;11,22,33,44,55,66,77,88&#125;; b.swap(temp); cout&lt;&lt;\"temp: \"; cout&lt;&lt;\"size-\"&lt;&lt;temp.size()&lt;&lt;\" \"; for(auto i=temp.begin();i != temp.end();i++) cout&lt;&lt;*i&lt;&lt;\" \"; cout&lt;&lt;endl; cout&lt;&lt;endl; cout&lt;&lt;\"b: \"; cout&lt;&lt;\"size-\"&lt;&lt;b.size()&lt;&lt;\" \"; for(auto j=b.begin();j != b.end();j++) cout&lt;&lt;*j&lt;&lt;\" \"; return 0; &#125; 向容器中添加元素（array不支持这些操作） &ensp; 说明 C.push_back(t)C.emplace_back(args) 在C的尾部创建一个值为t或由args创建的元素。返回void类型 C.push_front(t)C.emplace_front(args) 在C的头部创建一个值为t或由args创建的元素，返回指向新添加的元素的迭代器 C.insert(p_iterator,t)C.emplace(p_iterator,args) 在迭代器p_iterator之前插入一个值为t或由args创建的元素，返回指向新添加的元素的迭代器 C.insert(p_iterator,n,t) 在迭代器p_iterator指向的元素之前插入n个值为t的元素，返回指向新插入的第一个元素的迭代器，若n为0，则返回p_iterator C.insert(p_iterator,a_iterator,b_iterator) 将迭代器a_iterator和b_iterator指定的范围内的元素插入到迭代器p_iterator指向的元素之前，迭代器范围不能指向C中的元素。返回指向第一个新添加的元素的迭代器，若范围为空，则返回p_iterator C.insert(p_iterator,li) 将由花括号括起来的元素值列表li插入待迭代器p_iterator所指的元素之前。返回新添加的第一个元素的迭代器，若列表为空，则返回p_iterator 向一个vector、string或deque中插入元素会使所有指向容器的迭代器、引用和指针失效 记住，insert函数将元素插入到迭代器所指定的位置之前 当我们用一个对象来初始化容器时，或将一个对象插入到容器中的时，实际上放入到容器中的是对象的值的拷贝，而不是对象本身 vector、list、deque、string都支持insert成员，forward_list提供了特殊版本的insert成员 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;list&gt;using namespace std;void operated_1()&#123; vector&lt;string&gt; ss&#123;\"shansan\",\"wocao\",\"yeshan\"&#125;; vector&lt;string&gt; v; for(auto i:ss) v.push_back(i); for(auto temp:v) cout&lt;&lt;temp&lt;&lt;\" \"; &#125;void operated_2()&#123; list&lt;int&gt; ls; for(int num=3;num&gt;=0;num--) ls.push_front(num); for(int i=5;i&lt;8;i++) ls.push_back(i); for(auto i=ls.begin();i != ls.end(); i++) cout&lt;&lt;*i&lt;&lt;\" \";&#125;void operated_3()&#123; vector&lt;int&gt; v_1&#123;1,2,3,4,5&#125;; vector&lt;int&gt; v_2&#123;6,7,8,9,10&#125;; v_1.insert(v_1.begin(),66);//在迭代器v_1.begin()所指的元素之前插入一个元素66 for(auto temp: v_1) cout&lt;&lt;temp&lt;&lt;\" \"; cout&lt;&lt;endl; v_1.insert(v_1.begin(),v_2.begin(),v_2.end()); //在迭代器v_1.begin()所指的元素之前，插入迭代器v_2.begin()到v_2.end()指顶范围内的元素 for(auto temp:v_1) cout&lt;&lt;temp&lt;&lt;\" \"; &#125; int main()&#123; operated_1(); cout&lt;&lt;endl; operated_2(); cout&lt;&lt;endl; operated_3(); return 0;&#125; emplace操作 当调用一个insert或push成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中当调用一个emplace函数时，则是将参数传递给元素类型的构造函数。emplace成员直接使用这些参数在容器管理的内存空间中直接构造函数 emplace函数在容器中直接构造函数。传递给emplace函数的参数必须与元素类型的构造函数相匹配 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class student&#123; public: student(string str,int a):name(str),age(a)&#123;&#125; void print_1() &#123; cout&lt;&lt;\"name: \"&lt;&lt;this-&gt;name&lt;&lt;\",\"&lt;&lt;\"Age: \"&lt;&lt;this-&gt;age&lt;&lt;endl; &#125; private: int age; string name;&#125;;int main()&#123; vector&lt;student&gt; s;//我们将student存到了vector中 s.emplace_back(\"shansan\",18);//使用student对象的构造函数 auto temp=s.begin(); (*temp).print_1(); cout&lt;&lt;endl; //s.push_back(\"try\",66);//error：没有接受两个参数的push_back版本 s.push_back(student(\"try\",66));//创建一个临时的student对象传递给push_back for(auto i:s) i.print_1(); return 0; &#125; 访问容器中的元素 访问操作 说明 c.back() 返回c中尾元素的引用。若c为空，函数行为未定义 c.front() 返回c中首元素的引用。若c为空，函数行为未定义 c[n] 返回c中下标为n的元素的引用，n是一个无符号整数。若n&gt;=c.size()，则函数行为未定义 c.at(n) 返回下标为n的元素的引用。如果下标越界，则抛出一个out_of_range异常 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; /* * 不要对一个空的容器使用front和back操作 * at和下标操作只适用于string、vector、deque和array * back不适用于forward_list */ vector&lt;int&gt; v&#123;1,6&#125;; int a = v.front(); a=33; cout&lt;&lt;\"v[0]=\"&lt;&lt;v[0]&lt;&lt;endl; int &amp;refer = v.front(); refer =33;//改变了v[0]的值 cout&lt;&lt;\"v[0]=\"&lt;&lt;v[0]; return 0;&#125; 由于访问成员函数的返回值是引用类型，如果是非const的，我们可以使用它来改变元素的值 删除容器中的元素 删除操纵 说明 c.pop_back() 删除c的尾元素，如果c是空的，则函数行为未定义。函数返回void c.pop_front() 删除c的首元素，如果c是空的，则函数行为未定义。函数返回void c.erase(p_iterator) 删除迭代器p_iterator所指定的元素，返回一个指向被删除的元素之后元素的迭代器，若p_iterator指向尾元素，则返回尾后迭代器，若p_iterator是尾后迭代器，则函数行为未定义 c.erase(a_iterator,b_iterator) 删除迭代器a_iterator和b_iterator所指定范围内的元素，返回一个指向最后一个被删元素之后元素的迭代器，若b_iterator本身就是尾后迭代器，则返回尾后迭代器 c.clear() 删除c中所有的元素 删除deque中除首尾位置之外的任何元素都会使迭代器、引用和指针失效。指向vector或string中删除点位置之后的迭代器、引用和指针都会失效 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;list&gt;using namespace std;int main()&#123; vector&lt;string&gt; str&#123;\"shansan\",\"wocao\",\"555\"&#125;; for(auto temp:str) cout&lt;&lt;temp&lt;&lt;\" \"; str.pop_back(); cout&lt;&lt;endl; for(auto temp:str) cout&lt;&lt;temp&lt;&lt;\" \"; cout&lt;&lt;endl; str.erase(str.begin(),str.end()); for(auto temp:str) cout&lt;&lt;temp&lt;&lt;\" \"; list&lt;int&gt; lst=&#123;0,1,2,3,4,5,6,7,8,9,10&#125;; auto it = lst.begin(); while(it != lst.end()) &#123; if(*it%2) it = lst.erase(it);//删除奇数元素,返回指向被删除元素的下一个元素的迭代器 else it++; &#125; for(auto temp:lst) cout&lt;&lt;temp&lt;&lt;\" \"; return 0; &#125; 改变容器大小 c.resize(n):调整c的大小为n个元素。若n&lt;c.size()，则多出的元素被丢弃；若必须添加新元素，对新元素进行值初始化 c.resize(n,t):调整c的大小为n个元素，任何新添加的元素都初始化为值t 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;deque&gt;using namespace std;int main()&#123; vector&lt;int&gt; v&#123;22,33,3&#125;; cout&lt;&lt;\"v capacity:\"&lt;&lt;v.capacity()&lt;&lt;endl; v.resize(6,1); cout&lt;&lt;\"v size:\"&lt;&lt;v.size()&lt;&lt;endl; cout&lt;&lt;\"v capacity:\"&lt;&lt;v.capacity()&lt;&lt;endl; for(auto i:v) cout&lt;&lt;i&lt;&lt;\" \"; /* - 使用reserve操作通知容器应该为我们预留多少空间 - resize成员函数只改变容器中成员函数的数目，不改变容器的容量 - 容器的size操作指的是它已经保存的元素的数目 - capacity则是在不不分配新的内存空间的前提下知道它最多可以保存多少个元素 */ v.reserve(100); cout&lt;&lt;endl&lt;&lt;\"v capacity:\"&lt;&lt;v.capacity()&lt;&lt;endl; cout&lt;&lt;\"v size:\"&lt;&lt;v.size()&lt;&lt;endl; return 0; &#125;","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"Keep on moving ！","slug":"Keep-on-moving-！","date":"2018-11-26T16:35:22.000Z","updated":"2018-11-26T16:39:28.007Z","comments":true,"path":"2018/11/27/Keep-on-moving-！/","link":"","permalink":"https://yeshan333.github.io/2018/11/27/Keep-on-moving-！/","excerpt":"","text":"比赛终于完了！又可以安心打代码看书了emmmmmmm","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://yeshan333.github.io/tags/随笔/"}]},{"title":"再探函数","slug":"再探函数","date":"2018-11-21T16:16:21.000Z","updated":"2018-11-23T19:21:29.274Z","comments":true,"path":"2018/11/22/再探函数/","link":"","permalink":"https://yeshan333.github.io/2018/11/22/再探函数/","excerpt":"main:处理命令行//main函数的两种定义形式 int main(int argc,char **argv[]) int main(int argc,char *argv[]) argc:指的是命令行中输入参数的个数 argv:一个数组，它存储了所有的命令行参数","text":"main:处理命令行//main函数的两种定义形式 int main(int argc,char **argv[]) int main(int argc,char *argv[]) argc:指的是命令行中输入参数的个数 argv:一个数组，它存储了所有的命令行参数 参数使用示例子: 1234567891011121314//file_name:test.cpp //author:shansan#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main(int argc,char **argv) &#123; int i; for(i=0;i&lt;argc;i++) &#123; printf(\"argv[%d]=%s\\n\",i,argv[i]); &#125; return 0;&#125; 含有可变形参的函数initializer_list形参 initializer_list是一种标准库类型，用于表示某种特定类型的值的数组 initializer_list也是一种模板类型 支持size(),begin(),end()等操作 向initializer_list形参中传递一个值的序列，则必须把序列放在花括号中 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;void print_1(initializer_list&lt;string&gt; str)&#123; //遍历实参表列,使用initializer_list对象的成员begin和end进行遍历 cout&lt;&lt;\"parameter nums: \"&lt;&lt;str.size()&lt;&lt;endl; for(auto temp = str.begin();temp != str.end(); ++temp) &#123; cout&lt;&lt;*temp&lt;&lt;endl; &#125; cout&lt;&lt;endl; //用范围for语句遍历表列 for(auto beg : str) &#123; cout&lt;&lt;beg&lt;&lt;endl; &#125; &#125;int main()&#123; const string a = \"shansan\"; string b = \"yeshan333\"; string c = \"wocao\"; //向initializer_list形参中传递一个值的序列需放在花括号内部 print_1(&#123;a,b,c&#125;); return 0; &#125; 函数返回值——-列表初始化返回值 函数可以返回花括号包围的值的列表 如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间 如果函数返回的是类类型，由类本身定义初始值如何使用 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;string&gt; process()&#123; return &#123;\"shansan\",\"yeshan333\"&#125;;&#125;int main()&#123; vector&lt;string&gt; v; v = process(); //遍历vector对象 for(auto temp : v) &#123; cout&lt;&lt;temp&lt;&lt;endl; &#125; return 0;&#125; 调试帮助，预定义跟踪调试编译器为我们定义的 func:存放当前调试函数的名字 FILE:存放文件名的字符串字面值常量 LINE:存放文件当前行号的整型字面值 TIME:存放文件编译时间的字符串字面值常量 DATE:存放文件编译日期的字符串字面值常量","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"IO类型","slug":"IO类型","date":"2018-11-21T16:13:54.000Z","updated":"2018-11-23T19:19:47.297Z","comments":true,"path":"2018/11/22/IO类型/","link":"","permalink":"https://yeshan333.github.io/2018/11/22/IO类型/","excerpt":"IO库 IO库设施: istream类型:提供输入操作 ostream类型:提供输出操作 cin:一个istream对象，从标准输入读取数据 cout:一个ostream对象，从标准输出写入数据 cerr:一个ostream对象，通常用于输出程序错误信息，写入到标准错误 &gt;&gt;运算符:用来从一个istream对象读取输入数据 &lt;&lt;运算符:用来向一个ostream对象写入数据 getline函数:从一个给定的istream读取一行数据，存入一个给定的string对象中","text":"IO库 IO库设施: istream类型:提供输入操作 ostream类型:提供输出操作 cin:一个istream对象，从标准输入读取数据 cout:一个ostream对象，从标准输出写入数据 cerr:一个ostream对象，通常用于输出程序错误信息，写入到标准错误 &gt;&gt;运算符:用来从一个istream对象读取输入数据 &lt;&lt;运算符:用来向一个ostream对象写入数据 getline函数:从一个给定的istream读取一行数据，存入一个给定的string对象中 IO类 头文件 IO库类型 iostream istream,wistream从流读取数据ostream,wostream向流写入数据iostream,wiostream读写流 fstream ifstream,wistream从文件读取数据ofstream,wofstream向文件写入数据fstream,wfstream读写文件 sstream istringstream,wistringstream从string读取数据ostringstream,wostringstream向string写入数据stringstream,wstringstream读写string IO对象没有拷贝或赋值 定义函数时不能将形参设置为流类型 进行IO操作的函数通常使用引用方式传递和返回流 因为读写一个IO对象会改变其状态，因此传递和返回的引用不能是const类型的 一个流一旦发生错误，其后续的IO操作都会失败 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;istream&amp; read_print(istream &amp;s)&#123; int score; while(s&gt;&gt;score) &#123; cout&lt;&lt;score&lt;&lt;endl; &#125; s.clear();//流复位，清楚所有错误标志位 return s;&#125;int main()&#123; read_print(cin); cout&lt;&lt;\"shansan\"; return 0;&#125; 输出缓冲管理cout&lt;&lt;&quot;shansan&quot; 文本串可能立即打印出来，但也有可能被操作系统保存在操作系统的缓冲区中，随后再打印。缓冲机制的存在可以让操作系统将程序的多个输出操作组合成单一的系统级写操作由于设备写操作可能很耗时间，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的便利 使用操纵符刷新缓冲区 endl:完成换行机制并且刷新缓冲区 ends:仅刷新缓冲区 flush:仅刷新缓冲区 程序崩溃，输出缓冲区不会刷新 文件IOhttps://shansan.top/2018/10/22/%E5%9D%91%E4%BA%BA%E7%9A%84C++-2/#%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6-amp-amp-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6头文件定义了三个文件类型来支持文件IO ifstream:从文件读取数据 ofstream:向文件写入数据 fstream:读和写操作都能进行 每一个文件流对象都定义了一个名为open的成员函数，它完成了一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式一旦一个文件流已经打开，它就保持与对应文件的关联。对一个已经打开的文件流调用open会失败，并会导致failbit被置位，随后试图使用文件流的操作都会失败 ** ifstream、ofstream、fstream对象上的操作，以下操作都适用 操作 说明 fstream file 创建一个未绑定的文件流 fstream file(file_name) 创建一个fstream对象，并打开名字为file_name的文件。file_name可以是一个指向C风格的字符串，也可以是一个string类型 fstream file(file_name,mode) mode为指定的打开模式 fstream.close() 关闭与fstream绑定的文件 fstream.is_open() 返回一个bool值，指出与fstream关联的文件是否成功被打开且尚未被关闭 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;vector&gt; using namespace std;void write()&#123; ofstream file; file.open(\"shansan.txt\"); //等价于fstream file(\"shanshan.txt\"); //像文件写入数据 file&lt;&lt;\"shansan\"&lt;&lt;endl; file&lt;&lt;\"shansan.top\"&lt;&lt;endl; file&lt;&lt;\"yeshan333.github.io\"&lt;&lt;endl; file.close();&#125;void read_print()&#123; string buffer; ifstream read_file(\"shansan.txt\"); vector&lt;string&gt; v; while(getline(read_file,buffer))//每次从read_file读取一行给buffer v.push_back(buffer);//将buffer存到vector对象v中 for(auto temp:v) cout&lt;&lt;temp&lt;&lt;endl; &#125; int main()&#123; write(); read_print(); return 0;&#125; 文件模式每一个流都有一个关联的文件模式，用来指出如何使用文件。每一个文件流都定义了一个默认的文件模式 与ifstream关联的文件默认以in模式打开 与ofstream关联的文件默认以out模式打开 与fstream关联的文件默认以in和out模式打开 文件模式 说明 in 以读方式打开文件 out 以写方式打开文件 app 每次写操作前均定位到文件末尾 ate 打开文件后立即定位到文件末尾 trunc 截断文件 binary 以二进制方式进行IO","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"排序算法","slug":"排序算法","date":"2018-11-19T16:35:20.000Z","updated":"2018-12-18T03:59:49.357Z","comments":true,"path":"2018/11/20/排序算法/","link":"","permalink":"https://yeshan333.github.io/2018/11/20/排序算法/","excerpt":"排序算法插入排序直接插入排序基本思想:我们将一个待排序序列分为有序区和无序区（一般开始的时候将第一个元素作为有序区，剩下的元素作为无序区），每次将无序区的第一个元素作为待插入记录，按大小插入到前面已经排好的有序区中的适当位置，直到记录全部插入完成为止。(如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面)","text":"排序算法插入排序直接插入排序基本思想:我们将一个待排序序列分为有序区和无序区（一般开始的时候将第一个元素作为有序区，剩下的元素作为无序区），每次将无序区的第一个元素作为待插入记录，按大小插入到前面已经排好的有序区中的适当位置，直到记录全部插入完成为止。(如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面) C++实现 1234567891011121314151617void insert_sort_1(int a[],int n)//对n个元素从小到大排序&#123; int i,j; int temp; for(i=1;i&lt;n;i++) &#123; temp = a[i];//待插入元素 j = i-1; while(temp&lt;a[j] &amp;&amp; j) &#123; a[j+1] = a[j];//将大的往后挪 j--;//顺利的话可以减到-1，要么就是减到可以插入的位置的前一个位置 //所以后面的j需要加1 &#125; a[j+1]=temp; &#125;&#125; C++实现_2 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;void insert_sort_2(int a[],int n)//n个数,排的实际上是下标为1到n-1的元素,a[0]是监视哨 &#123; int i,j; //初始状态下a[1]为初始有序区 //a[2]到a[n-1]为无序区 for(i=2;i&lt;n;i++) &#123; a[0] = a[i];//设置监视哨 j = i-1; while(a[0]&lt;a[j])//将有序区中大于监视哨的元素往后挪，没有就不动 &#123; a[j+1] = a[j]; j--;//如果顺利可以减到0下标 &#125; a[j+1] = a[0]; &#125;&#125;int main()&#123; int temp[11]=&#123;0,10,9,8,7,6,5,4,3,2,1&#125;;//真正用于排序的只有10个数 insert_sort_2(temp,11); for(int i=1;i&lt;11;i++) &#123; cout&lt;&lt;temp[i]&lt;&lt;endl; &#125; return 0;&#125; 直接选择排序冒泡排序基本思想:我们把待排序元素序列竖直放置，每趟对相邻的元素进行两两比较，顺序相反则进行交换，每趟会将最小或最大的元素“浮”到元素序列的顶端，最终元素序列达到有序 C++实现 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;void bubble_sort(int array[],int n)//对n个数从小到大排序，注意数组下标从0开始 &#123; int i,j; int temp; for(i=0;i&lt;n-1;i++)//进行n-1趟比较 &#123; for(j=0;j&lt;n-1-i;j++)//每趟进行n-1-i次比较 &#123; if(array[j+1]&lt;array[j]) &#123; temp = array[j+1]; array[j+1] = array[j]; array[j] = temp; &#125; &#125; &#125;&#125;int main()&#123; int a[10] = &#123;10,9,7,8,6,5,4,2,3,1&#125;; bubble_sort(a,10); for(int i=0;i&lt;10;i++) &#123; cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125; return 0;&#125; 快速排序快速排序是分治思想在排序算法上的应用，从本质上来讲快速排序应该是在冒泡排序基础上的递归分治法。 算法步骤: 从待排数列中选出一个元素作为基准，一般选第一个元素 重新排序待排数列，所有元素比基准小的摆放在基准前面，所有元素比基准大的摆放在基准后面（相同的数可以放在任意一边）。在这个分区退出后，该基准就处于中间位置。（这个即为分区操作(partion)）。 递归地把小于基准元素的子数列和大于基准元素的子数列进行排序。 C实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;int a[101],n;void quick_sort(int left, int right)&#123; int i,j,temp; int t; if(left &gt; right) &#123; return ; &#125; temp = a[left];//基准数 i = left; j = right; while(i != j) &#123; //顺序很重要，先从右往左找 while( a[j] &gt;= temp &amp;&amp; i&lt;j) &#123; j--; &#125; //再从左边往右找 while( a[j] &lt;= temp &amp;&amp; i&lt;j) &#123; i++; &#125; //交换两个数在数组中的位置 if(i&lt;j)//两个哨兵没有相遇 &#123; t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125; //最终将基准数归位, a[left] = a[i]; a[i] = temp;//归位 quick_sort(left,i-1);//继续处理左边的数 quick_sort(i+1,right);//继续处理右边的数 return ; &#125;int main()&#123; int i,j; scanf(\"%d\",&amp;n); for(i=1; i&lt;=n; i++)//下表从1开始 scanf(\"%d\",&amp;a[i]); quick_sort(1,n);//sort for(j=1; j&lt;=n; j++) printf(\"%d \",a[j]); return 0;&#125; 参考: https://blog.csdn.net/adusts/article/details/80882649 https://github.com/hustcc/JS-Sorting-Algorithm","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://yeshan333.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://yeshan333.github.io/tags/Algorithm/"}]},{"title":"二分查找","slug":"二分查找","date":"2018-11-18T16:30:43.000Z","updated":"2019-03-23T09:13:14.560Z","comments":true,"path":"2018/11/19/二分查找/","link":"","permalink":"https://yeshan333.github.io/2018/11/19/二分查找/","excerpt":"","text":"二分查找算法百度百科算法效率O(log&lt;sub&gt;2&lt;/sub&gt;n)（对数时间）输入为一个有序的元素序列，如果要查找的元素包含在列表中，二分查找返回其位置，否则返回null 二分查找的基本思想是将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x,算法中止；如果x数组a的左半部分继续搜索x,如果x&gt;a[n/2],则只要在数组a的右半部搜索x. 仅当列表是有序的时候，二分查找才是有效的 python实现123456789101112131415161718192021222324252627282930# -*- coding: utf-8 -*-# binary_searchdef binary_search(list_1, item): low = 0 high = len(list_1)-1 while low &lt;= high: '''使用 // 整除运算符可以不用int进行类型转换''' #每次都检查中间的元素 mid = (low + high)/2 guess = list_1[int(mid)] if guess == item: return int(mid)#返回所在位置的索引 if guess &lt; item: #猜的数字小了，修改low low = mid+1 if guess &gt; item: #猜的数字大了，修改high high = mid-1 return Nonedef main(): list_2 = [1,2,3,4,5,6,7,8,9] print(binary_search(list_2, 8)) print(binary_search(list_2, 10))main() C++实现1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;int binary_search(int a[9],int n,int x)//n为元素个数 &#123; int mid; int high,low=0; int guess; high = n-1;//数组下标从0开始 while(low &lt;= high) &#123; mid = (high+low)/2; guess = a[mid]; if(guess == x) return mid; if(guess &gt; x) high = mid-1; if(guess &lt; x) low = mid+1; &#125; return -1;&#125;int main()&#123; int temp; int a[9] = &#123;1,2,3,4,5,6,7,8,9&#125;; cout&lt;&lt;sizeof(a)/sizeof(int)&lt;&lt;endl; cout&lt;&lt;typeid(sizeof(a)/sizeof(int)).name()&lt;&lt;endl; temp = binary_search(a,sizeof(a)/sizeof(int),5); cout&lt;&lt;temp&lt;&lt;endl; return 0; &#125; 类型名获取使用头文件typeinfo下的typeid(parameter).name()获取类型名","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://yeshan333.github.io/categories/Algorithm/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"},{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/tags/Python/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://yeshan333.github.io/tags/Algorithm/"}]},{"title":"C++面向对象-8","slug":"C++-面向对象-8","date":"2018-11-15T15:40:22.000Z","updated":"2018-11-23T19:18:43.121Z","comments":true,"path":"2018/11/15/C++-面向对象-8/","link":"","permalink":"https://yeshan333.github.io/2018/11/15/C++-面向对象-8/","excerpt":"","text":"使用struct关键字定义类 使用class和struct定义类的唯一区别就是默认的访问权限 使用struct关键字，定义在第一个访问说明符之前的成员是public 使用class关键字，定义在第一个访问说明符之前的成员是private 定义在类内的成员函数是自动inline的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;cstring&gt;#include&lt;iostream&gt; using namespace std;struct Sales_data&#123; /* - isbn成员函数用于返回对象的ISBN编号 - combine成员函数，用于将一个Sales_data对象加到另一个对象上 - avg_price成员函数，用于返回售出书籍的平均价格 */ string isbn() const&#123;return bookNo;&#125;//这是一个常量成员函数，不能改变调用它的对象的内容 Sales_data&amp; combine(const Sales_data&amp;); double avg_price() const; string bookNo; //ISBN unsigned units_sold = 0; //销售总数 double revenue = 0.0; //收益 &#125;;double Sales_data::avg_price() const&#123; if(units_sold) return revenue/units_sold; else return 0;&#125;Sales_data&amp; Sales_data::combine(const Sales_data &amp;rhs)&#123; units_sold += rhs.units_sold; revenue += rhs.revenue; return *this;//返回调用该函数的对象 &#125;/** Salse_data的非成员接口函数：- add函数，执行两个Sales_data对象的加法- read函数，将数据从istream读入到Sales_data对象中- print函数，将Sales_data对象的值输出到ostream */Sales_data add(const Sales_data&amp; ,const Sales_data&amp;);ostream &amp;print(ostream&amp; , const Sales_data&amp;);istream &amp;read(istream&amp; , const Sales_data&amp;);//输入的交易信息包括ISBN、售出总数、售出价格 istream &amp;read(istream &amp;is, Sales_data &amp;item)&#123; double price = 0.0; is&gt;&gt;item.bookNo&gt;&gt;item.units_sold&gt;&gt;price; &#125;ostream &amp;print(ostream &amp;os, const Sales_data &amp;item)&#123; os&lt;&lt;item.isbn()&lt;&lt;\" \"&lt;&lt;item.units_sold&lt;&lt;\" \" &lt;&lt;item.revenue&lt;&lt;\" \"&lt;&lt;item.avg_price(); return os; &#125;Sales_data add(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123; Sales_data sum = lhs;//把lhs的数据成员拷贝给sum sum.combine(rhs); return sum; &#125;int main()&#123; Sales_data total; string temp; temp = \"shansan\"; total.bookNo = temp; //total.bookNo = \"shansan\"; cout&lt;&lt;total.bookNo&lt;&lt;endl; cout&lt;&lt;total.isbn()&lt;&lt;endl; return 0;&#125; 使用=default保留默认的构造函数 &amp; 构造函数初始值列表 当我们需要其他构造函数的时，同时也希望保留默认的构造函数时候，可以使用= default 构造函数初始值是成员函数的一个列表，每个名字后面紧跟括号括起来的（或则在花括号内的）成员初始值。不同成员的初始值通过逗号分隔 构造函数初始值列表只说明用于初始化成员的值,而不限定初始化的具体执行顺序 但是如果一个成员是用另一个成员来初始化的，那么这两个成员的初始化顺序就很重要 consturctor(parameter):initializer_list,注意那个冒号，构造函数不能被声明成const的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cstring&gt; #include&lt;iostream&gt; using namespace std;struct Sales_data&#123; //新增构造函数 //使用构造函数初始值列表，注意那个冒号 //这两个构造函数的函数体都是空的，构造函数没有返回类型 Sales_data() = default;//保留默认构造函数 Sales_data(const string &amp;s) :bookNo(s) &#123;&#125; Sales_data(const string &amp;s, unsigned n, double p):bookNo(s),units_sold(n),revenue(p*n) &#123;&#125; //声明一个constructor，定义放在类外了 Sales_data(istream&amp;); string isbn() const&#123;return bookNo;&#125;//这是一个常量成员函数，不能改变调用它的对象的内容 Sales_data&amp; combine(const Sales_data&amp;); double avg_price() const; string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;;double Sales_data::avg_price() const&#123; if(units_sold) return revenue/units_sold; else return 0;&#125;Sales_data&amp; Sales_data::combine(const Sales_data &amp;rhs)&#123; units_sold += rhs.units_sold; revenue += rhs.revenue; return *this;//返回调用该函数的对象 &#125;/** Salse_data的非成员接口函数：- add函数，执行两个Sales_data对象的加法- read函数，将数据从istream读入到Sales_data对象中- print函数，将Sales_data对象的值输出到ostream */Sales_data add(const Sales_data&amp; ,const Sales_data&amp;);ostream &amp;print(ostream&amp; , const Sales_data&amp;);istream &amp;read(istream&amp; , const Sales_data&amp;);//输入的交易信息包括ISBN、售出总数、售出价格 istream &amp;read(istream &amp;is, Sales_data &amp;item)&#123; double price = 0.0; is&gt;&gt;item.bookNo&gt;&gt;item.units_sold&gt;&gt;price; &#125;ostream &amp;print(ostream &amp;os, const Sales_data &amp;item)&#123; os&lt;&lt;item.isbn()&lt;&lt;\" \"&lt;&lt;item.units_sold&lt;&lt;\" \" &lt;&lt;item.revenue&lt;&lt;\" \"&lt;&lt;item.avg_price()&lt;&lt;endl; return os; &#125;Sales_data add(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123; Sales_data sum = lhs;//把lhs的数据成员拷贝给sum sum.combine(rhs); return sum; &#125;//类外定义新的构造函数Sales_data::Sales_data(istream &amp;is)&#123; read(is,*this);//从is中读入一条信息存到this对象中 &#125; int main()&#123; Sales_data total;//调用默认的构造函数 string temp; temp = \"shansan\"; total.bookNo = temp; //total.bookNo = \"shansan\"; cout&lt;&lt;total.bookNo&lt;&lt;endl; cout&lt;&lt;total.isbn()&lt;&lt;endl; Sales_data let(\"shansan.top\",33,33);//调用构造函数Sales_data(const string &amp;s, unsigned n, double p) cout&lt;&lt;let.bookNo&lt;&lt;\" \"&lt;&lt;let.units_sold&lt;&lt;\" \"&lt;&lt;let.revenue&lt;&lt;endl; Sales_data read_print;//调用默认的构造函数 read(cin,read_print); print(cout,read_print); Sales_data dada(cin);//调用构造函数Sales_data(istream &amp;is) print(cout,dada); return 0;&#125; 委托构造函数 一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程 它把自己的一些或全部职责委托给了其他构造函数 一个委托构造函数和其他构造函数一样也有一个成员初始值列表和一个函数体 委托构造函数的成员初始值列表只有一个入口，就是类名本身。类名后面紧跟圆括号括起来的初始值列表，参数列表必须与另一个构造函数匹配 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;class People&#123; public: //非委托构造函数使用对应的实参初始化成员 People(string m,string x,int n):first_name(m),last_name(x),age(n) &#123;&#125; //其余构造函数全部委托给另一个构造函数 //注意使用冒号 People(): People(\"li\",\"lei\",18)&#123;&#125; People(string insert): People(insert,\"wan\",33)&#123;&#125; People(int a): People(\"wu\",\"ge\",a)&#123;&#125; int print_info(People temp) &#123; cout&lt;&lt;temp.first_name&lt;&lt;\" \"&lt;&lt;temp.last_name&lt;&lt;\" \"&lt;&lt;temp.age&lt;&lt;endl; return 0; &#125; private: string first_name; string last_name; int age; &#125;;int main()&#123; People num_1(\"shan\",\"san\",18);//调用构造函数 People(string m,string x,int n) num_1.print_info(num_1); People num_2;//调用委托构造函数 People(\"li\",\"lei\",18) num_2.print_info(num_2); People num_3(\"six\");//调用委托构造函数 People(string insert) num_3.print_info(num_3); People num_4(100);//调用委托构造函数 People(int a) num_4.print_info(num_4); return 0;&#125;","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"精度(precision)控制","slug":"精度-precision-控制","date":"2018-11-06T15:50:56.000Z","updated":"2018-11-23T19:20:21.520Z","comments":true,"path":"2018/11/06/精度-precision-控制/","link":"","permalink":"https://yeshan333.github.io/2018/11/06/精度-precision-控制/","excerpt":"C++输出精度（precision）控制,格式化输出使用cout对象的成员 setprecision() setf() width() fill() flags(ios::fixed)","text":"C++输出精度（precision）控制,格式化输出使用cout对象的成员 setprecision() setf() width() fill() flags(ios::fixed) 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int main()&#123; double a=3.1415926; double c=66.666666; cout.precision(3); //控制输出流显示的有效数字个数 cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;c&lt;&lt;endl; cout&lt;&lt;endl; cout.width(8); //控制输出宽度 cout.setf(ios::right); //设置对齐方式 cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;endl; cout.setf(ios::right); cout.fill('#'); //设置填充字符 cout.width(8); cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;endl; cout.flags(ios::fixed); //flags(ios::fixed)和precision()配合使用控制精度 cout.precision(4); cout&lt;&lt;a&lt;&lt;endl; return 0;&#125; 使用头文件iomanip中的setprecision()和setiosflags(ios::fixed)进行精度控制1234567891011121314#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;int main()&#123; double e = 2.7182818; cout&lt;&lt;setprecision(3)&lt;&lt;e&lt;&lt;endl; cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;endl; cout&lt;&lt;setprecision(3)&lt;&lt;e&lt;&lt;endl; return 0;&#125; 参考自：https://blog.csdn.net/yanglingwell/article/details/49507463","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"C++标准库类型","slug":"C++-标准库类型","date":"2018-11-05T15:24:19.000Z","updated":"2018-11-23T19:16:55.743Z","comments":true,"path":"2018/11/05/C++-标准库类型/","link":"","permalink":"https://yeshan333.github.io/2018/11/05/C++-标准库类型/","excerpt":"标准库类型string 标准库类型string表示可变长的字符序列 使用string类型必须包含string头文件，string定义在命名空间std中 定义和初始化string对象初始化string对象的方式 初始化方式 说明 string s1 默认初始化，s1是一个空字符串 string s2(s1) s2是s1的副本 string s2=s1 等价于s2(s1)，s2是s1的副本 string s3(“shansan”) s3是字面值”shansan”的副本，除了字面值最后的那个空字符串外 string s3=”shansan” 等价于s3(“shansan”) string s4(n,’c’) 把s4初始化为由连续n个字符c组成的串","text":"标准库类型string 标准库类型string表示可变长的字符序列 使用string类型必须包含string头文件，string定义在命名空间std中 定义和初始化string对象初始化string对象的方式 初始化方式 说明 string s1 默认初始化，s1是一个空字符串 string s2(s1) s2是s1的副本 string s2=s1 等价于s2(s1)，s2是s1的副本 string s3(“shansan”) s3是字面值”shansan”的副本，除了字面值最后的那个空字符串外 string s3=”shansan” 等价于s3(“shansan”) string s4(n,’c’) 把s4初始化为由连续n个字符c组成的串 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int main()&#123; string s1; cout&lt;&lt;s1&lt;&lt;endl; cout&lt;&lt;\"1\"&lt;&lt;endl; string s2 = \"shansan\"; cout&lt;&lt;s2&lt;&lt;endl; string s3(s2); cout&lt;&lt;s3&lt;&lt;endl; string s4(6,'s'); cout&lt;&lt;s4&lt;&lt;endl; return 0;&#125; string对象上的操作 getline(is,s):从is中读取一行赋给s，返回is s.empty():s为空返回true s.size():返回s中字符的个数 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;//empty(),getline(),size()int main()&#123; string s; cin&gt;&gt;s; //* 读取时string对象会默认忽略掉开头的空白（即空格符、换行符、制表符等） //* 从第一个真正的字符开始读起，直到遇见下一处空白为止 cout&lt;&lt;s&lt;&lt;endl; cout&lt;&lt;s.size()&lt;&lt;endl; if(!s.empty())//如果string对象非空 &#123; cout&lt;&lt;\"the string is not empty !\"&lt;&lt;endl; &#125; string line; //每次读取一整行，遇到换行符结束 while(getline(cin,line)) cout&lt;&lt;line&lt;&lt;endl; return 0;&#125; 标准库类型vector #include 标准库类型表示对象的集合，其中所有的对象类型都相同 集合中的每一个对象都有一个与之对应的索引，索引用于访问对象 定义和初始化vector对象 定义和初始化vector对象的方法 说明 vector v1 v1是一个空vector，它潜在的元素是T类型的，执行默认初始化 vector v2(v1) v2中包含有v1所有元素的副本 vector v2=v1 等价于v2(v1) vector v3(n,value) v3包含了n个重复的元素，每个元素的值都是value vector v4(n) v4包含了n个重复地执行了值初始化的对象 vector v5{a,b,c,…} v5包含了初始值的个数的元素，每元素被赋予相应的初始值 vector v5={a,b,c,…} 等价于v5 vector对象上的操作 v.empty():如果v不含有任何元素，返回真，否者返回假 v.size():返回v中元素的个数 v.push_back(t):向v的尾端添加一个值为t的元素 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; s=&#123;1,2,3,4,5&#125;;;//列表初始化vector对象s //- 可使用下标访问vector对象 cout&lt;&lt;s[0]&lt;&lt;endl; vector&lt;int&gt; a(8,1); for(auto i:a) &#123; cout&lt;&lt;i&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; string word; vector&lt;string&gt; text; while(cin&gt;&gt;word) &#123; text.push_back(word);//push_back() &#125; for(auto str:text) &#123; cout&lt;&lt;str&lt;&lt;\" \"; &#125; return 0; &#125; 使用范围for语句处理vector对象12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int num; vector&lt;int&gt; v; while(cin&gt;&gt;num)//获取元素值 &#123; v.push_back(num); &#125; for(auto &amp;i:v)//求元素值的平方 &#123; i = i*i; &#125; for(auto temp:v)//输出v中每一个元素 &#123; cout&lt;&lt;temp&lt;&lt;\" \"; &#125; return 0; &#125; 不可用下标形式为vector对象添加元素12345678910111213141516#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v;//空的vector对象 for(decltype(v.size()) i =0;i!=6;i++) &#123; v[i] = i; &#125; // -v是一个空的vector，不存在任何元素，不能通过下标去访问 // -应该使用vector对象的成员函数push_back()为vector对象添加元素较为安全 cout&lt;&lt;v[0]&lt;&lt;endl; return 0; &#125; vector对象(以及string对象)的下标运算符可用于访问已存在的元素，而不能用于添加元素 使用标准库函数begin()和end()遍历数组123456789101112131415#include&lt;iostream&gt;using namespace std;//库函数begin和end，以数组名作为参数 int main()&#123; int sums[]=&#123;1,2,3,4,5,6,7,8,9,10&#125;; int *beg = begin(sums); //指向sums首元素的指针 int *last = end(sums); //指向sums尾元素的下一位置的指针 int *temp; for(temp = beg;temp != last;temp++) &#123; cout&lt;&lt;*temp&lt;&lt;\" \"; &#125; return 0;&#125; begin()函数返回指向数组sums首元素的指针 end()函数返回指向数组sums尾元素下一位置的指针 使用可迭代对象（容器||string对象）的成员begin()和end()进行遍历 end成员返回指向容器(string对象)“尾元素下一位置（one past the end）”的迭代器（尾后迭代器） begin成员负责返回指向第一个元素（或者第一个字符的迭代器） 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; string s=\"shan san\";//s(\"shan san\"); cout&lt;&lt;s&lt;&lt;endl; //首字母改成大写形式 if(s.begin() != s.end()) &#123; auto it = s.begin();//令it指向s的第一个元素 *it = toupper(*it); &#125; cout&lt;&lt;s&lt;&lt;endl; //全部字母改成大写形式,&amp;&amp; !isspace(*temp) //temp是个迭代器，通过 * 运算符解引用迭代器获得迭代器所指的对象 for(auto temp=s.begin();temp != s.end() ; temp++) &#123; *temp = toupper(*temp); &#125; cout&lt;&lt;s&lt;&lt;endl; const int a=8; //a=0; cout&lt;&lt;a&lt;&lt;endl; char c[10]=\"123456789\"; char b[10]; strcpy(b,c); cout&lt;&lt;b[1]&lt;&lt;endl; return 0;&#125;","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"C++11特性-1","slug":"C++-11特性-1","date":"2018-11-05T15:19:57.000Z","updated":"2018-11-23T19:16:16.113Z","comments":true,"path":"2018/11/05/C++-11特性-1/","link":"","permalink":"https://yeshan333.github.io/2018/11/05/C++-11特性-1/","excerpt":"c++11特性列表初始化 使用花括号来初始化对象 使用列表初始化内置类型的变量，可能会存在丢失信息的风险","text":"c++11特性列表初始化 使用花括号来初始化对象 使用列表初始化内置类型的变量，可能会存在丢失信息的风险 auto类型说明符号decltype类型说明符auto auto让编译器通过初始值来推算变量的类型 使用auto也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中的所有变量的初始基本数据类型都必须一样 编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则 123456789101112131415161718#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;int main()&#123; int a = 33; double pi = 3.1415926; auto b=a; //auto c=1.414,d=1;//[Error] inconsistent deduction for 'auto': 'double' and then 'int' cout&lt;&lt;typeid(pi).name()&lt;&lt;endl; cout&lt;&lt;typeid(a).name()&lt;&lt;endl; //cout&lt;&lt;typeid(c).name()&lt;&lt;endl; return 0;&#125; delctype 从表达式的类型推断出要定义的变量的类型，不使用该表达式的值初始化变量 编译器分析表达式并得到它的类型，却不实际计算表达式的值 如果decltype使用的表达式不是一个变量，则返回表达式结果对用的类型 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;int main()&#123; int a=1,b=3; int &amp;refer_a=a; decltype(a+b) temp=33; decltype(refer_a) en=b;//引用类型定义时就必须初始化 decltype((a)) refer=b;//decltype((variable))的结果永远是引用，使用了双层括号 cout&lt;&lt;temp&lt;&lt;\" \"&lt;&lt;\"it's type:'\"&lt;&lt;typeid(temp).name()&lt;&lt;endl; cout&lt;&lt;refer_a; cout&lt;&lt;en&lt;&lt;endl; cout&lt;&lt;refer&lt;&lt;endl; return 0;&#125; 范围for语句基本形式： for(declaration : expression) statement expression部分是一个对象，用于表示一个序列 declaration部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量都会被初始化为expression部分的下一个元素值 使用范围for语句遍历string对象1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;int main()&#123; string str(\"shan san\"); //通过编译器来决定变量的类型 for(auto s : str) &#123; cout&lt;&lt;s&lt;&lt;\" \"; &#125; cout&lt;&lt;endl; for(auto temp : str) &#123; cout&lt;&lt;temp; &#125; cout&lt;&lt;endl; //使用引用,使字符串对象str变为大写 for(auto &amp;a : str) &#123; a = toupper(a); &#125; cout&lt;&lt;str&lt;&lt;endl; //使用下标进行迭代,改变字符串对象str的大小写状态 for(decltype(str.size()) index = 0; index != str.size(); ++index) &#123; str[index] = toupper(str[index]); &#125; cout&lt;&lt;str; return 0; &#125; 使用范围for语句遍历二维数组 使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstddef&gt; using namespace std;int main()&#123; constexpr size_t rowCnt = 3,colCnt = 4; int a[rowCnt][colCnt]; //二位数组初始化 for(size_t i = 0; i != rowCnt; i++) &#123; for(size_t j=0; j != colCnt;j++) &#123; //将元素的位置索引作为它的值 a[i][j] = i*colCnt + j; &#125; &#125; for(auto &amp;temp : a) //对于外层数组的每一个元素 &#123; for(auto lim :temp) //对于内层数组的每一个元素 &#123; cout&lt;&lt;lim&lt;&lt;endl; &#125; &#125; return 0;&#125; 使用范围for语句遍历vector对象1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int scores; vector&lt;int&gt; v; while(cin&gt;&gt;scores) &#123; v.push_back(scores); &#125; for(auto temp : v) &#123; cout&lt;&lt;temp&lt;&lt;\" \"; &#125; return 0;&#125;","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"python生成器回顾","slug":"python生成器回顾","date":"2018-11-02T15:25:44.000Z","updated":"2019-03-23T09:14:13.396Z","comments":true,"path":"2018/11/02/python生成器回顾/","link":"","permalink":"https://yeshan333.github.io/2018/11/02/python生成器回顾/","excerpt":"python生成器（generator） 生成器是一种使用普通函数语法定义的迭代器 包含yield语句的函数都是生成器，它是一个不断产生值的函数 生成器每次使用yield产生一个值后，函数都将冻结，即在此处停止执行，等待重新被唤醒。被唤醒后从停止的地方开始继续执行 生成器推导（生成器表达式） 使用圆括号()创建一个生成器推导 ,它创建了一个可迭代的对象使用next()函数可以获得生成器推导的下一个返回值 g = (i**2 for i in range(10))","text":"python生成器（generator） 生成器是一种使用普通函数语法定义的迭代器 包含yield语句的函数都是生成器，它是一个不断产生值的函数 生成器每次使用yield产生一个值后，函数都将冻结，即在此处停止执行，等待重新被唤醒。被唤醒后从停止的地方开始继续执行 生成器推导（生成器表达式） 使用圆括号()创建一个生成器推导 ,它创建了一个可迭代的对象使用next()函数可以获得生成器推导的下一个返回值 g = (i**2 for i in range(10)) simple generator demo_1 斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到 demo_2_generator recursive generator处理多层嵌套列表 1234567891011121314def flagtten(nested): try: for sublist in nested: for element in flagtten(sublist): yield element except TypeError:#处理迭代单个对象引起的typeerror异常 yield nesteddef main(): s = list(flagtten([1,[2,3]])) print(s)main() 123456789101112131415161718192021def flagtten(nested): try: #不迭代类似于字符串的对象 try: nested + '' except TypeError: pass else: raise TypeError for sublist in nested: for temp in flagtten(sublist): yield temp except TypeError: yield nesteddef main(): s = list(flagtten([\"haha\",[\"shan\",\"san\"]])) print(s)main()","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/tags/Python/"}]},{"title":"Scrapy爬虫框架","slug":"Scrapy爬虫框架","date":"2018-10-31T15:13:19.000Z","updated":"2019-03-23T09:13:52.660Z","comments":true,"path":"2018/10/31/Scrapy爬虫框架/","link":"","permalink":"https://yeshan333.github.io/2018/10/31/Scrapy爬虫框架/","excerpt":"","text":"网络爬虫框架scrapy（配置型爬虫） 什么是爬虫框架？ 爬虫框架是实现爬虫功能的一个软件结构和功能组件集合 爬虫框架是个半成品，帮助用户实现专业网络爬虫 scrapy框架结构(“5+2”结构) spider: 解析downloader返回的响应（Response） 产生爬取项（scraped item） 产生额外的爬去请求（Request）需要用户编写配置代码 engine(引擎): 控制所有模块之间的数据流 根据条件触发事件不需要用户修改 scheduler(调度器): 对所有爬取请求进行调度处理不需要用户修改 downloader(下载器): 根据请求下载网页不需要用户修改 item pipelines(): 以流水线处理spider产生的爬取项 由一组操作顺序组成，类似流水线，每个操作是一个Item Pipeline类型 可能操作包括：清理、检验和查重爬取项中的HTML数据，将数据存储到数据库中需要用户编写配置代码 downloader middleware(中间件): 目的：实施engine、scheduler和downloader之间进行用户可配置的控制 功能：修改、丢弃、新增请求或响应用户可以编写配置代码 spider middleware(中间件): 目的：对请求和爬去项的再处理 功能：修改、丢弃、新增请求或爬取项用户可以编写配置代码 数据流 1.Engine从Spider处获得爬取请求(Request) 2.Engine将爬取请求转发给Scheduler,用于调度 3.Engine从Scheduler处获得下一个爬取的请求 4.Engine将爬取请求通过中间件发送给Downloader 5.爬取网页后，Downloader形成响应(Response)，通过中间件(Middleware)发给Engine 6.Engine将收到的响应通过中间件发送给Spider处理 7.Spider处理响应后产生爬取项（scraped item）和新的爬取请求(Requests)给Engine 8.Engine将爬取项发送给Item Pipeline(框架出口) 9.Engine将爬取请求发送给Scheduler Engine控制各模块数据流，不间断从Scheduler处获得爬取请求，直到请求为空 框架入口：Spider的初始爬取请求 框架出口：Item Pipeline scrapy命令行格式 scrapy &lt;command&gt; [options] [args] 常用命令 命令 说明 格式 startproject 创建一个新工程 scrapy startproject [dir] genspider 创建一个爬虫 scrapy genspider [options] [domain] settings 获得爬虫配置信息 scrapy settings [options] crawl 运行一个爬虫 scrapy crawl list 列出工程中所有的爬虫 scrapy list shell 启动URL调试命令行 scrapy shell [url] demohttps://python123.io/ws/demo.html创建工程scrapy startproject python123demo 创建爬虫scrapy genspider demo python123.io //生成了一个名为demo的spider //在spider目录下增加代码文件demo.py（该文件也可以手工生成） demo.py文件 1234567891011# -*- coding: utf-8 -*-import scrapyclass DemoSpider(scrapy.Spider): name = 'demo' allowed_domains = ['python123.io'] start_urls = ['http://python123.io/'] def parse(self, response): pass 配置产生的spider爬虫123456789101112131415# -*- coding: utf-8 -*-import scrapyclass DemoSpider(scrapy.Spider): name = 'demo' #allowed_domains = ['python123.io'] start_urls = ['http://python123.io/ws/demo.html'] def parse(self, response): #存储文件名demo.html file_name = response.url.split('/')[-1] with open(file_name,\"wb\") as f: f.write(response.body) self.log('Saved file %s' % file_name)#日志 * 另一个版本 123456789101112131415161718192021# -*- coding: utf-8 -*-import scrapyclass DemoSpider(scrapy.Spider): name = 'demo' #allowed_domains = ['python123.io'] #start_urls = ['http://python123.io/ws/demo.html'] def start_requests(self): urls = [ 'http://python123.io/ws/demo.html' ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self, response): #存储文件名demo.html file_name = response.url.split('/')[-1] with open(file_name,\"wb\") as f: f.write(response.body) self.log('Saved file %s' % file_name)#日志 运行爬虫scrapy crawl demo Scrapy爬虫数据类型 Request类 Response类 Item类 Request类class scrapy.http.Request() Request对象表示一个HTTP请求 由Spider生成，由Downloader执行 属性 方法 .url Requests对应的请求URL地址 .method 对应的请求方法，’GEt’、’POST’等 .headers 字典类型风格的请求头 .body 请求内容主体，字符串类型 .meta 用户添加的扩展信息，在Scrapy内部模块间传递信息使用 .copy 复制该请求 Response类class scrapy.http.Response() Response对象表示一个HTTp响应 由Downloader生成，由Spider处理 属性或方法 说明 .url Response对应的URL地址 .status HTTP状态码，默认是200 .headers Response对应的头部信息 .body Response对应的内容信息，字符串类型 .flags 一组标记 .request 产生Response类型对应的Request对象 .copy() 复制该响应 Item类class scrapy.item.Item() Item对象表示一个从HTML页面中提取的信息内容 由Spider生成，由Item Pipeline处理 Item类似字典类型，可以按照字典类型操作 Scrapy爬虫的使用步骤 创建一个工程和Spider模板 编写Spider 编写Item Pipeline 优化配置策略 scrapy爬虫信息提取方法 Beautifui Soup lxml re XPath Selector CSS Selector","categories":[{"name":"Scrapy","slug":"Scrapy","permalink":"https://yeshan333.github.io/categories/Scrapy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/tags/Python/"},{"name":"Scrapy","slug":"Scrapy","permalink":"https://yeshan333.github.io/tags/Scrapy/"}]},{"title":"HTML试水","slug":"HTML试水","date":"2018-10-30T15:39:10.000Z","updated":"2018-10-30T15:42:01.717Z","comments":true,"path":"2018/10/30/HTML试水/","link":"","permalink":"https://yeshan333.github.io/2018/10/30/HTML试水/","excerpt":"一级标题 二级标题","text":"一级标题 二级标题 倚天屠龙记张无忌这是另一段 锚点这是我的个人博客这是我的个人博客，新标签页打开 邮箱联系我 图像 img是自关标记，不需要结束标记 文本这里是粗体 这里是斜体 what 这里还是斜体 插入字体，下划线 删除线 ~~~123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113下标&amp;&amp;上标H&lt;sub&gt;2&lt;/sub&gt;O&lt;sub&gt;2&lt;/sub&gt;嗯&lt;sup&gt;我飘了&lt;/sup&gt;&lt;code&gt;#include&lt;stdio.h&gt;int main()&#123; printf(&quot;wocao!&quot;);&#125;&lt;/code&gt;正常字&lt;small&gt;小号字&lt;/small&gt;&lt;q&gt;短引用，双引号包围&lt;/q&gt;&lt;blockquote&gt;长引用土地是以它的肥沃和收获而被估价的；才能也是土地，不过它生产的不是粮食，而是真理。如果只能滋生瞑想和幻想的话，即使再大的才能也只是砂地或盐池，那上面连小草也长不出来的。 —— 别林斯基&lt;/blockquote&gt;22222222222222222222222222222## 表格 &lt;table&gt;...&lt;/table&gt;:定义表格 &lt;th&gt;...&lt;/th&gt;:定义表格的标题栏（文字加粗体） &lt;tr&gt;...&lt;/tr&gt;:定义表格的行 &lt;td&gt;...&lt;/td&gt;:定义表格的列&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;row 1, cell 1&lt;/td&gt;&lt;td&gt;row 1, cell 2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;row 2, cell 1&lt;/td&gt;&lt;td&gt;row 2, cell 2&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;### 跨列表格&lt;table border=&quot;1&quot;&gt;&lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th colspan=&quot;2&quot;&gt;电话&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;shansan&lt;/td&gt; &lt;td&gt;1329441308&lt;/td&gt; &lt;td&gt;164354491&lt;/td&gt;&lt;/tr&gt;&lt;table&gt;&lt;h3&gt;跨行表格&lt;/h3&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;td&gt;shansan&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;电话&lt;/th&gt; &lt;td&gt;1329441308&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;164354491&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;## syntax```html# HTML试水&lt;h1&gt; 一级标题 &lt;/h1&gt;&lt;h2&gt; 二级标题 &lt;/h2&gt;&lt;!-- more --&gt;&lt;p&gt;倚天屠龙记&lt;/p&gt;&lt;p&gt;张无忌&lt;/p&gt;&lt;p&gt;这是另一段&lt;/p&gt;## 锚点&lt;a href = &quot;https://shansan.top&quot;&gt;这是我的个人博客&lt;/a&gt;&lt;a href = &quot;https://shansan.top&quot; target=&quot;_blank&quot;&gt;这是我的个人博客，新标签页打开&lt;/a&gt;&lt;a href=&quot;mailto:1329441308@qq.com&quot; target=&quot;_top&quot;&gt;邮箱联系我&lt;/a&gt;# 图像** img是自关标记，不需要结束标记 **&lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;## 文本&lt;b&gt;这里是粗体&lt;/b&gt;&lt;i&gt;这里是斜体&lt;/i&gt;&lt;strong&gt;what&lt;/strong&gt;&lt;em&gt;这里还是斜体&lt;/em&gt;&lt;ins&gt;插入字体，下划线&lt;/ins&gt;&lt;del&gt;删除线&lt;/del&gt;~~~ 还是删除线 下标&amp;&amp;上标H2O2 嗯我飘了 #includeint main(){ printf(“wocao!”);} 正常字小号字 短引用，双引号包围 长引用 土地是以它的肥沃和收获而被估价的；才能也是土地，不过它生产的不是粮食，而是真理。 如果只能滋生瞑想和幻想的话，即使再大的才能也只是砂地或盐池，那上面连小草也长不出来的。 —— 别林斯基 22222222222222222222222222222 表格 row 1, cell 1 row 1, cell 2 row 2, cell 1 row 2, cell 2 跨列表格 姓名 电话 shansan 1329441308 164354491 跨行表格 姓名 shansan 电话 1329441308 164354491 &lt;/table&gt; ```","categories":[{"name":"HTML","slug":"HTML","permalink":"https://yeshan333.github.io/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://yeshan333.github.io/tags/HTML/"}]},{"title":"竖式问题","slug":"竖式问题","date":"2018-10-24T15:59:00.000Z","updated":"2018-10-24T16:00:38.071Z","comments":true,"path":"2018/10/24/竖式问题/","link":"","permalink":"https://yeshan333.github.io/2018/10/24/竖式问题/","excerpt":"字符串处理函数strchr() &amp;&amp; 竖式问题 竖式问题","text":"字符串处理函数strchr() &amp;&amp; 竖式问题 竖式问题 题目描述 找出所有形如abc*de（三位数乘两位数）的算式，使得在完整的竖式中，所有数字都属于一个特定的数字集合。 输入： 输入一个数字集合（相邻数字之间没有空格） 输出： 输出所有竖式.每个竖式前应该编号，之后应该有一个空行。最后输出解的总数。 样例输入： 2357 样例输出： (1)&ensp;&ensp;775x&ensp;&ensp;33——-&ensp;23252325&ensp;——-25575The number of solution = 1 分析小学的乘法运算 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;string.h&gt; int main()&#123; int count; char s[20],buf[99]; scanf(\"%s\",s); for(int abc = 111;abc &lt;= 999;abc++) &#123; for(int de = 11;de &lt;= 99;de++) &#123; int x = abc*(de%10),y = abc*(de/10),z = abc*de; sprintf(buf,\"%d%d%d%d%d\",abc,de,x,y,z); /* - 使用sprintf()把信息输出到字符串 - strchr()函数的作用是在一个字符串中查找单个字符 */ int ok = 1; for(int i = 0;i&lt;strlen(buf);i++) &#123; if(strchr(s,buf[i])==NULL) ok = 0; &#125; if(ok) &#123; printf(\"(%d)\\n\",++count); printf(\"%5d\\nx%4d\\n-----\\n%5d\\n%4d\\n-----\\n%5d\\n\\n\",abc,de,x,y,z); &#125; &#125; &#125; printf(\"The number of solutions = %d\\n\",count); return 0;&#125; 字符处理函数strchr()strchr() 用来查找某字符在字符串中首次出现的位置，其原型为： char strchr (const char str, int c); strchr() 将会找出 str 字符串中第一次出现的字符 c 的地址，然后将该地址返回。 如果找到指定的字符则返回该字符所在地址，否则返回 NULL。 12345678910#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char *s=\"666shansan\"; char *p; p = strchr(s,'s'); printf(\"%s\",p); return 0;&#125; 输出结果 shansan","categories":[{"name":"C","slug":"C","permalink":"https://yeshan333.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"https://yeshan333.github.io/tags/C/"}]},{"title":"坑人的C++-2","slug":"坑人的C++-2","date":"2018-10-22T15:41:19.000Z","updated":"2018-11-23T19:20:54.111Z","comments":true,"path":"2018/10/22/坑人的C++-2/","link":"","permalink":"https://yeshan333.github.io/2018/10/22/坑人的C++-2/","excerpt":"C++文件和流在C++中进行文件处理，可使用标准库fstream 它定义了三个新的数据类型，用于从文件写入流和从文件读取流 数据类型 描述 ofstream 该数据类型表示输出文件流，用于创建文件并向文件中写入信息 ifstream 该数据类型表示输入文件流，用于从文件中读取信息 fstream 该数据类型通常表示文件流，同时具有ofstream和ifstream两种功能，他可以创建文件，向文件中写入信息，从文件中读取信息","text":"C++文件和流在C++中进行文件处理，可使用标准库fstream 它定义了三个新的数据类型，用于从文件写入流和从文件读取流 数据类型 描述 ofstream 该数据类型表示输出文件流，用于创建文件并向文件中写入信息 ifstream 该数据类型表示输入文件流，用于从文件中读取信息 fstream 该数据类型通常表示文件流，同时具有ofstream和ifstream两种功能，他可以创建文件，向文件中写入信息，从文件中读取信息 打开文件ofstream和ifstream对象都可以open()函数打开文件进行写操作。open()函数是ofstream、ifstream、fstream对象的一个成员。open()函数标准语法 void open(const char *filename,ios::openmode mode) 第一个参数为要打开的文件名称和位置 第二个参数为文件打开的模式 模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾 ios::ate 文件打开后定位到文件末尾 ios::in 打开文件用于读取 ios::out 打开文件用于写入 ios::trunc 如果文件已经存在，其内容在打开文件之前被截断，即把文件长度设为0 打开模式可以两个或者多个结合使用 ofstream outfile; outfile.open(&quot;file.data&quot;,ios::out|ios::trunc) //outfile.open(&quot;file.data&quot;,ios::out|ios::in) 关闭文件C++程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。听说优秀的程序员会在程序终止前关闭打开的文件 使用close()函数 写入文件 &amp;&amp; 读取文件 使用流插入运算符（&lt;&lt;）向文件写入信息，就像使用该运算符输出信息到屏幕上一样，但用的不是cout对象，而是ofstream或者fstream对象 -使用流提取运算符（&gt;&gt;）从文件中读取信息。这里使用的是ifstream或者fstream对象 demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;int main()&#123; char data[100]; //以写模式打开文件 ofstream outfile; outfile.open(\"afile.data\");//这里使用了相对路径 cout&lt;&lt;\"writing to the file\"&lt;&lt;endl; cout&lt;&lt;\"enter your name:\"; cin.getline(data,100);//cin对象的附加函数，getline()从外部读取一行 //向文件写入用户输入的数据 outfile&lt;&lt;data&lt;&lt;endl; cout&lt;&lt;\"enter your age:\"; cin&gt;&gt;data; cin.ignore();//忽略掉之前读语句留下的多余字符 //再次向文件写入用户输入的数据 outfile&lt;&lt;data&lt;&lt;endl; outfile.close(); //以读模式打开文件 ifstream infile; infile.open(\"afile.data\"); cout&lt;&lt;\"reading from the file\"&lt;&lt;endl; infile&gt;&gt;data; //在屏幕上读取数据 cout&lt;&lt;data&lt;&lt;endl; //再次从文件中读取数据并显示它 infile&gt;&gt;data; cout&lt;&lt;data&lt;&lt;endl; infile.close(); return 0; &#125;","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"坑人的C++","slug":"坑人的C++","date":"2018-10-22T15:38:58.000Z","updated":"2018-11-23T19:20:38.277Z","comments":true,"path":"2018/10/22/坑人的C++/","link":"","permalink":"https://yeshan333.github.io/2018/10/22/坑人的C++/","excerpt":"C++自定义命名空间使用关键字namespace namespace namespace_name { //代码声明 }","text":"C++自定义命名空间使用关键字namespace namespace namespace_name { //代码声明 } 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;using std::cout;namespace print_myname&#123; void func() &#123; cout&lt;&lt;\"myname: shansan\"&lt;&lt;endl; &#125;&#125;namespace print_font&#123; void func_1() &#123; std::cout&lt;&lt;\"什么鬼 ！\"&lt;&lt;endl; &#125;&#125;using namespace print_myname;using namespace print_font; int main()&#123; //print_myname::func(); func(); //print_font::func_1(); func_1(); return 0;&#125; 不连续的命名空间 命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的组成部分可以分布在多个文件中所以，如果命名空间中某个组成部分需要请求定义在另一个文件中的名称，仍然需要声明该名称。下面的命名空间可以定义一个新的命名空间，也可以是为已有的命名空间增加新的元素。 namespace namespace_name { //代码生明 } 嵌套的命名空间可以在一个命名空间中定义另一个命名空间 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;namespace my_firstname&#123; void print_firstname() &#123; cout&lt;&lt;\"shan \"; &#125; namespace my_lastname &#123; void print_lastname() &#123; cout&lt;&lt;\"san\"&lt;&lt;endl; &#125; &#125;&#125;//using namespace my_firstname;using namespace my_firstname::my_lastname;int main()&#123; //print_firstname(); //my_lastname::print_lastname(); print_lastname(); return 0;&#125; C++异常处理 异常是在程序执行期间产生的问题。 C++异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。 异常提供了一种转移程序控制权的方式。 C++异常处理关键字 throw:当问题出现时，程序会抛出一个异常。通过throw关键字来完成。 catch:在想要处理问题的地方，通过异常处理程序捕获异常。catch关键字用于捕获异常。 try:try块中的代码标识将被激活的特定异常。他后面通常跟着一个或者多个catch块如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号... 12345678try &#123; //被保护代码块 &#125; catch(...) &#123; //能处理任何异常代码 &#125; 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;double division(double a,double b)&#123; if(b == 0) &#123; throw \"Division by zero condition!\"; &#125; return (a/b);&#125;int main()&#123; int a,b; double temp; scanf(\"%d%d\",&amp;a,&amp;b); try &#123; temp = division(a,b); cout&lt;&lt;temp&lt;&lt;endl; &#125; /*由于我们抛出了一个类型为 const char* 的异常， 因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。*/ catch(const char *msg) &#123; cerr&lt;&lt;msg&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"丘一丘正则表达式","slug":"丘一丘正则表达式","date":"2018-10-17T17:51:46.000Z","updated":"2019-03-23T09:12:32.039Z","comments":true,"path":"2018/10/18/丘一丘正则表达式/","link":"","permalink":"https://yeshan333.github.io/2018/10/18/丘一丘正则表达式/","excerpt":"正则表达式(regular expression,regex,RE) 正则表达式是一种用来简洁表达一组字符串的表达式 正则表达式是一种通用的字符串表达框架 正则表达式是一种针对字符串表达“简洁”和“特征”思想的工具 正则表达式可以用来判断某字符串的特征归属","text":"正则表达式(regular expression,regex,RE) 正则表达式是一种用来简洁表达一组字符串的表达式 正则表达式是一种通用的字符串表达框架 正则表达式是一种针对字符串表达“简洁”和“特征”思想的工具 正则表达式可以用来判断某字符串的特征归属 正则表达式常用操作符 操作符 说明 实例 . 表示任意单个字符 py. 可以匹配pyc,pyy,py!等等 [ ] 字符集，对单个字符给出取值范围 [abc]可以匹配a或b或c；[0-9a-zA-z\\_]可以匹配一个数字、一个字母或者一个下划线 非字符集，对单个字符给出排除范围 abc可以匹配非a或非b或非c的单个字符 * 前一个字符0次或多次扩展 abc* 可以匹配ab、abc、abcc、abccc等等 + 前一个字符的1次或多次扩展 abc+可以匹配abc、abcc、abccc等等 ? 前一个字符0次或1次扩展 abc?可以匹配ab、abc &#124; 左右表达式任意一个 abc&#124;def表示abc、def {m} 扩展前一个字符m次 ab{2}c匹配abbc {m,n} 扩展前一个字符m至n次数（含n） ab{1，2}c可以匹配abc、abbc ^ 匹配字符串开头 ^abc表示abc且在一个字符串的开头,^\\d表示必须以数字开头 $ 匹配字符串结尾 abc表示abc且在一个字符串的结尾、\\d$白哦是必须以数字结尾 ( ) 分组标记,内部只能使用&#124;操作符 (abc&#124;def)表示abc、def \\d 可以匹配一个数字，相当于[0-9] \\d{3}表示匹配3个数字，如010 \\w 可以匹配一个字母或者数字或者下划线，相当于[a-zA-Z0-9_] \\w\\w\\d可以匹配’py3’ \\s 可以匹配一个空格（也包括Tab等空白字符） \\s+表示至少有一个空格，如’ ‘、’ ‘ 精确匹配在正则表达式中，如果直接给出字符，就是精确匹配 ‘pyt’ 匹配’pyt’ ‘00\\d’ 可以匹配’007’ ‘\\w\\d’ 可以匹配’!5’ ‘ye.’ 可以匹配’yes’ ‘(P&#124;p)python’ 可以匹配’Python’、’python’ 高阶精确匹配,经典实例 ^[A-Za-z]+$ 匹配由26个英文字母组成的字符串,如’abrg’、’abgsfsfga’ [a-zA-Z\\][0-9a-zA-Z\\]* 可以匹配由字母或者下划线开头、后接任意一个由字母、数字或者下划线组成的字符串，也就是python的合法变量 ^-?\\d+$ 匹配整数形式的字符串 ^[0-9][1-9][0-9]$ 匹配正整数形式的字符串 [1-9]\\d{5} 中国境内邮政编码,6位 [\\u4e00-\\u9fa5] 匹配中文字符 \\d{3}-\\d{8}&#124;\\d{4}-\\d{7} 国内电话号码,010-68913536 python正则表达式模块，（Re模块） re是python的标准库，主要用于字符串匹配 re库采用raw string类型(原生字符串类型)表示正则表达式，例如r&#39;[1-9]\\d{5}&#39;,raw string是不包含对转义符再次转义的字符串 re库也可以采用string类型表示正则表达，但是较为繁琐，例如&#39;[1-9]\\\\d{5}&#39; re库功能函数 函数 说明 re.search() 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象 re.match() 从一个字符串的开始位置起匹配正则表达式，返回match对象 re.findall() 搜索字符串，以列表类型返回全部能匹配的子串 re.split() 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型 re.finditer 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 re.sub() 在字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 1. re.search(pattern,string,flags=0) 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象 pattern:正则表达式的字符串或原生字符串表示 string:待匹配字符串 flags： 正则表达式使用时的控制标记 常用标记 说明 re.I&ensp;re.IGNORECASE 忽略正则表达式的大小写，[A-Z]能够匹配小写字符 re.M&ensp;re.MULTILINE 正则表达式中的^操作符能够将给定字符串的每行当做匹配开始 re.s&ensp;re.DOTALL 正则表达式中的.操作符能够匹配所有字符串，默认匹配除换行外的所有字符串 2. re.match(pattern,string,flags=0) 从一个字符串的开始位置起匹配正则表达式，返回match对象 pattern:正则表达式的字符串或者原生字符串表示 string:待匹配字符串 flags:正则表达式使用时的控制标记 3. re.findall(pattern,string,flags=0) 搜索字符串，以列表类型返回全部能匹配的字符串 4. re.split(pattern,string,maxsplit=0,flags=0) 将一个字符串按照正则匹配结果进行分割，返回列表类型 maxsplt:最大分割数，剩余部分作为最后一个元素输出 5. re.finditer(pattern,string,flags=0) 搜索字符串，返回一个匹配结果的迭代类型，每个迭代类型是match对象 6. re.sub(pattern,repl,string,cout=0,flags=0) 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 repl:替换匹配字符串的字符串 cout:匹配的最大替换次数 re库的面向对象用法在python中使用正则表达式的时候，re模块内部会做两件事： 编译正则表达式，如果正则表达式本身不合法，会报错 用编译后的正则表达式去匹配字符串 regex = re.compile(pattern,flags=0) 将正则表达式的字符串形式编译成正则表达式对象 pattern:正则表达式的字符串或原生字符串表示 flags:正则表达式使用时的控制标记 compile后生成了regular expression对象，由于该1对象包含了正则表达式，所以调用对应的方法不用给出正则字符串 re库的Match对象 Match对象是一次匹配的结果，包含很多信息 Match对象的属性 属性 说明 .string 待匹配的文本 .re 匹配使用的pattern对象(正则表达式) .pos 正则表达式搜索文本的开始位置 .endpos 正则表达式搜索文本的结束位置 Match对象的方法 方法 说明 .group(0) 获得匹配后的字符串 .start() 匹配字符串在原始字符串的开始位置 .end() 匹配字符串在原始字符串的结束位置 .span() 返回(.start(),.end())一个元组 re库的贪婪匹配和最小匹配re库默认使用贪婪匹配，即匹配最长的子串 最小匹配 最小匹配操作符 操作符 说明 *? 前一个字符0次或者无限次扩展，最小匹配 +? 前一个字符1次或者无限次扩展，最小匹配 ?? 前一个字符0次或1次扩展，最小匹配 {m,n}? 扩展前一个字符m至n次(包含n)，最小匹配 只要输出长度可能不同的，都可以通过在操作符后面加?变成最小匹配 https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143193331387014ccd1040c814dee8b2164bb4f064cff000","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://yeshan333.github.io/tags/爬虫/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://yeshan333.github.io/tags/正则表达式/"}]},{"title":"C++面向对象-7","slug":"C++-面向对象-7","date":"2018-10-16T15:39:00.000Z","updated":"2018-11-23T19:18:33.485Z","comments":true,"path":"2018/10/16/C++-面向对象-7/","link":"","permalink":"https://yeshan333.github.io/2018/10/16/C++-面向对象-7/","excerpt":"数据抽象 数据抽象(data abstraction)是与面向对象(object-oriented)并列的一种编程范式(programming paradigm)。数据抽象也成为抽象数据类型(abstract data type/ADT)。数据抽象是一种依赖于接口和实现分离的编程（设计）技术。https://wizardforcel.gitbooks.io/sicp-py/content/2.2.htmlhttp://wj196.iteye.com/blog/860303https://blog.csdn.net/Solstice/article/details/6707148 C++类为数据抽象提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。数据抽象仅为用户暴露接口，而把具体的实现隐藏了起来","text":"数据抽象 数据抽象(data abstraction)是与面向对象(object-oriented)并列的一种编程范式(programming paradigm)。数据抽象也成为抽象数据类型(abstract data type/ADT)。数据抽象是一种依赖于接口和实现分离的编程（设计）技术。https://wizardforcel.gitbooks.io/sicp-py/content/2.2.htmlhttp://wj196.iteye.com/blog/860303https://blog.csdn.net/Solstice/article/details/6707148 C++类为数据抽象提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。数据抽象仅为用户暴露接口，而把具体的实现隐藏了起来 数据抽象的两个优势 类的内部受到保护，不会因为无意的用户级错误导致对象状态受损。 类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对哪些不改变用户级代码的错误报告。 1234567891011121314151617181920212223242526272829303132333435363738//example：//demo #include&lt;iostream&gt;using namespace std;class Student &#123; private: //对外隐藏的数据 int num; int score; public: //构造函数 Student() &#123; cout&lt;&lt;\"Constructor called !\"&lt;&lt;endl; &#125; //对外的接口 int SetNum(int number) &#123; this-&gt;num = number; return num; &#125; //对外的接口 int SetScore(int s) &#123; this-&gt;score = s; return score; &#125;&#125;;int main()&#123; Student A; cout&lt;&lt;A.SetScore(20)&lt;&lt;endl; cout&lt;&lt;A.SetNum(17001)&lt;&lt;endl; return 0;&#125; 数据封装 数据封装是一种把数据和操作数据的函数捆绑在一起的机制。C++程序中，任何带有公有和私有成员的类都可以作为数据封装和数据抽象的实例 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;class Adder//求和类 &#123; private: //对外隐藏的数据，数据隐藏 int total; public: Adder(int i=0) &#123; total = i; &#125; //对外接口 void addNum(int number) &#123; total += number; &#125; //对外接口 int getTotal() &#123; return total; &#125;&#125;;int main()&#123; Adder A; A.addNum(10); A.addNum(33); cout&lt;&lt;\"Total: \"&lt;&lt;A.getTotal()&lt;&lt;endl; return 0;&#125;/*- 公有成员addNum和getTotal是对外的接口，用户需要知道他们以便使用类。- 私有成员total是对外的隐藏，用户不需要了解它，但它又是类能正常工作所必须的。 */ 接口（抽象类）如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。抽象类是一种只能定义，不能生成对象的类。 抽象类不能用于实例化对象，只能作为接口使用 如果一个抽象类的子类需要被实例化，则必须实现每个虚函数。即必须在派生类中重载虚函数 接口描述了类的行为和功能，而不需要完成类的特定实现 用于实例化对象的类被称为具体类 抽象类的派类依然可以不完善基类中的纯虚函数，继续作为抽象类被派生，知道给出所有的纯虚函数定义，则成为一个具体类，才可以实例化对象 抽象类因为抽象、无法具化，所以不能作为参数类型、返回值、强转类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//example:#include&lt;iostream&gt;using namespace std;class Shape&#123; //基类 protected: int width; int height; public: //提供接口框架的纯虚函数 virtual int getArea() = 0; void setWidth(int w) &#123; this-&gt;width = w; &#125; void setHeight(int h) &#123; this-&gt;height = h; &#125; &#125;;//派生类 class Rectangle:public Shape&#123; public: int getArea() &#123; return width*height; &#125;&#125;;class Triangle:public Shape&#123; public: int getArea() &#123; return (width*height)/2; &#125;&#125;;int main()&#123; Rectangle A; //矩形 Triangle B; //三角形 A.setHeight(3); A.setWidth(4); B.setHeight(3); B.setWidth(4); cout&lt;&lt;&quot;Total Rectangle area: &quot;&lt;&lt;A.getArea()&lt;&lt;endl; cout&lt;&lt;&quot;Total Triangle area: &quot;&lt;&lt;B.getArea()&lt;&lt;endl; return 0; &#125; total 数据抽象是一种仅向用户暴露接口而把具体实现细节隐藏起来的一种机制 数据封装是一种把数据和操作数据的函数捆绑在一起的机制 抽象类作为接口使用，不能用于实例化对象","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"recording","slug":"recording","date":"2018-10-15T16:27:52.000Z","updated":"2018-10-17T08:51:19.577Z","comments":true,"path":"2018/10/16/recording/","link":"","permalink":"https://yeshan333.github.io/2018/10/16/recording/","excerpt":"辽宁一分钟harage","text":"辽宁一分钟harage 四川一分钟 湖北一分钟 西藏一分钟 云南一分钟 山东一分钟 河南一分钟 陕西一分钟 江西一分钟 深圳一分钟 宁夏一分钟 贵州一分钟 重庆一分钟 江苏一分钟","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://yeshan333.github.io/tags/随笔/"}]},{"title":"定向爬虫-中国大学MOOC-python网络爬虫实例","slug":"定向爬虫-中国大学MOOC-python网络爬虫实例","date":"2018-10-15T15:48:56.000Z","updated":"2019-03-23T09:13:26.509Z","comments":true,"path":"2018/10/15/定向爬虫-中国大学MOOC-python网络爬虫实例/","link":"","permalink":"https://yeshan333.github.io/2018/10/15/定向爬虫-中国大学MOOC-python网络爬虫实例/","excerpt":"定向爬虫:仅对输入URL进行爬取，不扩展爬取中国大学排名2018","text":"定向爬虫:仅对输入URL进行爬取，不扩展爬取中国大学排名2018 format格式化输出 看下所需信息位置 程序大体框架12345678910111213141516171819202122import requestsfrom bs4 import BeautifulSoupdef getHTMLText(url): return \"\"def fillUnivList(ulist,html): passdef printUnivList(ulist,num): print(\"Suc\"+str(num))def main(): uinfo = [] url = \"\" html = getHTMLText(url) fillUnivList(uinfo,html) printUnivList(uinfo,10)main() getHTMLText()12345678def GetHTMLText(url): #获取网页内容 try: r = requests.get(url) r.raise_for_status() #用于捕获异常 r.encoding = r.apparent_encoding return r.text except: return \"\" fillUnivList()12345678def fillUnivList(ulist, html): # 把网页内容放到数据结构中 soup = BeautifulSoup(html,\"html.parser\") '''一个tr标签存放一所大学的信息''' for tr in soup.find(\"tbody\").children: if isinstance(tr,bs4.element.Tag): #仅仅遍历标签,过滤掉非标签类型的其它信息 tds = tr('td') #将所有的td标签存放到列表tds中，等价于tr.find_all('td')返回一个列表类型 '''由于进行了遍历，使用print打印tds会得到多个列表''' ulist.append([tds[0].string, tds[1].string, tds[3].string])#向ulist中增加所需要的信息 printUnivList()12345def printUnivlist(ulist, num): print(\"&#123;:^10&#125;\\t&#123;:^6&#125;\\t&#123;:^10&#125;\".format(\"排名\",\"学校\",\"总分\")) for i in range(num): u = ulist[i] print(\"&#123;:^10&#125;\\t&#123;:^6&#125;\\t&#123;:^10&#125;\".format(u[0],u[1],u[2])) main12345678910111213141516171819202122232425262728293031323334353637import requestsimport bs4 # 用到instancefrom bs4 import BeautifulSoupdef GetHTMLText(url): #获取网页内容 try: r = requests.get(url) r.raise_for_status() #用于捕获异常 r.encoding = r.apparent_encoding return r.text except: return \"\"def fillUnivList(ulist, html): # 把网页内容放到数据结构中 soup = BeautifulSoup(html,\"html.parser\") '''一个tr标签存放一所大学的信息''' for tr in soup.find(\"tbody\").children: if isinstance(tr,bs4.element.Tag): #仅仅遍历标签,过滤掉非标签类型的其它信息 tds = tr('td') #将所有的td标签存放到列表tds中，等价于tr.find_all('td')返回一个列表类型 '''由于进行了遍历，使用print打印tds会得到多个列表''' ulist.append([tds[0].string, tds[1].string, tds[3].string])#向ulist中增加所需要的信息def printUnivlist(ulist, num): print(\"&#123;:^10&#125;\\t&#123;:^6&#125;\\t&#123;:^10&#125;\".format(\"排名\",\"学校\",\"总分\")) for i in range(num): u = ulist[i] print(\"&#123;:^10&#125;\\t&#123;:^6&#125;\\t&#123;:^10&#125;\".format(u[0],u[1],u[2]))def main(): uinfo = [] url = \"http://www.zuihaodaxue.cn/zuihaodaxuepaiming2018.html\" html = GetHTMLText(url) fillUnivList(uinfo,html) printUnivlist(uinfo,10)main() 代码优化，使用chr(12288)解决中文对齐问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsimport bs4 # 用到instancefrom bs4 import BeautifulSoupdef GetHTMLText(url): #获取网页内容 try: r = requests.get(url) r.raise_for_status() #用于捕获异常 r.encoding = r.apparent_encoding return r.text except: return \"\"def fillUnivList(ulist, html): # 把网页内容放到数据结构中 soup = BeautifulSoup(html,\"html.parser\") '''一个tr标签存放一所大学的信息''' for tr in soup.find(\"tbody\").children: if isinstance(tr,bs4.element.Tag): #仅仅遍历标签,过滤掉非标签类型的其它信息 tds = tr('td') #将所有的td标签存放到列表tds中，等价于tr.find_all('td')返回一个列表类型 '''由于进行了遍历，使用print打印tds会得到多个列表''' ulist.append([tds[0].string, tds[1].string, tds[3].string])#向ulist中增加所需要的信息'''def printUnivlist(ulist, num): print(\"&#123;:^10&#125;\\t&#123;:^6&#125;\\t&#123;:^10&#125;\".format(\"排名\",\"学校\",\"总分\")) for i in range(num): u = ulist[i] print(\"&#123;:^10&#125;\\t&#123;:^6&#125;\\t&#123;:^10&#125;\".format(u[0],u[1],u[2]))''''''优化输出格式，中文对齐问题,使用chr(12288)表示一个中文空格，utf-8编码'''def printUnivlist(ulist, num): tplt = \"&#123;0:^10&#125;\\t&#123;1:&#123;3&#125;^10&#125;\\t&#123;2:^10&#125;\" #输出模板，&#123;3&#125;使用format函数第三个变量进行填充，即使用中文空格进行填充 print(tplt.format(\"排名\",\"学校\",\"总分\",chr(12288))) for i in range(num): u = ulist[i] print(tplt.format(u[0],u[1],u[2],chr(12288)))def main(): uinfo = [] url = \"http://www.zuihaodaxue.cn/zuihaodaxuepaiming2018.html\" html = GetHTMLText(url) fillUnivList(uinfo,html) printUnivlist(uinfo,10)main()","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://yeshan333.github.io/tags/爬虫/"}]},{"title":"Eyes candy","slug":"Eyes-candy","date":"2018-10-15T15:28:16.000Z","updated":"2018-10-15T15:29:03.781Z","comments":true,"path":"2018/10/15/Eyes-candy/","link":"","permalink":"https://yeshan333.github.io/2018/10/15/Eyes-candy/","excerpt":"","text":"","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://yeshan333.github.io/tags/随笔/"}]},{"title":"C++面向对象-6","slug":"C++-面向对象-6","date":"2018-10-14T15:30:27.000Z","updated":"2018-11-23T19:18:22.819Z","comments":true,"path":"2018/10/14/C++-面向对象-6/","link":"","permalink":"https://yeshan333.github.io/2018/10/14/C++-面向对象-6/","excerpt":"C++多态C++的多态意味着调用成员函数时，会根据调用的对象的类型来执行不同的函数 编译时的多态，编译时就确定了具体的操作过程。运行时的多态，程序运行过程中才确定的操作过程。操作的过程即称为联编，也称为绑定。","text":"C++多态C++的多态意味着调用成员函数时，会根据调用的对象的类型来执行不同的函数 编译时的多态，编译时就确定了具体的操作过程。运行时的多态，程序运行过程中才确定的操作过程。操作的过程即称为联编，也称为绑定。 静态联编（早绑定），在编译和连接时确认的。比如函数重载，函数模板。效率高 动态联编（后期绑定），运行的时候才能确定是哪块代码段。灵活 静态联编函数调用在程序执行前就准备好了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#define PI 3.1415926using namespace std;class Point&#123; private: int x; int y; public: Point(int x=0,int y=0) &#123; this-&gt;x=x; this-&gt;y=y; &#125; double area() &#123; return 0.0; &#125;&#125;;class Circle: public Point&#123; private: int r; public: Circle(int x,int y,int R):Point(x,y)//基基类中有带参数的构造函数，派生类中的构造函数需要自定义 &#123; this-&gt;r=R; &#125; double area() &#123; return r*r*PI; &#125;&#125;;int main()&#123; Point A(3,3);//一个点 Circle B(3,3,3); //一个圆 cout&lt;&lt;A.area()&lt;&lt;endl; cout&lt;&lt;B.area()&lt;&lt;endl; Point *ptr; //Point类型的指针 ptr = &amp;B; //指向了Circle类型 cout&lt;&lt;ptr-&gt;area()&lt;&lt;endl;//输出结果不理想 return 0;&#125; 第三个cout输出0的原因:编译器在编译时就依据ptr的类型来执行那个are，指针ptr虽然指向了Circle类型的B，但是指针ptr为Point类型，所以执行Point类里的are方法。这里实行的即为静态编译。此时编译器看的是指针的类型而非内容。 动态编译使用虚函数进行动态联编。程序在任意点可以根据所调用的对象类型来选择调用的函数，这种操作即为动态联编，也成为后期绑定。 虚函数在基类中使用virtual关键字进行声明的函数。 virtual 函数返回值 函数名(形参) { 函数体 } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#define PI 3.1415926using namespace std;class Point&#123; private: int x; int y; public: Point(int x=0,int y=0) &#123; this-&gt;x=x; this-&gt;y=y; &#125; virtual double area() &#123; return 0.0; &#125;&#125;;class Circle: public Point&#123; private: int r; public: Circle(int x,int y,int R):Point(x,y)//基基类中有带参数的构造函数，派生类中的构造函数需要自定义 &#123; this-&gt;r=R; &#125; double area() &#123; return r*r*PI; &#125;&#125;;int main()&#123; Point A(3,3);//一个点 Circle B(3,3,3); //一个圆 cout&lt;&lt;A.area()&lt;&lt;endl; cout&lt;&lt;B.area()&lt;&lt;endl; Point *ptr; //Point类型的指针 ptr = &amp;B; cout&lt;&lt;ptr-&gt;area()&lt;&lt;endl; cout&lt;&lt;(*ptr).area()&lt;&lt;endl; return 0;&#125; 纯虚函数在基类中不能对虚函数给出有意义的实现，这时侯就使用到了纯虚函数。包含纯虚函数的类是抽象类。抽象类至少包含一个纯虚函数。 定义方式: virtual 返回值 函数名(形参) = 0; 虚析构函数 在C++中，不能把构造函数定义为虚构造函数，因为在实例化一个对象时才会调用构造函数，而且虚函数的实现，其实际本质是通过一个虚函数表指针来调用的，还没有对象更没有没内存空间当然无法调用，故没有实例化一个对象之前的构造函数没有意义也不能实现。析构函数可以为虚函数，而且大多数时候都声明为虚析构函数。这样就可以在基类的指针指向派生类的对象在释放时，可以根据所指向的对象类型动态联编调用子类的析构函数，实现真正的对象内存释放。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;class Point&#123; private: int x; int y; int *str; public: Point(int x=0,int y=0) &#123; this-&gt;x=x; this-&gt;y=y; str = new int[100]; &#125; ~Point() &#123; delete []str; cout&lt;&lt;\"Called Point's Destructor and Delete str !\"&lt;&lt;endl; &#125;&#125;;class Circle:public Point&#123; private: int r; int *str; public: Circle(int x,int y,int r):Point(x,y) &#123; this-&gt;r=r; str = new int[100]; &#125; ~Circle() &#123; delete []str; cout&lt;&lt;\"Called Circle's Destructor and Delete str !\"&lt;&lt;endl; &#125;&#125;;int main() &#123; Point *p; p = new Circle(10,10,20); delete p; return 0;&#125; 仅调用了基类的析构函数，这样一来派生类中new出来的4*100字节的内存就会残留，造成内存泄漏！","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"Just relax","slug":"Just-relax","date":"2018-10-13T15:44:56.000Z","updated":"2018-10-13T15:48:16.016Z","comments":true,"path":"2018/10/13/Just-relax/","link":"","permalink":"https://yeshan333.github.io/2018/10/13/Just-relax/","excerpt":"","text":"","categories":[],"tags":[{"name":"Astronomy","slug":"Astronomy","permalink":"https://yeshan333.github.io/tags/Astronomy/"}]},{"title":"C++面向对象-5","slug":"C++-面向对象-5","date":"2018-10-12T10:54:32.000Z","updated":"2018-11-23T19:18:12.747Z","comments":true,"path":"2018/10/12/C++-面向对象-5/","link":"","permalink":"https://yeshan333.github.io/2018/10/12/C++-面向对象-5/","excerpt":"派生类的构造函数attention: 在创建一个派生类的时候，系统会先创建一个基类。 派生类会吸收基类的全部成员，但不包括构造函数和析构函数。 派生类在调用自己的构造函数之前，会先调用基类的构造函数。","text":"派生类的构造函数attention: 在创建一个派生类的时候，系统会先创建一个基类。 派生类会吸收基类的全部成员，但不包括构造函数和析构函数。 派生类在调用自己的构造函数之前，会先调用基类的构造函数。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;class Clock&#123; private: int h; int m; int s; public: Clock() &#123; cout&lt;&lt;\"Clock's consturctor called !\"&lt;&lt;endl; &#125; &#125;;class AlarmClock:public Clock&#123; private: int ah; int am; int as; public: AlarmClock() &#123; cout&lt;&lt;\"AlarmClock's constructor called!\"&lt;&lt;endl; &#125;&#125;;int main()&#123; AlarmClock A; return 0;&#125; 当基类的构造函数带参的时候，派生类的构造函数应该这么定义： 派生类狗制造函数名字(总形参表列):基类构造函数(实参表类) //注意这里基类的构造函数用了是实际参数 一但基类中有带参数的构造函数，派生类则必须有显式传参的派生类构造函数，来实现基类中参数的传递，完成初始化工作1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;class Clock&#123; private: int h; int m; int s; public: Clock() &#123; cout&lt;&lt;\"Clock's constructor called\"&lt;&lt;endl; &#125; Clock(int h,int m,int s) &#123; cout&lt;&lt;\"Clock's consturctor with paramter called !\"&lt;&lt;endl; &#125; &#125;;class AlarmClock:public Clock&#123; private: int ah; int am; int as; public: AlarmClock() &#123; cout&lt;&lt;\"AlarmClock's constructor called!\"&lt;&lt;endl; &#125; AlarmClock(int h,int m,int s):Clock(h,m,s) &#123; cout&lt;&lt;\"AlarmClock's constructor with paramter called!\"&lt;&lt;endl; &#125; &#125;;int main()&#123; AlarmClock A; AlarmClock B(20,47,55); return 0;&#125; 派生类的析构函数构造函数调用顺序:基类-&gt;派生类析构函数调用顺序:派生类-&gt;基类 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;class Clock&#123; private: int h; int m; int s; public: Clock() &#123; cout&lt;&lt;\"Clock's consturctor called !\"&lt;&lt;endl; &#125; ~Clock() &#123; cout&lt;&lt;\"Clock's destructor called !\"&lt;&lt;endl; &#125; &#125;;class AlarmClock:public Clock&#123; private: int ah; int am; int as; public: AlarmClock() &#123; cout&lt;&lt;\"AlarmClock's constructor called !\"&lt;&lt;endl; &#125; ~AlarmClock() &#123; cout&lt;&lt;\"AlarmClock's destructor called !\"&lt;&lt;endl; &#125; &#125;;int main()&#123; AlarmClock A; return 0;&#125; 虚基类，使用virtual进行声明 虚继承的出现成为了解决多继承中二义性问题的一种方式 如果一个派生类有多个直接基类，而这些直接基类又有一个共同的基类，则在最终的派生类中会保留该间接共同基类数据成员的多份同名成员，这时就产生了二义性问题。 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;class grandfather&#123; public: int key;&#125;;class father_1:public grandfather &#123; &#125;;class father_2:public grandfather&#123;&#125;;class grandson:public father_1,public father_2&#123; &#125;;int main()&#123; grandson A; A.key = 10; //[Error] return 0;&#125; 在继承的时候在继承类型public之前用virtual修饰一下 虚基类并不是在声明基类时声明的，而是在声明派生类时，指定继承方式时声明的。 为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类。否则仍然会出现对基类的多次继承。 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;class grandfather&#123; public: int key;&#125;;class father_1:virtual public grandfather &#123; &#125;;class father_2:virtual public grandfather&#123;&#125;;class grandson:public father_1,public father_2&#123; &#125;;int main()&#123; grandson A; A.key = 10; printf(\"%d\",A.key); return 0;&#125; https://www.cnblogs.com/yiranlaobaitu/p/3764422.htmlhttps://blog.csdn.net/bxw1992/article/details/77726390","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"XXX","slug":"XXX","date":"2018-10-12T08:07:01.000Z","updated":"2018-10-12T08:09:52.271Z","comments":true,"path":"2018/10/12/XXX/","link":"","permalink":"https://yeshan333.github.io/2018/10/12/XXX/","excerpt":"","text":"","categories":[],"tags":[{"name":"Astronomy","slug":"Astronomy","permalink":"https://yeshan333.github.io/tags/Astronomy/"}]},{"title":"信息标记","slug":"信息标记","date":"2018-10-11T16:43:58.000Z","updated":"2018-12-31T16:00:00.000Z","comments":true,"path":"2018/10/12/信息标记/","link":"","permalink":"https://yeshan333.github.io/2018/10/12/信息标记/","excerpt":"信息标记的三种形式 XML(eXtensible Markup Language) YAML(YAML Ain’t Markup Language) JSON(JaveScript Object Notation)","text":"信息标记的三种形式 XML(eXtensible Markup Language) YAML(YAML Ain’t Markup Language) JSON(JaveScript Object Notation) XML使用标签标记信息的表达形式1234567891011&lt;people&gt; &lt;!--这是注释--&gt; &lt;firstname&gt;Shan&lt;/firstname&gt; &lt;lastname&gt;Ye&lt;/lastname&gt; &lt;address&gt; &lt;streetAddre&gt;None&lt;/streetAddre&gt; &lt;city&gt;Gui Lin&lt;/city&gt; &lt;zipcode&gt;541004&lt;/zipcode&gt; &lt;/address&gt; &lt;prof&gt;boy&lt;/prof&gt;&lt;prof&gt;boring&lt;/prof&gt;&lt;/people&gt; JSON有类型键值对标记信息的表达形式1234567891011&#123; \"firstname\": \"Shan\", \"lastname\" : \"Ye\", \"address\": &#123; \"streetAddre\":\"None\", \"city\": \"Gui Lin\", \"zipcode\": \"541004\" &#125; &#125; YML无类型键值对标记信息的表达形式 1234567891011121314firstname: Shanlastname: Yeaddress: #缩进表达所属关系 streetAddre: None city: Gui Lin zipcode: 541004prof: #this is a comment-boy #并列关系-boringtext: | #整块数据ACM国际大学生程序设计竞赛（英文全称：ACM International Collegiate Programming Contest（简称ACM-ICPC或ICPC））是由国际计算机协会（ACM）主办的，一项旨在展示大学生创新能力、团队精神和在压力下编写程序、分析和解决问题能力的年度竞赛。经过近40年的发展，ACM国际大学生程序设计竞赛已经发展成为全球最具影响力的大学生程序设计竞赛。赛事目前由IBM公司赞助。 123456789101112131415'''提取HTMl中的所有信息（1）搜索到所有的&lt;a&gt;标签（2）解析&lt;a&gt;标签格式，提取href后的链接内容'''import requestsfrom bs4 import BeautifulSoupurl = \"http://python123.io/ws/demo.html\"r = requests.get(url)demo = r.textsoup = BeautifulSoup(demo,\"html.parser\")for link in soup.find_all('a'): print(link.get(\"href\")) 基于bs4库的信息提取的一般方法&lt;&gt;.find_all()方法&lt;&gt;.find_all(name,attrs,recursive,string,**kwargs) name: 对应标签名称的检索字符串 attrs:对应标签属性值的检索字符串，可标注属性检索 recursive：是否对子孙全部检索，默认为True string：...字符串区域的检索字符串 soup.find_all(...)等价于soup(...) .find_all(...)等价于(...) 扩展方法 方法 说明 &lt;&gt;.find() 搜索且只返回一个结果，同.find_all()参数 &lt;&gt;.find_parents() 在先辈节点中搜索，返回列表类型，同.find_all()参数 &lt;&gt;.find_parent() 在先辈节点中返回一个结果，同.find()参数 &lt;&gt;.find_next_siblings() 在后续平行节点中搜索，返回一个列表，同.find_all()参数 &lt;&gt;.find_next_sibling() 在后续节点中返回一个结果，用.find()参数 &lt;&gt;find_previous_siblings() 在前续平行结点中搜索，返回列表类型，同.find_all()参数 &lt;&gt;find.previous_sibling() 在前续节点中返回一个节点，同.find()参数","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://yeshan333.github.io/tags/爬虫/"},{"name":"信息标记","slug":"信息标记","permalink":"https://yeshan333.github.io/tags/信息标记/"}]},{"title":"C++面向对象-4","slug":"C++-面向对象-4","date":"2018-10-10T16:40:05.000Z","updated":"2018-11-23T19:17:48.814Z","comments":true,"path":"2018/10/11/C++-面向对象-4/","link":"","permalink":"https://yeshan333.github.io/2018/10/11/C++-面向对象-4/","excerpt":"继承和派生 新类拥有原有类的全部属性为继承！原有类产生新类的过程为派生。 原有类称为基类，产生的新类称为派生类。http://www.dotcpp.com/course/cpp/200027.html 继承方式（派生权限） 公有继承 私有继承 保护继承","text":"继承和派生 新类拥有原有类的全部属性为继承！原有类产生新类的过程为派生。 原有类称为基类，产生的新类称为派生类。http://www.dotcpp.com/course/cpp/200027.html 继承方式（派生权限） 公有继承 私有继承 保护继承 公有继承 基类中的公有成员，在派生类中仍然为公有成员。无论派生类的成员函数还是成员对象都可以访问。 基类中的私有成员，无论在派生类的成员还是派生类对象都不可以访问。 基类中的保护成员，在派生类中仍然是保护类型，可以通过派生类的成员函数访问，但派生类对象不可以访问！ 私有继承 基类中的公有和受保护类型，被派生类私有吸收后，都变为派生类的私有类型，即在类的成员函数里可以访问，不能在类外访问。 基类的私有成员，在派生类类内和类外都不可以访问。 保护继承 基类的公共成员和保护类型成员在派生类中为保护成员。 基类的私有成员在派生类中不能被直接访问。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;class Student //基类 &#123; private: int number; public: int Set(int number) &#123; this-&gt;number=number; return 0; &#125; int Show() &#123; cout&lt;&lt;\"he or she number:\"&lt;&lt;number&lt;&lt;endl; &#125;&#125;;class Score:public Student //公有继承，派生类 &#123; private: int score; public: int set_score(int score) &#123; this-&gt;score=score; return 0; &#125; int show_score() &#123; cout&lt;&lt;\"the score is :\"&lt;&lt;score&lt;&lt;endl; return 0; &#125; &#125;;int main()&#123; Score A; A.Set(17007101); A.Show(); A.set_score(99); A.show_score(); return 0;&#125; 多继承一个子类可以有多个父类，继承多个父类的特性 class &lt;派生类名&gt;:&lt;继承方式&gt;&lt;基类名1&gt;,&lt;继承方式&gt;&lt;基类名2&gt;,…{派生类类体} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;using namespace std;class Shape&#123; public: void setWidth(int w) &#123; width = w; &#125; void setHight(int h) &#123; height = h; &#125; protected: int width; int height;&#125;;class PaintCost &#123; public: int GetCost(int area) &#123; return area*70; &#125; &#125;;class Rectangle: public Shape,public PaintCost //派生类 &#123; public: int getArea() &#123; return (width*height); &#125;&#125;;int main()&#123; Rectangle Rect; int area; Rect.setWidth(10); Rect.setHight(3); area = Rect.getArea(); //输出对象面积 cout&lt;&lt;\"Total area: \"&lt;&lt;Rect.getArea()&lt;&lt;endl; //输出总花费 cout&lt;&lt;\"Total paint cost: \"&lt;&lt;Rect.GetCost(area)&lt;&lt;endl; return 0; &#125;","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"浅尝BeautifulSoup","slug":"浅尝BeautifulSoup","date":"2018-10-10T10:03:59.000Z","updated":"2019-03-23T09:12:43.990Z","comments":true,"path":"2018/10/10/浅尝BeautifulSoup/","link":"","permalink":"https://yeshan333.github.io/2018/10/10/浅尝BeautifulSoup/","excerpt":"12345678910111213141516import requestsfrom bs4 import BeautifulSoup #引入BeautifulSoup类url = \"https://python123.io/ws/demo.html\"r = requests.get(url)print(r.status_code)print(\"\\n\")#demo = r.text #html格式信息#soup = BeautifulSoup(demo,\"html.parser\")#使用html.parser对demo进行html解析soup = BeautifulSoup(open(r\"C:\\Users\\Administrator\\Desktop\\beautifulsoup\\demo.html\"))print(soup.prettify()) BeautifulSoup官方文档","text":"12345678910111213141516import requestsfrom bs4 import BeautifulSoup #引入BeautifulSoup类url = \"https://python123.io/ws/demo.html\"r = requests.get(url)print(r.status_code)print(\"\\n\")#demo = r.text #html格式信息#soup = BeautifulSoup(demo,\"html.parser\")#使用html.parser对demo进行html解析soup = BeautifulSoup(open(r\"C:\\Users\\Administrator\\Desktop\\beautifulsoup\\demo.html\"))print(soup.prettify()) BeautifulSoup官方文档 BeautifulSoup库解析器 解析器 使用方法 条件 bs4的HTML解析器 beautiful(mk,”html.parser”) 安装bs4库 lxml的HTML解析器 BeautifulSoup(mk,”lxml”) 安装lxml库 lxml的xml解析器 BeautifulSoup(mk,”xml”) 安装lxml库 html5lib的解析器 BeautifulSoup(mk,”html5lib”) 安装html5lib库 BeautifulSoup库的基本元素 基本元素 说明 Tag 标签，最基本的信息组织单元，分别用标明开头和结尾 Name 标签的名字，&lt;p&gt;...&lt;/p&gt;的名字是‘p’,格式:&lt;tag&gt;.name Attributes 标签的属性,字典形式组织，格式:&lt;tag&gt;.attrs NavigableString 标签内非属性字符串,...中字符串，格式:&lt;tag&gt;.string Comment 标签内字符串的注释部分，一种特殊的Comment类型 1234567891011# Tag的Comment元素from bs4 import BeautifulSoupsoup = BeautifulSoup(\"&lt;b&gt;&lt;!--This is a comment--&gt;&lt;/b&gt;&lt;p&gt;This is not a comment&lt;/p&gt;\",\"html.parser\")print(soup.b.string)print(type(soup.b.string))print(soup.p.string)print(type(soup.p.string)) BeautifulSoup对应一个HTML/XML文档的全部内容 任何存在于HTMl语法中的标签都可以用soup.&lt;tag&gt;访问获得，当HTML文档中存在多个相同&lt;tag&gt;对应内容时，soup.&lt;tag&gt;返回第一个 每个&lt;tag&gt;都有自己的名字，通过&lt;tag&gt;.name获取，字符串类型 一个&lt;tag&gt;可以有0或多个属性，字典类型 NavigableString可以跨越多个层次 基于bs4库的HTML内容遍历方法 标签数的下行遍历 属性 说明 .contents 子节点的列表，将所有儿子节点存人列表 .children 子节点的迭代类型，于.contents类似，用于循环遍历儿子节点 .descendants 子孙节点的迭代类型，包含所有子孙节点，用于循环遍历 123456789101112131415161718# 标签树的下行遍历import requestsfrom bs4 import BeautifulSoupurl = \"https://python123.io/ws/demo.html\"r = requests.get(url)demo = r.textsoup = BeautifulSoup(demo,\"html.parser\")'''for child in soup.body.children: #遍历儿子节点 print(child)'''for child in soup.body.descendants: #遍历子孙节点 print(child) 标签树的上行遍历 属性 说明 .parent 节点的父亲标签 .parents 节点先辈标签的的迭代类型，用于循环遍历先辈节点 1234567891011121314151617# 标签树的上行遍历import requestsfrom bs4 import BeautifulSoupurl = \"https://python123.io/ws/demo.html\"r = requests.get(url)demo = r.textsoup = BeautifulSoup(demo,\"html.parser\")for parent in soup.a.parents: #遍历所有先辈节点，包括soup本身，soup的先辈不存在name信息 if parent is None: print(parent) else: print(parent.name) 标签树的平行遍历平行遍历发生在同一个父节点下的各节点之间 属性 说明 .next_sibling 返回按照HTML文本顺序的下一个平行节点标签 .previous_sibling 返回按照HTML文本顺序的上一个平行节点标签 .next_siblings 迭代类型，返回按照HTML文本顺序的后续所有平行节点标签 .previous_siblings 迭代类型，返回按照HTML文本顺序的前续所有平行节点标签 123456789101112131415161718# 标签树的平行遍历import requestsfrom bs4 import BeautifulSoupurl = \"https://python123.io/ws/demo.html\"r = requests.get(url)demo = r.textsoup = BeautifulSoup(demo,\"html.parser\")for sibling in soup.a.next_sibling: print(sibling) #遍历后续节点'''for sibling in soup.a.previous_sibling: print(sibling) #遍历前续节点''' 基于bs4库的HTML格式输出—-prettify()方法 .prettify()为HTML文本&lt;&gt;及其内容增加’\\n’ .prettify()可用于标签,方法:&lt;tag&gt;.perttify() bs4库将任何HTML输入都变成utf-8编码","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://yeshan333.github.io/tags/爬虫/"},{"name":"BeautifulSoup","slug":"BeautifulSoup","permalink":"https://yeshan333.github.io/tags/BeautifulSoup/"}]},{"title":"C++面向对象-3","slug":"C++-面向对象-3","date":"2018-10-08T16:12:54.000Z","updated":"2018-11-23T19:17:32.909Z","comments":true,"path":"2018/10/09/C++-面向对象-3/","link":"","permalink":"https://yeshan333.github.io/2018/10/09/C++-面向对象-3/","excerpt":"友元函数和友元类 友元的对象可以是全局的一般函数，也可以是其它类里的成员函数，这种叫做友元函数。友元还可以是一个类，这种叫做友元类，这时整个类的所有成员都是友元","text":"友元函数和友元类 友元的对象可以是全局的一般函数，也可以是其它类里的成员函数，这种叫做友元函数。友元还可以是一个类，这种叫做友元类，这时整个类的所有成员都是友元 一、友元函数 类的友元函数定义在类的外部，但是有权访问类的所有私有成员和保护成员。但友元函数并不是成员函数。 有元函数的声明使用friend关键字 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;class Point&#123; private: double x; double y; public: Point(double a,double b) //Constructor &#123; x=a; y=b; &#125; int GetPoint() &#123; cout&lt;&lt;\"(\"&lt;&lt;x&lt;&lt;\",\"&lt;&lt;y&lt;&lt;\")\"&lt;&lt;endl; return 0; &#125; friend double Distance(Point &amp;a,Point &amp;b);//声明友元函数 &#125;;double Distance(Point &amp;a,Point&amp;b)&#123; double xx; double yy; xx = a.x-b.x; yy = a.y-b.y; return sqrt(xx*xx+yy*yy); &#125; int main()&#123; Point A(2.0,3.0); Point B(1.0,2.0); A.GetPoint(); B.GetPoint(); double dis; dis = Distance(A,B); cout&lt;&lt;dis&lt;&lt;endl; return 0;&#125; 友元函数没有this指针，参数的情况； 要访问非static成员时，需要对象做参数 要访问static成员或全局变量时，则不需要对象做参数 如果做参数的对象时全局对象，则不需要对象做参数，可直接调用友元函数，不需要通过对象或指针。 二、友元类把一个类A声明为另一个类B的友元类,则类A中的所有成员函数都可以访问类B中的成员。在类B中声明即可。 friend class A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;Cmath&gt;using namespace std;class Point&#123; private: double x; double y; public: Point(double a,double b)//Constructor &#123; x=a; y=b; &#125; int GetPoint() &#123; cout&lt;&lt;\"(\"&lt;&lt;x&lt;&lt;\",\"&lt;&lt;y&lt;&lt;\")\"&lt;&lt;endl; return 0; &#125; friend class Tool;//声明友元类 &#125;;class Tool&#123; public: double Get_x(Point &amp;A ) &#123; return A.x; &#125; double Get_y(Point &amp;A) &#123; return A.y; &#125; double Distance(Point &amp;A) //求一点到原点的距离 &#123; cout&lt;&lt;sqrt(A.x*A.x+A.y*A.y)&lt;&lt;endl; return sqrt(A.x*A.x+A.y*A.y); &#125;&#125; ;int main()&#123; Point A(3.0,3.0); A.GetPoint(); Tool T; T.Get_x(A); T.Get_y(A); T.Distance(A); return 0;&#125;","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"C++面向对象-2","slug":"C++-面向对象-2","date":"2018-10-06T08:20:16.000Z","updated":"2018-11-23T19:17:21.904Z","comments":true,"path":"2018/10/06/C++-面向对象-2/","link":"","permalink":"https://yeshan333.github.io/2018/10/06/C++-面向对象-2/","excerpt":"类的构造函数(Constructor)和析构函数(Destructor)","text":"类的构造函数(Constructor)和析构函数(Destructor) 构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会反回任何类型，也不会反回void。 析构函数也是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。函数名称与类的名称完全相同，只是在前面加了个~波浪线作为前缀，它不会返回任何值，也不能带有任何参数。 1.构造函数（Constructor）&ensp; 当我们定义一个类的对象时，系统就会自动调用它，进行专门的初始化对象用。如果我们没有定义构造函数，系统会默认生成一个默认形式，隐藏着的构造函数，这个构造函数的函数体是空的，它不具有任何功能。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;Cstring&gt;using namespace std;class Student&#123; private: int num; char name[100]; int score; public: Student(int n,char *str,int s); int print(); int Set(int n,char *str,int s); &#125;;Student::Student(int n,char *str,int s)//定义了一个带默认参数的构造函数 &#123; num=n; strcpy(name,str); score=s; cout&lt;&lt;\"Constructor\"&lt;&lt;endl; &#125;int Student::print()&#123; cout&lt;&lt;num&lt;&lt;\" \"&lt;&lt;name&lt;&lt;\" \"&lt;&lt;score; return 0;&#125;int Student::Set(int n,char *str,int s)&#123; num=n; strcpy(name,str); score=s;&#125;int main()&#123; Student A(1700710135,\"yeshan\",99); A.print(); //Student C;这样定义对象会报错，因为我们在类中定义了一个带默认参数的构造函数 cout&lt;&lt;endl; Student B(1700710134,\"xu jie\",100); B.print(); return 0;&#125; 由于在程序中定义了一个带默认参数的构造函数，则系统不会再自动生成，这个时候定义对象时也要传入三个默认初始值，因为构造函数可以重载，可以有多个兄弟，系统会找最匹配的一个函数 2.析构函数（Destructor）&ensp;对象销毁时自动调用的一个函数，析构函数不能重载，一个类只能有一个析构函数，析构函数有助于跳出程序前释放内存。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;Cstring&gt;using namespace std;class Student&#123; private: int num; char name[100]; int score; public: Student(int n,char *str,int s); ~Student(); int print(); int Set(int n,char *str,int s); &#125;;Student::Student(int n,char *str,int s)//构造函数 &#123; num=n; strcpy(name,str); score=s; cout&lt;&lt;num&lt;&lt;\" \"&lt;&lt;name&lt;&lt;\" \"&lt;&lt;score&lt;&lt;\" \"; cout&lt;&lt;\"Constructor\"&lt;&lt;endl;&#125; Student::~Student()//析构函数 &#123; cout&lt;&lt;num&lt;&lt;\" \"&lt;&lt;name&lt;&lt;\" \"&lt;&lt;score&lt;&lt;\" \"; cout&lt;&lt;\"destructor\"&lt;&lt;endl;&#125;int Student::print()&#123; cout&lt;&lt;num&lt;&lt;\" \"&lt;&lt;name&lt;&lt;\" \"&lt;&lt;score&lt;&lt;endl; return 0;&#125;int Student::Set(int n,char *str,int s)&#123; num=n; strcpy(name,str); score=s;&#125;int main()&#123; Student A(100,\"dot\",11); Student B(101,\"cpp\",12); return 0;&#125; 对象A和B的构造函数的调用顺序以及构造函数的调用顺序，完全相反！原因在于A和B对象同属局部对象，也在栈区存储，也遵循“先进后出”的顺序！ 拷贝构造函数 拷贝构造函数是一种特殊的构造函数，具有单个形参，该形参（常用const修饰）是对该类类型的引用。它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。当定义一个新对象并用同一个类型的对象对它进行初始化时，将显示使用拷贝构造函。只包含类类型成员或内置类型（但不是指针类型）成员的类，无须显式地定义拷贝构造函数也可以拷贝。 显示定义拷贝构造函数的情况： 类有数据成员是指针； 有成员表示在构造函数中分配的其他资源 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;using namespace std;class Age&#123; public: int GetAge(void); Age(int age); //Constructor Age(const Age&amp; A); //Copy Constructor ~Age(); //Desconstructor private: int *ptr;&#125;;Age::Age(int age)&#123; cout&lt;&lt;\"调用构造函数\"&lt;&lt;endl; ptr = new int;//为指针分配内存 *ptr = age; &#125;Age::Age(const Age&amp; A)&#123; cout&lt;&lt;\"调用拷贝构造函数，并为指针ptr分配内存\"&lt;&lt;endl; ptr = new int; *ptr = *A.ptr; //拷贝值 &#125;Age::~Age()&#123; cout&lt;&lt;\"释放内存\"&lt;&lt;endl; delete ptr;&#125; int Age::GetAge(void)&#123; return *ptr; &#125;void print_age(Age A)&#123; cout&lt;&lt;\"the age: \"&lt;&lt;A.GetAge()&lt;&lt;endl; //这里也调用了拷贝构造函数&#125;int main()&#123; Age member_1(10); Age member_2(member_2);//相当于Age member_2 = member_1; return 0; &#125; 成员变量中加一个了指针成员，初始化中需要动态开辟内存，如果不自定义拷贝构造函数，而是用默认生成的，则会出现极大的安全隐患。默认的拷贝构造函数仅仅是进行数值赋值，并不能为指针开辟内存空间。相当于代码This-&gt;str=str.本质上也就是两个指针指向了一块堆空间。程序结束回收对象的时候，会调用自己的析构函数，释放这块内存空间，由于两个对象要调用两次，即delete两次，就会出现错误 [引自](http://www.dotcpp.com/course/cpp/200020.html) C++中的this指针对象中隐藏的指针 每一个对象都能通过this指针来访问自己的地址。this指针是所有成员函数额隐含参数。因此在成员函数内部，它可以用来指向调用的对象。 如果程序中有多个属于同一类的对象，因成员函数的代码仅有一份，所以为了区分它们是哪个对象调用的成员函数，编译器也是转化成this-&gt;成员函数这种形式来使用的。 友元函数没有this指针，因为友元不是类的成员。只有成员函数才有this指针。 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;class Age&#123; public: Age(int your_age=18) //Constructor function &#123; cout&lt;&lt;\"Constructor now\"&lt;&lt;endl; age=your_age; &#125; int GetAge() &#123; return age; &#125; int compare(Age member) &#123; return this-&gt;GetAge()&gt;member.GetAge(); //看这里 &#125; private: int age;&#125;;int main()&#123; Age member_1(20),member_2(24); if(member_1.compare(member_2)) &#123; cout&lt;&lt;\"member_1 is older than member_2\"&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;\"member_1 is younger than member_2\"&lt;&lt;endl; &#125;&#125; 关键字new和delete new（新建）用于新建一个对象。new 运算符总是返回一个指针。由 new 创建。 delete（删除）释放程序动态申请的内存空间。delete 后面通常是一个指针或者数组 []，并且只能 delete 通过 new 关键字申请的指针。","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"C++面向对象","slug":"C++-面向对象","date":"2018-10-05T15:15:07.000Z","updated":"2018-11-23T19:17:11.790Z","comments":true,"path":"2018/10/05/C++-面向对象/","link":"","permalink":"https://yeshan333.github.io/2018/10/05/C++-面向对象/","excerpt":"类 &amp; 对象 类是对象的抽象和概括，而对象是类的具体和实例","text":"类 &amp; 对象 类是对象的抽象和概括，而对象是类的具体和实例 类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。 类中的数据和方法称为类的成员。(成员有变量也有函数，分别成为类的属性和方法) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;Cstring&gt;using namespace std;/*class Student&#123; public: int num; char name[100]; int score; int print() &#123; cout&lt;&lt;num&lt;&lt;\" \"&lt;&lt;name&lt;&lt;\" \"&lt;&lt;score; return 0; &#125; &#125;;*/class Student&#123; public: int num; char name[100]; int score; int print(); &#125;; int Student::print()&#123; cout&lt;&lt;num&lt;&lt;\" \"&lt;&lt;name&lt;&lt;\" \"&lt;&lt;score; return 0; &#125; int main()&#123; Student A; A.num=1700710135; strcpy(A.name,\"ye shan\"); A.score=100; //A.print(); //Student *Ap; //Ap=&amp;A; //Ap-&gt;print(); Student&amp; A_reference=A; //引用定义时就要初始化 //A_reference=A; 错误 A_reference.print(); return 0;&#125; 类的定义 定义一个类，本质上是定义一个数据类型的蓝图。它定义类的对象包括了什么，以及可以在这个对象上执行哪些操作。 类的定义以关键字class开头，后面跟类的名称。类的主体包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。 写法1成员函数定义在在类里123456789101112class Student&#123; public: //声明公有成员，可被类的任何对象访问 int num; char name[100]; int score; int print() &#123; cout&lt;&lt;num&lt;&lt;\" \"&lt;&lt;name&lt;&lt;\" \"&lt;&lt;score; return 0; &#125; &#125;; 写法2成员函数定义在类外，使用范围解析运算符(作用域限定符):: 在::限定符前必须使用类名1234567891011121314class Student&#123; public: int num; char name[100]; int score; int print(); &#125;; int Student::print()&#123; cout&lt;&lt;num&lt;&lt;\" \"&lt;&lt;name&lt;&lt;\" \"&lt;&lt;score; return 0; &#125; 对象的建立和使用 类就是包含函数的结构体，是一种自定义数据类型，用它定义出来变量，就是对象，这就是所谓的“对象是类的具体和实例”，定义了一个这个类的对象，也可以说实例化了一个对象，就是这个意思！ 声明类的对象，就像声明基本的变量类型一样 访问公共数据成员可以使用直接成员访问运算符.来访问 Student A; //声明A，类型为Student A.num=1700710135; strcpy(name,&quot;ye shan&quot;); A.score=100; A.print(); 类的访问修饰符 private protected public 成员和类的默认访问修饰符是private&ensp; 私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。 保护成员修饰符protected，保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员变量在派生类（即子类）中是可以访问的。 公有成员在程序中类的外部是可以访问的。可以在不适用任何成员函数来设置和获取公有变量的值 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;Cstring&gt;using namespace std;class Student&#123; private: int num; protected: int score; public: char name[100]; int GetNum(int n); int GetScore(int s);&#125;;int Student::GetNum(int n)&#123; num=n; return num;&#125; int Student::GetScore(int s)&#123; score=s; return score;&#125;int main()&#123; Student A; strcpy(A.name,\"yeshan\"); cout&lt;&lt;\"the name is\"&lt;&lt;\" \"&lt;&lt;A.name&lt;&lt;endl; //A.num=1700710135，成员num是稀有的，不可这样用 cout&lt;&lt;\"the num is\"&lt;&lt;\" \"&lt;&lt;A.GetNum(1700710135)&lt;&lt;endl; cout&lt;&lt;\"the score is\"&lt;&lt;\" \"&lt;&lt;A.GetScore(100)&lt;&lt;endl; return 0; &#125; 派生类中使用protected成员变量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;Cstring&gt;using namespace std;class Student&#123; private: int num; protected: int score; public: char name[100]; int GetNum(int n); int GetScore(int s);&#125;;class Small_Student:Student//Small_Student是派生类 &#123; public: int Get_Score_1(int temp); &#125;; int Small_Student::Get_Score_1(int temp) //子类成员函数 &#123; score=temp; return score;&#125; int Student::GetNum(int n)&#123; num=n; return num;&#125; int Student::GetScore(int s)&#123; score=s; return score;&#125;int main()&#123; Student A; strcpy(A.name,\"yeshan\"); cout&lt;&lt;\"the name is\"&lt;&lt;\" \"&lt;&lt;A.name&lt;&lt;endl; //A.num=1700710135，成员num是稀有的，不可这样用 cout&lt;&lt;\"the num is\"&lt;&lt;\" \"&lt;&lt;A.GetNum(1700710135)&lt;&lt;endl; cout&lt;&lt;\"the score is\"&lt;&lt;\" \"&lt;&lt;A.GetScore(100)&lt;&lt;endl; Small_Student B; cout&lt;&lt;\"the score is\"&lt;&lt;\" \"&lt;&lt;B.Get_Score_1(520)&lt;&lt;endl; return 0; &#125; 类的静态成员使用static关键字把类成员定义为静态的 静态成员数据 静态成员在类的所有对象中是共享的。如果不存在其它初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。 不能把静态成员放置在类的定义中，但是可以在类的外部通过使用范围解析运算符::来重新声明静态变量，从而对它进行初始化。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;class Area&#123; private: double length; double width; public: static int object_count; Area(double x,double y) &#123; length = x; width = y; object_count++;//每次创建对象时加一 &#125; double Print_Area() &#123; return length*width; &#125;&#125;;int Area::object_count=0;//初始化类Area的静态成员 int main()&#123; Area number_1(3,4); Area number_2(5,6); cout&lt;&lt;\"creat \"&lt;&lt;Area::object_count&lt;&lt;\" object\"&lt;&lt;endl; //使用 类名+范围解析运算符::+静态成员变量 访问静态成员数据 cout&lt;&lt;\"the area of number_1 is \"&lt;&lt;number_1.Print_Area(); &#125; 静态成员函数 静态成员函数即使在类对象不存在的情况下也能被调用。 静态成员函数只能访问静态数据成员，不能访问其他静态成员函数和类外部的函数 静态成员函数有一个类范围，他们不能访问类的this指针。可以用静态成员函数来判断某些对象是否已被创建。 调用时使用 类名+范围解析运算符+静态成员函数名 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;class Area&#123; private: double length; double width; public: static int object_count; //静态成员数据 static int get_count() //静态成员函数 &#123; return object_count; &#125; Area(double x,double y) &#123; cout&lt;&lt;\"Constructor\"&lt;&lt;endl; length = x; width = y; object_count++;//每次创建对象时加一 &#125; double Print_Area() &#123; return length*width; &#125;&#125;;int Area::object_count=0;//初始化类Area的静态成员 int main()&#123; cout&lt;&lt;\"number of objects:\"&lt;&lt;Area::get_count()&lt;&lt;endl; Area number_1(3,4); Area number_2(5,6); cout&lt;&lt;\"after creat object ,number of objects:\"&lt;&lt;Area::get_count()&lt;&lt;endl; return 0;&#125;","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"C++入坑记(3)","slug":"C++-入坑记-3","date":"2018-10-04T12:44:06.000Z","updated":"2018-11-23T19:19:22.992Z","comments":true,"path":"2018/10/04/C++-入坑记-3/","link":"","permalink":"https://yeshan333.github.io/2018/10/04/C++-入坑记-3/","excerpt":"变量初始化问题当局部变量被定义时，系统不会自动对其初始化；当全局变量被定义时，系统会初始化为下列值: 数据类型 初始化默认值 int 0 float 0 double 0 char ‘\\0’ pointer NULL","text":"变量初始化问题当局部变量被定义时，系统不会自动对其初始化；当全局变量被定义时，系统会初始化为下列值: 数据类型 初始化默认值 int 0 float 0 double 0 char ‘\\0’ pointer NULL C++储存类 auto static extern register mutable thread_local static储存类 用于指示编译器在程序的生命周期内保持局部变量的存在，而不需要每次在它进入和离开作用域时进行创建和销毁。 static修饰局部变量，可以在函数调用之间保持局部变量的值 static修饰全局变量，会使变量的作用域限制在生明它的文件内参考 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;static int count=10; //全局变量 void func()&#123; static int i=5; //局部静态变量 i++; cout&lt;&lt;\"变量i为:\"&lt;&lt;i; cout&lt;&lt;\",变量count为:\"&lt;&lt;count&lt;&lt;endl; &#125;int main() &#123; while(count--) &#123; func(); &#125; return 0;&#125; extern储存类 用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。使用extern时，对于无法初始化的变量，会把变量名指向一个之前已经定义过的存储位置。当有多个文件且定义了一个就可在其他文件中使用的全局变量或函数时，可以在其他文件中使用extern来得到已定义的变量或函数的引用。 C++引用 引用变量是一个别名。它是某个已存在的变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量 引用与指针的差别 不存在空引用，引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 引用可以当成变量附属在内存的第二个标签 int i; //为i声明一个引用变量 int&amp; r=i; 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;int main()&#123; int i; double d; //声明引用变量 int&amp; r=i; double&amp; s=d; i=3; cout&lt;&lt;\"Value of i：\"&lt;&lt;i&lt;&lt;endl; cout&lt;&lt;\"Value of i reference:：\"&lt;&lt;r&lt;&lt;endl; d=5.20; cout&lt;&lt;\"d= \"&lt;&lt;d&lt;&lt;endl; cout&lt;&lt;\"Value of d reference：\"&lt;&lt;s&lt;&lt;endl; return 0; &#125; 用引用做函数形参12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;void swap(int&amp; x,int&amp; y)&#123; int temp; temp = x; x = y; y = temp;&#125;int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;\"a=\"&lt;&lt;a&lt;&lt;\" \"&lt;&lt;\"b=\"&lt;&lt;b&lt;&lt;endl; swap(a,b); cout&lt;&lt;\"after exchange:\"&lt;&lt;endl; cout&lt;&lt;\"a=\"&lt;&lt;a&lt;&lt;\" b=\"&lt;&lt;b&lt;&lt;endl; return 0; &#125; 引用做返回值当函数返回一个引用时，则返回一个指向返回值的隐式指针。 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;ctime&gt; using namespace std;int vals[]=&#123;1,2,3,4,5&#125;;int&amp; setValues(int i)&#123; return vals[i];//返回第i个元素的引用 &#125;int main()&#123; cout&lt;&lt;\"before change:\"&lt;&lt;endl; for(int i=0;i&lt;5;i++) &#123; cout&lt;&lt;vals[i]&lt;&lt;\" \"; &#125; setValues(1)=520; //change the second value setValues(3)=1314; //change the forth value cout&lt;&lt;endl&lt;&lt;\"after change:\"&lt;&lt;endl; for(int i=0;i&lt;5;i++) &#123; cout&lt;&lt;vals[i]&lt;&lt;\" \"; &#125; return 0;&#125;","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"工具小整合","slug":"工具小整合","date":"2018-10-03T07:00:06.000Z","updated":"2018-10-07T09:23:10.230Z","comments":true,"path":"2018/10/03/工具小整合/","link":"","permalink":"https://yeshan333.github.io/2018/10/03/工具小整合/","excerpt":"","text":"百度文库、知网文章下载https://pan.baidu.com/s/1-BY2B4hBn_3wHgYlXkFLCg 百度云下载提速软件https://pan.baidu.com/s/1EYy5AN9JVv7m42f6NNmvlA 微软PE工具箱https://pan.baidu.com/s/1J1Nud9qTU6jSP6cTpk8Zlg window10数字权利激活工具 github: https://github.com/TGSAN/CMWTAT_Digital_Edition/releases https://github.com/vyvojar/slshim/releases 激活方法参考https://pan.baidu.com/s/1_VqJiuBeCHLyRp5Xcc562wkms激活工具win10下载 Gif制作工具https://pan.baidu.com/s/1Eu_O-7EPSB81cwmR-R1zvw提取码:q51n 录屏软件https://pan.baidu.com/s/1VsN5XClhZiRCqUyxbTJ_tg提取码:vlrb CamStudio汉化版提取码:kckg","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://yeshan333.github.io/tags/随笔/"}]},{"title":"C++入坑记(2)","slug":"C++-入坑记-2","date":"2018-10-03T03:47:26.000Z","updated":"2018-11-23T19:19:02.515Z","comments":true,"path":"2018/10/03/C++-入坑记-2/","link":"","permalink":"https://yeshan333.github.io/2018/10/03/C++-入坑记-2/","excerpt":"函数，默认参数的使用在C++中，允许在自定义函数的形参列表中，给形参一个默认的值，这样在调用的时候如果有实参，那么按照实参传递给形参的方法使用；若调用的时候没有指定对应的实参，则形参将使用默认值。由于参数的传递顺序是从右至左入栈，所以有默认值的参数必须在放在形参列表的最右边！","text":"函数，默认参数的使用在C++中，允许在自定义函数的形参列表中，给形参一个默认的值，这样在调用的时候如果有实参，那么按照实参传递给形参的方法使用；若调用的时候没有指定对应的实参，则形参将使用默认值。由于参数的传递顺序是从右至左入栈，所以有默认值的参数必须在放在形参列表的最右边！ 12345678910111213#include&lt;iostream&gt;using namespace std;int Sum(int a=4,int b=5)&#123; return a+b;&#125;int main()&#123; cout&lt;&lt;Sum(5,7)&lt;&lt;endl; cout&lt;&lt;Sum()&lt;&lt;endl; cout&lt;&lt;Sum(9)&lt;&lt;endl; return 0;&#125; 函数重载函数重载即两个或以上的函数，函数名相同，但形参类型或个数不同，编译器根据调用方传入的参数的类型和个数，自动选择最适合的一个函数来进行绑定调用，自动实现选择。123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;int sum(int a,int b)&#123; return a+b;&#125;double sum(double a,double b)&#123; return a+b;&#125;double sum(double a,int b)&#123; return a+b;&#125;double sum(int a,double b)&#123; return a+b;&#125;int main()&#123; cout&lt;&lt;sum(1,2)&lt;&lt;endl; cout&lt;&lt;sum(1.414,2.526)&lt;&lt;endl; cout&lt;&lt;sum(3.14,6)&lt;&lt;endl; cout&lt;&lt;sum(8,9.9)&lt;&lt;endl; return 0;&#125; 函数模板（template）模板是创建泛型类或函数的蓝图或公式。是泛型编程的基础。函数模板，是可以创建一个通用的函数，可以支持多种形参。用关键字template来定义模板函数定义的一般形式 template&lt;class 类型名1,class 类型名2&gt; 返回值 函数名(形参列表) { 函数体 } 1234567891011121314151617#include&lt;iostream&gt;using namespace std;template&lt;class T1,class T2&gt;T1 sum(T1 a,T2 b)//模板函数中的T1和T2类型将根据实际传入的类型变成具体类型。这个化成就叫做模板的实例化。//T1、T2是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。 &#123; cout&lt;&lt;sizeof(T1)&lt;&lt;\",\"&lt;&lt;sizeof(T2)&lt;&lt;\"\\t\"; return a+b;&#125;int main()&#123; cout&lt;&lt;sum(1,2)&lt;&lt;endl; cout&lt;&lt;sum(3.14,1.414)&lt;&lt;endl; cout&lt;&lt;sum('A',2)&lt;&lt;endl; return 0;&#125; inline内联函数 内联函数的基本思想在于将每个函数调用都以它的代码体来替换 内联函数减少了不必要的函数栈帧的开销,节约内存 内联函数以空间换取了时间，但是inline对编译器只是一个建议，如果定义的函数体内有循环或递归等，编译器优化时会自动忽略掉内联 12345678910111213#include&lt;iostream&gt;using namespace std; inline int Max(int a,int b)&#123; return a&gt;b?a:b;&#125;int main()&#123; cout&lt;&lt;Max(3,5)&lt;&lt;endl; cout&lt;&lt;Max(7,9)&lt;&lt;endl; return 0;&#125; 内联函数的定义要在调用之前出现","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"ACM入门（占个位）","slug":"ACM入门","date":"2018-10-02T14:48:28.000Z","updated":"2019-03-21T18:02:09.297Z","comments":true,"path":"2018/10/02/ACM入门/","link":"","permalink":"https://yeshan333.github.io/2018/10/02/ACM入门/","excerpt":"A+B for Input-Output Practice(using C++)1. Problem Description Your task is to Calculate a + b. Too easy?! Of course! I specially designed the problem for acm beginners. You must have found that some problems have the same titles with this one, yes, all these problems were designed for the same aim Input The input will consist of a series of pairs of integers a and b, separated by a space, one pair of integers per line. Output For each pair of input integers a and b you should output the sum of a and b in one line, and with one line of output for each line in input. Sample Input 1 61 20 Sample Output 721","text":"A+B for Input-Output Practice(using C++)1. Problem Description Your task is to Calculate a + b. Too easy?! Of course! I specially designed the problem for acm beginners. You must have found that some problems have the same titles with this one, yes, all these problems were designed for the same aim Input The input will consist of a series of pairs of integers a and b, separated by a space, one pair of integers per line. Output For each pair of input integers a and b you should output the sum of a and b in one line, and with one line of output for each line in input. Sample Input 1 61 20 Sample Output 721 1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123; int x,y; while(cin&gt;&gt;x&gt;&gt;y) &#123; cout&lt;&lt;x+y&lt;&lt;endl; &#125; return 0;&#125; 2. Problem Description The first line integer means the number of input integer a and b. Your task is to Calculate a + b. Input Your task is to Calculate a + b. The first line integer means the numbers of pairs of input integers. Output For each pair of input integers a and b you should output the sum of a and b in one line, and with one line of output for each line in input. Sample Input 210 2022 36 Sample Output 3058 1234567891011121314#include&lt;iostream&gt;using namespace std;int main()&#123; int n,i; int a,b; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;a+b&lt;&lt;endl; &#125; return 0;&#125; 3. Problem Description Your task is to Calculate a + b. Input Input contains multiple test cases. Each test case contains a pair of integers a and b, one pair of integers per line. A test case containing 0 0 terminates the input and this test case is not to be processed. Output For each pair of input integers a and b you should output the sum of a and b in one line, and with one line of output for each line in input. Sample Input 1 510 200 0 Sample Output 630 12345678910111213#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b; while(cin&gt;&gt;a&gt;&gt;b) &#123; if(a==0&amp;&amp;b==0)break; else cout&lt;&lt;a+b&lt;&lt;endl; &#125; return 0;&#125; 4. Problem Description Your task is to Calculate the sum of some integers. Input Input contains multiple test cases. Each test case contains a integer N, and then N integers follow in the same line. A test case starting with 0 terminates the input and this test case is not to be processed. Output For each group of input integers you should output their sum in one line, and with one line of output for each line in input. Sample Input 4 1 2 3 45 1 2 3 4 50 Sample Output 1015 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;n) &#123; if(n==0)return 0; int x,sum=0; while(n--) &#123; cin&gt;&gt;x; sum+=x; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125; 5. Problem Description Your task is to calculate the sum of some integers. Input Input contains an integer N in the first line, and then N lines follow. Each line starts with a integer M, and then M integers follow in the same line. Output For each group of input integers you should output their sum in one line, and with one line of output for each line in input. Sample Input 24 1 2 3 45 1 2 3 4 5 Sample Output 1015 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;int main()&#123; int N; int i; int n,x; cin&gt;&gt;N; for(i=0;i&lt;N;i++) &#123; int n; int x,sum=0; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;x; sum += x; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125; 6. Problem Description Your task is to calculate the sum of some integers. Input Input contains multiple test cases, and one case one line. Each case starts with an integer N, and then N integers follow in the same line. Output For each test case you should output the sum of N integers in one line, and with one line of output for each line in input. Sample Input 4 1 2 3 4 55 1 2 3 4 5 Sample Output 1015 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main()&#123; int n; int x,sum=0; while(cin&gt;&gt;n) &#123; while(n--) &#123; cin&gt;&gt;x; sum +=x; &#125; cout&lt;&lt;sum&lt;&lt;endl; sum=0; &#125; return 0;&#125; 7. Problem Description Your task is to Calculate a + b. Input The input will consist of a series of pairs of integers a and b, separated by a space, one pair of integers per line. Output For each pair of input integers a and b you should output the sum of a and b, and followed by a blank line. Sample Input 1 510 20 Sample Output 630 123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int x,y; while(cin&gt;&gt;x&gt;&gt;y) &#123; cout&lt;&lt;x+y&lt;&lt;endl; cout&lt;&lt;endl; &#125; return 0;&#125; 8. Problem Description Your task is to calculate the sum of some integers Input Input contains an integer N in the first line, and then N lines follow. Each line starts with a integer M, and then M integers follow in the same line Output For each group of input integers you should output their sum in one line, and you must note that there is a blank line between outputs. Sample Input 34 1 2 3 45 1 2 3 4 56 1 2 3 4 5 6 Sample Output 101521 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;int main()&#123; int N; int n,x; int sum=0; cin&gt;&gt;N; while(N--) &#123; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;x; sum +=x; &#125; cout&lt;&lt;sum&lt;&lt;endl; cout&lt;&lt;endl; sum=0; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://yeshan333.github.io/categories/ACM/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"},{"name":"ACM","slug":"ACM","permalink":"https://yeshan333.github.io/tags/ACM/"}]},{"title":"C++入坑记","slug":"C++-入坑记","date":"2018-10-01T16:40:03.000Z","updated":"2018-11-23T19:18:52.548Z","comments":true,"path":"2018/10/02/C++-入坑记/","link":"","permalink":"https://yeshan333.github.io/2018/10/02/C++-入坑记/","excerpt":"C++关键字https://www.runoob.com/w3cnote/cpp-keyword-intro.html asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template …","text":"C++关键字https://www.runoob.com/w3cnote/cpp-keyword-intro.html asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template … 入坑C++1234567891011#include&lt;iostream&gt; //文件包含，包含iostream标准库 using namespace std; //声明一个叫std的命名空间 int main()&#123; string my_name; int age; cin&gt;&gt;my_name&gt;&gt;age; cout&lt;&lt;my_name&lt;&lt;' '&lt;&lt;age; cout&lt;&lt;\"\\nHello C++ !\"&lt;&lt;endl&lt;&lt;\"Nice\"&lt;&lt;\"\\n\\n\"; cout&lt;&lt;\"Nice to meet you !\";&#125; 流提取运算符&gt;&gt;流插入运算符&lt;&lt; 什么是命名空间 命名空间(namespace)为防止名字冲突提供了更加可控的机制。 一个命名空间的定义包含两部分：首先是关键字namespace，随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类、变量(及其初始化操作)、函数(及其定义)、模板和其它命名空间。命名空间结束后无须分号，这一点与块类似。和其它名字一样，命名空间的名字也必须在定义它的作用域内保持唯一。命名空间既可以定义在全局作用域内，也可以定义在其它命名空间中，但是不能定义在函数或类的内部。命名空间作用域后面无须分号。 https://blog.csdn.net/fengbingchun/article/details/78575978?utm_source=copy只是新标准中使用不带.h的头文件包含时，必须要声明命名空间，并且包含头文件在前，声明使用的名字空间在后。 例如标准C++库提供的对象都存在std这个标准名字中，比如cin，cout，endl。 写法—1123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int a; cin&gt;&gt;a; cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;\"**************************\\n\"; cout&lt;&lt;\"Hello World!\"&lt;&lt;endl; cout&lt;&lt;\"**************************\\n\"; return 0;&#125; 写法—2使用域限定符::来逐个制定,cout和endl前面分别用std::指明，表示来自std1234567891011#include&lt;iostream&gt;int main()&#123; int a; std::cin&gt;&gt;a; std::cout&lt;&lt;a&lt;&lt;std::endl; std::cout&lt;&lt;\"**************************\\n\"; std::cout&lt;&lt;\"Hello World!\"&lt;&lt;std::endl; std::cout&lt;&lt;\"**************************\\n\"; return 0;&#125; 写法—3用using和域限定符一起制定用哪些名字1234567891011121314#include&lt;iostream&gt;using std::cin;using std::cout; using std::endl;int main()&#123; int a; cin&gt;&gt;a; cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;\"**************************\\n\"; cout&lt;&lt;\"Hello World!\"&lt;&lt;endl; cout&lt;&lt;\"**************************\\n\"; return 0;&#125; 在用cin和cout输入和输出数据时，不需要手动控制数据类型就可以使用 更新于2018/10/4 23:15:56 I/O库头文件&lt;iostream&gt;、&lt;iomanip&gt;、&lt;fstream&gt; 头文件 函数和描述 iostream 该文件定义了cin、cout、cerr和clog对象，分别对应于标准输入流、标准输出流、非缓冲标准错误和缓冲标准错误流 iomanip 该文件通过所谓的参数化的流操纵器（比如setw和setprecision），来声明对执行标准化I/O有用的服务 fstream 该文件为用户控制的文件处理声明服务","categories":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/categories/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://yeshan333.github.io/tags/CPP/"}]},{"title":"Requests库入门(2)","slug":"Requests库入门-2","date":"2018-10-01T10:58:54.000Z","updated":"2019-03-23T09:14:02.053Z","comments":true,"path":"2018/10/01/Requests库入门-2/","link":"","permalink":"https://yeshan333.github.io/2018/10/01/Requests库入门-2/","excerpt":"requests库入门实操 京东商品页面爬取 亚马逊商品页面的爬取 百度/360搜索关键字提交 IP地址归属地查询 网络图片的爬取和储存","text":"requests库入门实操 京东商品页面爬取 亚马逊商品页面的爬取 百度/360搜索关键字提交 IP地址归属地查询 网络图片的爬取和储存 1.京东商品页面的爬取华为nova3 123456789101112import requestsdef GetHTMLText(url): try: r = requests.get(url) r.raise_for_status() r.encoding = r.apparent_encoding return r.text[:1000] except: print(\"爬取失败\")if __name__ == '__main__': url = \"https://item.jd.com/30185690434.html\" print(GetHTMLText(url)) 2.亚马孙商品页面的爬取某些网站可能有反爬机制。通常的反爬策略有: 通过Headers反爬虫 基于用户行为反爬虫 动态页面的反爬虫参考 12345678910111213141516#如网站对Headers的User-Agent进行检测，可定制请求头伪装成浏览器import requestsdef GetHTMLText(url): try: #定制请求头 headers = &#123;\"user-agent\":\"Mozilla/5.0\"&#125; r = requests.get(url,headers = headers) r.raise_for_status() r.encoding = r.apparent_encoding return r.text[:1000] except: print(\"爬取失败\")if __name__ == '__main__': url = \"https://www.amazon.cn/gp/product/B01M8L5Z3Y\" print(GetHTMLText(url)) 3.百度/360搜索关键字提交使用params参数,利用接口keyword1234567891011121314151617181920212223#百度搜索引擎关键词提交接口: http://www.baidu.com/s?wd=keyword#360搜索引擎关键词提交接口: http://www.so.com/s?q=keywordimport requestsdef Get(url): headers = &#123;'user-agent':'Mozilla/5.0'&#125; key_word = &#123;'wd':'python'&#125; try: r=requests.get(url,headers=headers,params=key_word) r.raise_for_status() r.encoding = r.apparent_encoding print(r.request.url) #return r.request.url return r.text except: return \"爬取失败\"if __name__ == '__main__': url = \"http://www.baidu.com/s\" #print(Get(url)) print(len(Get(url))) 4.IP地址归属地查询使用IP138的API接口http://m.ip138.com/ip.asp?ip=ipaddress 12345678910111213# ip地址查询import requestsurl =\"http://m.ip138.com/ip.asp?ip=\"ip = str(input())try: r= requests.get(url+ip) r.raise_for_status() print(r.status_code) #r.encoding = r.apparent_encoding print(r.text[-500:])except: print(\"failed\") 5.网络图片的爬取和储存123456789101112131415161718192021222324# spider_for_imgsimport requestsimport osurl = \"http://n.sinaimg.cn/sinacn12/w495h787/20180315/1923-fyscsmv9949374.jpg\"#C:\\Users\\Administrator\\Desktop\\spider\\first week\\imgs/root = \"C://Users/Administrator/Desktop/spider/first week/imgs/\"path = root + url.split('/')[-1]try: if not os.path.exists(root): os.mkdir(root) if not os.path.exists(path): r = requests.get(url) with open(path, 'wb') as f: f.write(r.content) f.close() print(\"save successfully!\") else: print(\"file already exist!\")except: print(\"spider fail\")","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"Requests","slug":"Requests","permalink":"https://yeshan333.github.io/tags/Requests/"},{"name":"爬虫","slug":"爬虫","permalink":"https://yeshan333.github.io/tags/爬虫/"}]},{"title":"优雅的Markdown（2）","slug":"优雅的Markdown（2）","date":"2018-09-30T15:25:53.000Z","updated":"2018-10-06T16:18:58.232Z","comments":true,"path":"2018/09/30/优雅的Markdown（2）/","link":"","permalink":"https://yeshan333.github.io/2018/09/30/优雅的Markdown（2）/","excerpt":"Markdown编辑器使用-MarkdownPad2快捷键 粗体 ctrl+B 斜体 ctrl+I 引用 ctrl+Q 代码 ctrl+K 超链接 ctrl+L 图片 ctrl+G 无序列表 ctrl+U 有序列表 ctrl+shift+O 水平标尺 ctrl+R 时间戳 ctrl+T 撤销 ctrl+Z 重做 ctrl+Y","text":"Markdown编辑器使用-MarkdownPad2快捷键 粗体 ctrl+B 斜体 ctrl+I 引用 ctrl+Q 代码 ctrl+K 超链接 ctrl+L 图片 ctrl+G 无序列表 ctrl+U 有序列表 ctrl+shift+O 水平标尺 ctrl+R 时间戳 ctrl+T 撤销 ctrl+Z 重做 ctrl+Y 插入图片时间可使用MarkdownPad2默认的图床 MarkdownPad2使用的默认图床是imgur 插入视频演示戳这里","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://yeshan333.github.io/tags/markdown/"}]},{"title":"简单爬虫","slug":"简单爬虫","date":"2018-09-28T17:17:32.000Z","updated":"2018-09-29T15:19:00.000Z","comments":true,"path":"2018/09/29/简单爬虫/","link":"","permalink":"https://yeshan333.github.io/2018/09/29/简单爬虫/","excerpt":"Requests库入门http://www.python-requests.org/en/master/requests Requests库的7个主要方法 方法 说明 requests.request() 构造一个请求，支撑以下各方法的基本方法 requests.get() 获取HTML网面的方法 requests.head() 获取HTML网页头部信息的方法 requests.post() 向HTML网页提交POST请求的方法 requests.put() 向HTML页面提交PUT请求的方法 requests.patch() 向HTML网页提交局部修改请求 requests.delete() 向HTML网页提交删除请求","text":"Requests库入门http://www.python-requests.org/en/master/requests Requests库的7个主要方法 方法 说明 requests.request() 构造一个请求，支撑以下各方法的基本方法 requests.get() 获取HTML网面的方法 requests.head() 获取HTML网页头部信息的方法 requests.post() 向HTML网页提交POST请求的方法 requests.put() 向HTML页面提交PUT请求的方法 requests.patch() 向HTML网页提交局部修改请求 requests.delete() 向HTML网页提交删除请求 Requests库的get()方法requests.get(url,params=None,**kwargs) url：拟获取页面的url链接 params：url中的额外参数，字典或字节流格式，可选 **kwargs：12个控制访问的参数 r = requests.get(url) r为一个包含服务器资源的Response对象(即为requests.get()返回内容) get()方法和url构造了一个向服务器请求资源的Request对象 Response对象Response对象包含服务器反回的所有信息，也包含请求的Request信息 Response对象的属性 属性 说明 r.stats_code HTTP请求的返回状态，200表示连接成功 r.txt HTTP响应的字符串形式 r.encoding 从HTTP header中猜测的响应方式的内容编码 r.apparent_enconding 从内容中分析出的响应内容编码方式（备选编码方式） r.content HTTP响应内容编码的二进制形式 r.encoding:如果charset不存在，则默认编码为ISO-8859-1，r.text根据r.encoding显示网页内容 r.apparent_encoding：根据网页内容分析出的编码方式 理解Response异常r.raise_for_status()如果不是200，产生异常requests.HTTPError异常1r.raise_for_status()在方法内部判断r.statu_code是否等于200，不需要增加额外的if语句，该语句便于try-except进行异常处理 Requests库的异常 异常 说明 requests.ConnectonError 网路连接错误异常 requests.HTTPError HTTP错误异常 requests.URLRequire URL缺失异常 requests.TooManyRedirects 超过最大重定向次数，产生重定向异常 requests.ConnectTimeout 连接远程服务器异常 requests.Timeout 请求URL超时，产生超时异常 python爬取网页代码通用框架12345678910111213141516import requests#import timedef getHTMLText(url): try: r = requests.get(url,timeout = 30) r.raise_for_status()#如果状态不是200，产生HTTPError异常 #print(r.status_code) r.encoding = r.apparent_encoding return r.text except: return \"产生异常\"if __name__ == '__main__': url = \"http://www.baidu.com\" print(getHTMLText(url)) Requests库的request()方法requests.request(method, url, **kwargs) method: 请求方式，对应get/put/delete等7种 url:拟获取页面的url链接 **kwargs: 控制访问的参数 kwargs:控制访问参数，（可选）12345678910111213params：字典或字节序列，作为参数增加到URL中data：字典、字节序列或文章对象，作为Request的内容json：Json格式的数据headers：HTTP定制头cookies：字典或CookieJar，Request中的cookieauth：元组，支持HTTP认证功能file：字典类型，传输文件timeout：设置超时时间，单位为秒proxies：字典类型，设定访问代理服务器，可以增加登录认证allow_redirects：True/False，默认为True，重定向开关strem：True/False，默认为True，获取页面立即下载开关verify：True/False，默认为True,认证SSl证书开关cert：本地SSL证书","categories":[{"name":"Python","slug":"Python","permalink":"https://yeshan333.github.io/categories/Python/"}],"tags":[{"name":"Requests","slug":"Requests","permalink":"https://yeshan333.github.io/tags/Requests/"},{"name":"爬虫","slug":"爬虫","permalink":"https://yeshan333.github.io/tags/爬虫/"}]},{"title":"music","slug":"music","date":"2018-09-28T14:37:08.000Z","updated":"2019-01-06T17:26:09.160Z","comments":true,"path":"2018/09/28/music/","link":"","permalink":"https://yeshan333.github.io/2018/09/28/music/","excerpt":"网易云音乐","text":"网易云音乐","categories":[],"tags":[]},{"title":"优雅的Markdown","slug":"优雅的Markdown","date":"2018-09-28T08:49:47.000Z","updated":"2018-10-06T16:18:50.198Z","comments":true,"path":"2018/09/28/优雅的Markdown/","link":"","permalink":"https://yeshan333.github.io/2018/09/28/优雅的Markdown/","excerpt":"Markdown浅尝一、勾选框注意[]前后都要有空格1234- [x] 干的漂亮- [x] 吃饭- [x] 写代码- [ ] 睡觉 [x] 干的漂亮 [x] 吃饭 [x] 写代码 [ ] 睡觉","text":"Markdown浅尝一、勾选框注意[]前后都要有空格1234- [x] 干的漂亮- [x] 吃饭- [x] 写代码- [ ] 睡觉 [x] 干的漂亮 [x] 吃饭 [x] 写代码 [ ] 睡觉 二、列表12345#无序列列表 * 换成 - 也行* 你* 你好* 你好呀- 你很好啊 你 你好 你好呀 你很好啊 12345#有序列表 . 后面有个空格1. 我2. 是我3. 是我呀4. 还是我呀 我 是我 是我呀 还是我呀 1234567#多级列表* 数学 * 高等代数 * 解析几何 * 离散数学 * 数学分析 * 实变函数 数学 高等代数 解析几何 离散数学 数学分析 实变函数 表格1234| 姓名 | 性别 | 是否同性恋 || ---- |---- | --------- ||张三|男|否||李四|男|是| 姓名 性别 是否同性恋 张三 男 否 李四 男 是 可用:设置对齐方式1234| 姓名 | 性别 | 是否同性恋 || ---- |:----: | :---------:||张三|男|否||李四|男|是| 姓名 性别 是否同性恋 张三 男 否 李四 男 是 1234| 姓名 | 性别 | 是否同性恋 || ---- |----: | :---------:||张三|男|否||李四|男|是| 姓名 性别 是否同性恋 张三 男 否 李四 男 是 插入代码12#行内代码`printf(&quot;hello world!&quot;);` printf(&quot;hello world!&quot;); 代码块123#每行前四个空格或一个tab php:echo &quot;Hello World&quot; VBscript：Msgbox &quot;Hello World&quot; php:echo &quot;Hello World&quot; VBscript：Msgbox &quot;Hello World&quot; 有行标代码块 无行标12for i in range(4): print(i) bash换成python使用语法高亮 123#下划线使用&lt;u&gt;&lt;u&gt;bash换成python&lt;/u&gt;#换行使用&lt;br/&gt;、&lt;br&gt; 瞬间发现没什么区别 更新于2018/10/1 11:05:19 上下标,使用&lt;sup&gt;、&lt;sub&gt;12y=x&lt;sup&gt;2&lt;/sup&gt;H&lt;sub&gt;2&lt;/sub&gt;O&lt;sub&gt;2&lt;/sub&gt; y=x2H2O2 反斜杠的使用使用反斜杠可以避免文本中的符号被当作markdown标识符而发生不必要的转换 例如1234\\!\\()\\**不是粗体**\\# 不是一级标题 !()*不是粗体*# 不是一级标题 使用缩进1234567不断行的空白格 &amp;nbsp; 或 &amp;#160;半角的空格 &amp;ensp; 或 &amp;#8194;全角的空格 &amp;emsp; 或 &amp;#8195;示例:&amp;ensp; &amp;ensp今天天气好啊&amp;emsp;&amp;emsp;感觉倍爽啊 &ensp;&ensp;今天天气好啊&emsp;&emsp;感觉倍爽啊 不要忘了英文的分号 参考自zhouie","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://yeshan333.github.io/tags/markdown/"}]},{"title":"博客搭建历程（4）","slug":"博客搭建历程（4）","date":"2018-09-27T08:35:56.000Z","updated":"2018-12-27T04:27:10.327Z","comments":true,"path":"2018/09/27/博客搭建历程（4）/","link":"","permalink":"https://yeshan333.github.io/2018/09/27/博客搭建历程（4）/","excerpt":"博客评论系统的选择其他评论系统参考经过一波折腾，最终选择了Valine 我喜欢它的匿名评论，23333！！！ 参考教程 作者的博客 Valine文档 https://github.com/litten/hexo-theme-yilia/pull/646 https://www.xxwhite.com/2017/Valine.html https://panjunwen.com/diy-a-comment-system/","text":"博客评论系统的选择其他评论系统参考经过一波折腾，最终选择了Valine 我喜欢它的匿名评论，23333！！！ 参考教程 作者的博客 Valine文档 https://github.com/litten/hexo-theme-yilia/pull/646 https://www.xxwhite.com/2017/Valine.html https://panjunwen.com/diy-a-comment-system/ 安装过程简记 注册Leancloud 创建应用 获取appid和appkey 设置安全域名 部署云引擎 参考设置好环境变量 yilia主题修改1、修改themes\\yilia\\_config.ymlhttps://github.com/litten/hexo-theme-yilia/pull/646 12345678910#6、Valine https://valine.js.orgvaline: enable: true appid: #LeanCloud的appId appkey: #Leancloud的appKey verify: false #验证码 notifi: false #评论回复提醒 avatar: ' '#评论列表头像样式 placeholder: Just go go #评论占位框 pageSize: 15 #评论分页 2、修改themes\\yilia\\layout\\_partial\\article.ejs我是在尾部位添加的 123456789&lt;% if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt; &lt;section id=\"comments\" style=\"margin:10px;padding:10px;background:#fff;\"&gt; &lt;%- partial('post/valine', &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt; &lt;/section&gt; &lt;% &#125; %&gt; 在themes\\yilia\\layout\\_partial\\post下新建个·valine.ejs·文件添加如下代码123456789101112131415161718&lt;div id=\"vcomment\" class=\"comment\"&gt;&lt;/div&gt; &lt;script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"&gt;&lt;/script&gt;&lt;script src=\"//unpkg.com/valine/dist/Valine.min.js\"&gt;&lt;/script&gt;&lt;script&gt; var notify = '&lt;%= theme.valine.notify %&gt;' == true ? true : false; var verify = '&lt;%= theme.valine.verify %&gt;' == true ? true : false; window.onload = function() &#123; new Valine(&#123; el: '#vcomment', notify: notify, verify: verify, app_id: \"&lt;%= theme.valine.appid %&gt;\", app_key: \"&lt;%= theme.valine.appkey %&gt;\", placeholder: \"&lt;%= theme.valine.placeholder %&gt;\", avatar:\"&lt;%= theme.valine.avatar %&gt;\" &#125;); &#125;&lt;/script&gt; 测试下效果hexo g hexo s 预览 没问题就部署到github吧 hexo d -g 定时器添加https://github.com/zhaojun1998/Valine-Admin/issues/1","categories":[{"name":"blog","slug":"blog","permalink":"https://yeshan333.github.io/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://yeshan333.github.io/tags/hexo/"}]},{"title":"Markdown(2)","slug":"Markdown-2","date":"2018-09-26T15:24:26.000Z","updated":"2018-10-06T16:18:20.372Z","comments":true,"path":"2018/09/26/Markdown-2/","link":"","permalink":"https://yeshan333.github.io/2018/09/26/Markdown-2/","excerpt":"兴奋于搭建了我的博客，兴奋于认识了markdown，终于可以甩开花里胡哨的word了，233333！！！ 认识Markdown Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例LaTeX，Docbook。 Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。 —引自百度百科","text":"兴奋于搭建了我的博客，兴奋于认识了markdown，终于可以甩开花里胡哨的word了，233333！！！ 认识Markdown Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例LaTeX，Docbook。 Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。 —引自百度百科 Windows常用Markdown编辑器 VSCode 下载 Atom 下载 CuteMarkEd 下载 MarkdownPad2 下载 MarkPad 下载 Miu 下载 Typora 下载 RStudio 下载 Markdown语法说明-中文版为什么使用Markdown 它使我更加专注于文字内容而不是排版样式 We believe that writing is about content, about what you want to say – not about fancy formatting. —Ulysses for Mac [高级应用](https://blog.mariusschulz.com/2014/12/16/how-to-set-up-sublime-text-for-a-vastly-better-markdown-writing-experience) Sublime Text3+Markdown Editing 参考","categories":[{"name":"markdown","slug":"markdown","permalink":"https://yeshan333.github.io/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://yeshan333.github.io/tags/markdown/"}]},{"title":"博客搭建历程（3）","slug":"博客搭建历程（3）","date":"2018-09-26T12:11:17.000Z","updated":"2019-07-11T07:56:01.420Z","comments":true,"path":"2018/09/26/博客搭建历程（3）/","link":"","permalink":"https://yeshan333.github.io/2018/09/26/博客搭建历程（3）/","excerpt":"hexo生成工程文件介绍 hexo插件 主题yilia 默认目录结构具体参考","text":"hexo生成工程文件介绍 hexo插件 主题yilia 默认目录结构具体参考 |--.deploy |--public |--scaffolds |--source |--themes |--_config.yml |--package.json .deploy ：部署到GitHub上的内容目录 public：输出的静态网页内容目录 scaffolds：layout模板文件目录 source：文件源码目录 themes：主题文件目录 —config.yml：全局配置文件 package.json：应用程序数据 给主题yilia配置干货一、腾讯公益404公益404 hexo new page 404 #新建一个页面 1234567891011#在生成的index.md文件下添加以下代码&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;]\\&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;404&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1hexo d -g#直接部署到GitHub 参考 二、制作个网站ico戳这里 也可以不弄，直接用 把你的网站ico放在public\\img即可修改theme\\_config.yml 三、使用网站访问量统计(使用友盟)效果如下 注册账号友盟官网 获取代码 在hemes\\yilia\\layout\\_partial\\footer.ejs挑个位置放 12hexo ghexo s 看下效果 hexo d #部署到 github 若不想用CNZZ参考","categories":[{"name":"blog","slug":"blog","permalink":"https://yeshan333.github.io/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://yeshan333.github.io/tags/hexo/"}]},{"title":"xuxu","slug":"xuxu","date":"2018-09-26T09:13:00.000Z","updated":"2018-09-26T09:13:17.361Z","comments":true,"path":"2018/09/26/xuxu/","link":"","permalink":"https://yeshan333.github.io/2018/09/26/xuxu/","excerpt":"baidu收录测试","text":"baidu收录测试","categories":[],"tags":[]},{"title":"博客搭建历程（2）","slug":"博客搭建历程（2）","date":"2018-09-25T15:31:27.000Z","updated":"2019-07-11T07:41:43.576Z","comments":true,"path":"2018/09/25/博客搭建历程（2）/","link":"","permalink":"https://yeshan333.github.io/2018/09/25/博客搭建历程（2）/","excerpt":"一、使用hexo deploy部署博客到Github 使用参考 先安装个扩展$ npm install hexo-deployer-git --save 1.修改博客根目录下的_config_yml文件 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:yeshan333/yeshan333.github.io.git # 这个可到Github仓库拿 branch: master","text":"一、使用hexo deploy部署博客到Github 使用参考 先安装个扩展$ npm install hexo-deployer-git --save 1.修改博客根目录下的_config_yml文件 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:yeshan333/yeshan333.github.io.git # 这个可到Github仓库拿 branch: master 2.部署到GitHub repo生成ssh keys1ssh-keygen -t rsa -C \"邮件地址@youremail.com\" #生成新的key文件，邮箱地址填注册Github时用的 将生成的ssh keys添加到Github的deploy keys中 复制key 这里用到.ssh目录下，id_rsa.pub文件中的那串key 到GitHub的yourname.hithub.io仓库添加那串key到deploy keys中 测试一下是否添加成功了: 1ssh -T git@github.com 部署博客 先配好git用户信息 12git config --global user.name \"你的名字\" # github用户名git config --global user.email \"邮箱@邮箱.com\" # github邮箱 部署博客到仓库 12hexo g # 生成静态文件hexo d # 部署到远程仓库 访问https://yourname.github.io查看结果 到此，整个博客搭建完成了 以下是写的是博客主题的更换，主题可以自己写，也可以使用别人写的，可去这里https://hexo.io/themes/找喜欢的主题，如果使用的是别人的主题，需要阅读主题使用文档进行相关配置。 二、Hexo主题设置 更换主题 cd进themes目录 12cd themesgit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 对根目录下的config_yml文件进行修改 12cd themes/yiliagit pull #更新主题 预览新主题 123hexo clean # 清楚缓存，删除public目录hexo g # 生成新的博客静态文件hexo s 去http://localhost:4000预览，没毛病就hexo d部署到远程仓库。","categories":[{"name":"blog","slug":"blog","permalink":"https://yeshan333.github.io/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://yeshan333.github.io/tags/hexo/"}]},{"title":"博客搭建历程（1）","slug":"博客搭建历程（1）","date":"2018-09-25T14:40:31.000Z","updated":"2019-08-03T10:19:11.833Z","comments":true,"path":"2018/09/25/博客搭建历程（1）/","link":"","permalink":"https://yeshan333.github.io/2018/09/25/博客搭建历程（1）/","excerpt":"我为什么要搭建自己的博客:人嘛!总会有迷茫的时候。无聊了就搭建一个博客玩玩。借此思考下人生戳这里先洗下脑 [BetterExplained]为什么你应该（从现在开始就）写博客 使用Hexo+GitHub Pages搭建属于自己的博客依赖 安装Node.js 安装git 一个GitHub账号 hexo全家桶","text":"我为什么要搭建自己的博客:人嘛!总会有迷茫的时候。无聊了就搭建一个博客玩玩。借此思考下人生戳这里先洗下脑 [BetterExplained]为什么你应该（从现在开始就）写博客 使用Hexo+GitHub Pages搭建属于自己的博客依赖 安装Node.js 安装git 一个GitHub账号 hexo全家桶 一、Node.js安装参考Node.js官网 nodejs版本越高越好，不然后面安装hexo时会出现问题，Hexo官网给的建议是6.9版本以上 官网windows 64bit 下载(v10.16.0) 二、git的安装参考安装需根据自己的实际情况，在cmd使用git --version指令可以查看安装的版本 windows 64 bit 下载（v2.19.0） 三、使用Github Pages 注册Github账号 创建一个repository，用于存放博客站点文件 开启Github Page 1、创建一个repository 仓库命名方式须注意下，这样命名会开启githubpage服务，代码仓库命名方式随意，如果以用户名+github.io的形式命名，会自动开启Github Pages服务，否则需要自己在仓库的设置那里手动开启GIthub Pages服务。 Github Pages 是 github 公司提供的免费的静态网站托管服务，用起来方便而且功能强大，不仅没有空间限制(为免费用户提供了500M空间)，还可以绑定自己的域名，1GB空间限制（个人博客够用了），每月带宽限制100GB，自由绑定自己的域名。 2、开启GitHub PagesGitHub Pages官方介绍，Github的中文官方文档已推出https://help.github.com/cn/articles/what-is-github-pages(2019年7月11日更新) 点击choose a theme选完主题后即可到https://yourname.github.io/访问自己的个人主页了，yourname记得替换成你的用户名。 接下来需要使用Hexo在本地创建好博客，再将博客文件上传到刚刚创建的仓库。 四、Hexo配置 Hexo是一个静态站点生成器，如果想深入了解Hexo可以去Hexo的官网看看。https://hexo.io/zh-cn/docs/ 在本地搭建博客1.安装hexo插件套装以下两条命令直接打开windows cmd执行即可，用git bash执行也行 12# 安装hexo命令行工具npm install hexo-cli -g 安装hexo包到全局node_modules中，修改package.json文件，将模块名和版本号添加到dependencies部分npm install hexo —save~ 2.初始化hexo 这里需要新建个目录用于存放本地的博客文件 往后的命令均需要在此目录下执行，可用cd命令进入目录中执行往后的命令 1hexo init # 初始化目录，生成相关文件 目录中生成的文件如下 123456789101112.├── node_modules # 存放博客依赖的npm packages├── scaffolds # 存放生成博客文章、博客页面、草稿的模板目录├ ├── draft.md├ ├── page.md├ └── post.md├── source├ └── posts # 用于存放博客文章├── _config.yml # 博客全局配置文件├── .gitignore├── package.json # 记录当前目录下实际安装的各个npm package的具体来源和版本号└── package-lock.json # 存放锁定安装时的包的版本号，此文件一般会上传到git 12hexo g # 生成静态页面hexo s # 部署到本地服务器http://localhost:4000/ 预览效果http://localhost:4000/ 到这里本地的博客搭建完了，接下来就是将博客上传到刚刚创建的Github仓库，上传后就可以使用外网访问了 博客搭建历程（2） 博客搭建参考教程推荐 csdn w3cschool 博客园 思否","categories":[{"name":"blog","slug":"blog","permalink":"https://yeshan333.github.io/categories/blog/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://yeshan333.github.io/tags/hexo/"}]},{"title":"Markdown","slug":"Markdown","date":"2018-09-25T10:34:13.000Z","updated":"2018-10-06T16:18:12.154Z","comments":true,"path":"2018/09/25/Markdown/","link":"","permalink":"https://yeshan333.github.io/2018/09/25/Markdown/","excerpt":"体验markdown有点意思，哈！ 同级文件夹，的img文件夹下的图片 添加链接我的博客 添加图片","text":"体验markdown有点意思，哈！ 同级文件夹，的img文件夹下的图片 添加链接我的博客 添加图片 一级引用 要判断一个人是否真正聪明，那就要看他能否根本不用动手，而工作却又能完成。 二级引用 在C++里, 想搬起石头砸自己的脚更为困难了。 不过一旦你真这么做了, 整条腿都得报销! 列表的使用一级列表 python Java c++多级列表 数学分析 高等代数 解析几何 插入代码行内代码printf(&quot; hello world &quot;); 块代码,每行代码前四个空格或一个tabWocao Nimei Fenced Code Block12for i in range(4): print(i) 划重点人生苦短 下划线干的漂亮 删除线这都什么鬼 这里是斜体这里是粗体这里是粗斜体 利用html标签换行有点意思 这里是表格 浏览器 好 坏 google 1 0 firefox 1 0 使用font标签控制字体颜色红色 自定义字体样式、颜色、大小","categories":[{"name":"markdown","slug":"markdown","permalink":"https://yeshan333.github.io/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://yeshan333.github.io/tags/markdown/"}]},{"title":"hello my first blog in here ！","slug":"hello-my-first-blog-in-here-！","date":"2018-09-19T15:14:15.000Z","updated":"2019-04-23T15:22:45.181Z","comments":true,"path":"2018/09/19/hello-my-first-blog-in-here-！/","link":"","permalink":"https://yeshan333.github.io/2018/09/19/hello-my-first-blog-in-here-！/","excerpt":"","text":"New Start","categories":[],"tags":[]}]}